# My R script for flow cytometry analysis in R in a literate org doc

* TODO Issues [75%]

    - [ ] look into Christian's approach for fsc correction

    - [ ] addn. 2D correlation plots
      + FSC w/ fluors
      + FSC/SSC (already have)
      + fluors w/ TFT ratio 
      + all w/ time as neg. ctrl 

    - [X] +finish formatting so it can run from MSI+
      + +might also make a script to move stuff to and from MSI+
        - +stick the R CMD batch in the middle, then delete everything when finished+
        - +could rsync the dirs too to get all the results, none of the fcs+

    - [X] +remove any 'adjust = ' from density plots+
      + +test w/ no adjust syntax in plot code+

    - [X] +re-write code for replicate plots+
      + +ea. replicate = separate color+
      + +mean trace = black+

    - [X] +re-do gating so that we take +/- 1.5 SDs of FSC and SSC instead of curv gate+

    - [X] +more sensible legends+
      + +stop using+ "_"

    - [X] +increase lwd on density plots+
      + +maybe 1.5-2.5x+

#+NAME: christian_fsc_correction
#+BEGIN_SRC R

subdataMC<-subdataMC[subdataMC$FSC.A>0 & subdataMC$SSC.A>0 & subdataMC$mCherry.A>0 & subdataMC$GFP.A>0,]
subdataMC<-subdataMC[log(subdataMC$GFP.A)>4.8,]
#plot(log(subdataMC$GFP.A),log(subdataMC$mCherry.A))test<-loess(log(subdataMC$mCherry.A)~subdataMC$FSC.A)
subdataMC$mCHc<-unlist(test$residuals)+mean(log(subdataMC$mCherry.A))
test2<-loess(log(subdataMC$GFP.A)~subdataMC$FSC.A)
subdataMC$GFPc<-unlist(test2$residuals)+mean(log(subdataMC$GFP.A))

#+END_SRC

* Misc. Notes
Remember that you can use radio buttons in the code as a means of generating
links in the written portion of this document:

[[goes_here][this_link]]

<<goes_here>>

* Flow Analysis Overview
My approach to flow cytometry data analysis in R is to collect 10-50,000 cells
of multiple biological replicates of the same strain/reporter and compare these
across strains/reporters for a single flow session.  At present, I typically
fill a 96-well plate with 7-8 biological replicates of each strain/reporter of
interest and collect 10,000 cells from each well.  Collecting more cells per
well (e.g., 50,000) does not seem to change the results appreciably and for
several of the downstream analyses in this document, the mean of these 10,000
cells is used as a single data point, making collecting additional cells
unnecessary.

* [[Required_Packages]]
The analysis requires several packages from both regular R package repositories
and Bioconductor.  Setting up the script so that the packages are installed if
they're not available has proven challenging.  I've attempted to do this using
MSI as a test of whether the scripts are working.  Access to R through MSI is
illustrated in the following script:

#+NAME: MSI_login_R_load
#+BEGIN_SRC bash
## -----
## login to MSI/mesabi
ssh mahlon@login.msi.umn.edu
ssh mesabi

## albert lab compute node
ssh cn5711


## -----
## determine which R versions are available
module avail R

## load the latest version
module load R/3.6.0
## now calling R should load the above version (3.6.0)
R
#+END_SRC

Installing packages, in particular Bioconductor packages, has been challenging
using MSI.  One of the issues has been error messages about directory locking
during package installation.  A solution to this issue is described here:
[[https://stackoverflow.com/questions/14382209/r-install-packages-returns-failed-to-create-lock-directory][SO_link]]

The solution boils down to setting an option for the install to [['--no-lock']] as
shown in the link.  This seems to work with both 'install.packages' and
'BiocManager::install'.

* [[Color_Setup]]
#+DATE: 2020.04.21
My color setup uses the same color for each strain background.  So, for example,
the BY strains always use the same blue color, the RM strains always use the
same magenta color, etc...  I used to use a setup wherein the number of colors
was set programmatically (using the 'rainbow' function) based on how many
strains were present.  The issue with this approach is that the strains never
had the same colors across plots/flow runs and I found myself changing the
strain colors by hand in inkscape, which is not desirable.

My current approach Using the same color for each strain background also has
limitations.  Namely, you can't plot multiple reporters in the same strain
background in the same plot.  For now, I'm not concerned about this issue, as
I'm typically plotting one reporter per plot.  Should the need arise to plot
multiple reporters and strain backgrounds in a single plot, varying the line
type is an easy solution to this issue.

Developing an approach to set the strain colors was not straightforward.  The
current approach seems to work, but is not especially elegant or efficiently
coded.  The idea behind the approach is to create association lists of strain
background and color.  Then, the strain list (those strains that were analyzed
for a particular run) is used to filter the strain-color association list.  The
result is a list of colors that is the same length as the strain list.  Getting
there is not particularly straightforward.  I use the following steps:

    - [1] 'sapply' the strain-color regular expression as a pattern for 'grepl'
      and use the strain names as the vector to match against.  The result of
      this operation is an n*6 table, where n is the number of strains.

    - [2] 'sapply' each column of the n*6 table.  I collapse across the rows in
      each column to a single, logical value.  Basically, if a strain name
      matched, keep it, if it didn't, discard it.  The result is a logical
      vector the same length as the color list

    - [3] I then unlist the color list and subset on the logical vector above.
      This gives a color vector that is the same length and order as the strain
      list and can be used in subsequent plotting operations.

For the FSC density curves, I take advantage of the fact that:

length(all.set) == length(all.cols)

and 'Map' over both to get density plots that are colored by strain.

* [[Reading_FCS_Files]]
I've attempted to automate as much of the analysis of flow data as possible.
The user needs to input information in certain places, however, and I've marked
these places with the following placeholder:

##############
## USER INPUT:
##############

My general approach to analyzing the data after loading required packages is as
follows:

    - [1] set the working directory to the location of the data

    - [2] build a directory structure for data, scripts, and results files:
          + directories for:
            - fcs files
            - results
            - tables
            - scripts

    - [3] read .fcs files using regex for strains
          + regex is:
            - strain
            - reporter
            - replicate
              > e.g., BY_rpn4_TFT_004.fcs

    - [4] provide descriptive strain names for the plots
          + e.g., "no reporter", "BY rpn4_sfGFP_TFT", etc...

Once I've finished these steps, I build a list whose elements are the regex I'll
use to read fcs files for individual strains.  I use lapply to find all the
files that match all the strain names using the 'read.flowSet' function with a
pattern option.  The result is a list of ungated flowsets named 'all.strains'.
The length of all.strains is equal to the number of strains analyzed.  So, if I
had the following strain regex list:

no.reporter   <- ".*untagged.*fcs"
by.rpn4.tft   <- "BY.*rpn4.*.fcs"
rm.rpn4.tft   <- "RM.*rpn4.*.fcs"
rpn4.rpn4.tft <- "rpn4.*rpn4.*.fcs"

'all.strains' would be of length 4.  To access the individual replicates that
make up each list element of all.strains, I would use syntax like:

all.strains\[[2]\]\[[4]\], which would access the fourth replicate of
'by.rpn4.tft' above.

In flowcore parlance, a 'flowSet' is simply a list of 'flowFrames', where
flowFrames are individual .fcs files.


-----
To ensure the regex I set up work as intended, I also write the replicate
groupings of each flowSet in 'all.strains' to a table.   I recently (2020.03.05)
re-did the function that groups the strains to write a more R/UNIX friendly
table that shows which group each fcs file was assigned to and which regex was
used to place it in a group.  The table is easily viewed using the following:

column -t -s "," ./strain_replicate_groupings.txt

* [[TFT_Transformation]]
I apply two transformations to each flowframe initially:

    - [1] truncation transformation
          + this converts 0's to 1's in the fluor channels
          + this allows us to log10 transform the fluors
            - i.e., log10(0) = -inf

    - [2] ratio transformation
          + this gives us the TFT and PSV ratios
            - TFT ratio = log2(RFP/GFP)
            - PSV ratio = log2(GFP/RFP)

I use lapply in combination with its flowCore equivalent, 'fsApply'.  The
result is that we apply the transform function to each flowframe via 'fsApply'
via applying the function to each element of 'all.set' through 'lapply'.  i.e.,
lapply fsApply using all.set.

* [[Cell_Gating]]
This analysis considers each sample at three levels of gating:

    - [1] ungated
    - [2] forward/side scatter (FSC/SSC) gating out of cell clumps and
          non-cellular debris
    - [3] FSC-based gating of haploids

For a sample of 10,000 cells, I expect the following numbers of cells for each
gate:

    - [1] ungated :: 10,000
    - [2] FSC/SSC :: 7,600
    - [3] FSC haploid :: 2,400

The FSC/SSC gating is done using the 'curv2Filter' function, which finds areas
of high local density in a sample.  The key parameters are the bwFac (bandwidth
factor) and the gridsize.  Basically, I set these to large values to grab the
central 'cloud' of cells in the sample.  This is relatively crude, but should
eliminate clumps of cells (high FSC/SSC) and non-cellular debris (low FSC/SSC).

The FSC haploid gating is a more restrictive gating approach that removes
approximately 75% of the cells from the sample.  The FSC density plot of haploid
cells is characterized by a high peak and long, descending right shoulder.  I
take the cells in the 10% above and 10% below of the peak.  This nicely captures
the peak and excludes everything else in the plot.  My preliminary results
suggest that the effect of this gating is to reduce the variance of the sample,
without altering the mean/median of the fluorescent reporters.

I plot the gating results a lot of different ways, with the overall goal being
to ensure that any results I observe from the reporters are not a result of a
gating mishap.  I plot both the entire sample with the gate overlaid, as well as
the gated populations themselves to ensure that the results align with each
other at each step in the process.

[[FSC_SSC_Gate]]
This is a curv2Filter gate with large bandwidth settings.  By comparison, a very
tight FSC/SSC gate would use a bwFac setting of 2.  Here, I used a bwFac setting
of 7.  I write this as a custom function then use 'lapply' and 'fsApply'
together to apply it to each sample in the run.  The data structure of the
samples are as follows:

'all.set' is the entirety of the samples.  It is a list of flowSets and each
flowSet is a list of flowframes (individual flow cytometry runs).  Therefore,
lapply applies the fsApply function to each element of the 'all.set' list.  In
turn, fsApply applies the custom gating and splitting function to each flowframe
in each all.set list element.  The result ('initial.split.all') is a list of
gated flowSets.

[[FSC_Gate]]
This gate takes the 10% of cells above and 10% of cells below the peak of the
FSC density plot.  To get the values of this gate, I wrote a custom function
'fsc.gate.generator'.  The values 'fsc.gate.generator' returns are used to split
the cells using the 'rectangleGate' function.  A nice feature of 'rectangleGate'
is that only 1 dimension needs to be input (in this case, FSC).  If no value is
supplied for the other dimension (in this case, SSC), the function simply takes
the min/max values for that parameter.  Therefore, the resulting split gates the
cells on FSC without applying any gating on SSC.

* [[Gate-Based_Subsetting]]
The gated cells are put into the following lists:

    - [1] FSC gated - c.final.frame
    - [2] FSC/SSC gated - i.final.frame
    - [3] ungated - u.final.frame

Because each sample in each of the above lists is still coded as a flowset, I
use 'lapply' and 'for' loops to subset the flowSets.  These then get combined
into a long, ungrouped list (i.e., no grouping of replicates by strain).  I then
combine these long lists into a single list, 'all.data', for further analysis.
This structure works well for single-sample analyses.  I then group back into
strain groups later in the analysis.

For both the FSC/SSC and FSC-based gatings, the flowSets that result have a
length of 1 (because I keep only the populations I'm interested in).  The
alternative would be to include all populations, which would produce flowSets
with length > 1.  For example, with the FSC gate, if I kept all populations, the
result would be a list with length 2, with population 1 ('rectangleGate+') and
population 2 ('rest').  Because I only keep the population I'm interested in,
the subsetting I use needs only to take the first (i.e., only) flowFrame from
each sample's flowSet.

I then apply the tube name to each element of the gated and ungated data.
Applying this name allows me to group samples using regular expressions in a
later step. To do so:

    - [1] return sample names by printing the original tube name from the fcs
          files ('tube.names')

    - [2] use 'grepl' to return a logical vector of whether each fcs file
          matches a given strain regular expression
          + e.g., "RM.*.fcs" matches RM, doesn't match doa10

    - [3] subset the long list of ungrouped flowsets using 'lapply' with the
      logical vectors below.

    - [4] this creates three-tiered list structure
          + 1. gate (curv, initial, or ungated)
          + 2. strain (BY, RM, rpn4, etc...)
          + 3. replicate (001, 002, etc...)

    - [5] use the set2Frame function to merge all replicates into a single frame

* [[Cell_Count_Table_and_Plots]]
I create a table of the cell counts for each gate (curv, initial, or ungated)
for each sample.  Each gate is a column in the table.  Strain is a factor with
each genetic background being a level.  The ungated cells are a control for the
process by which we get cell counts, i.e., the value should be the same for all
samples (e.g., 10,000).  I write the cell counts to a .txt table then read this
information in for plotting of cell counts by strain by gate.  The cell count
plots are basic box plots.  I don't set the y axis for these plots, which tends
to exaggerate the differences, but I'm not likely to use the plots for
publication, so I don't think this is a critical issue.

* [[Check_Gate_Groupings]]
This section provides another check on the results of my analysis to ensure that
samples were separated into appropriate groups.  It writes a data file that
shows which samples were grouped together at each of the three gating levels
(curv, initial, and ungated).  The output is not a table, but rather a list of
the sample names and their grouping at each gating level.

* [[Data_Frame_Conversion]]
The code so far accesses sample data stored in the flowFrame data structure.
For the subsequent analyses, it is useful to have the data in the more
accessible dataframe format.  Therefore, I use an 'lapply' call to a custom
function that converts each flowFrame into a dataframe and store the output in
the object 'all.data.e' (where 'e' = 'exprs').

I then save the flowFrames and exprs matrices as R objects in case I need to
access them again in the future.  The objects can be quite large (> 18 mb), so
I may consider deleting these in the future.

* [[Between_Groups_Processing]]
This step creates an object ('all.groups.e') that merges individual replicates
into a single dataframe.  Since the call is made via 'rbind', the resultant
object is a dataframe, NOT a flowFrame.  I nest multiple 'lapply' calls to cover
the following levels:

    - [1] all.data.e\[\[1:n\]\]
          + the different gate levels

    - [2] all.data.e\[\[1:n\]\][\[1:n\]\]
          + the different strain levels

The result is that each strain at each gating level is merged into a single
dataframe for subsequent between-groups analyses.

Note that the 'rbind' step MUST be done via 'do.call' or it won't work.

I then add strain names to each dataframe that results from this operation.


-----
In the last step of this analysis, I create a new object 'cell.counts', that I
use to make a table of the total number of cells for each strain background.
This is simply the values from each individual replicate summed.  I write the
output of this operation to a separate table, 'total_cells_per_group_gate.txt'.
The table can be viewed in shell using 'column -t -s ","
./total_cells_per_group_gate.txt'.  

* [[Between_Groups_Plots]]
This analysis creates density plots that show the between-strains effects at the
group level (i.e., does not show any individual replicates).  The idea is to
group all the cells of a given strain background and build a density plots that
compares all strains for all collected parameters.

I set up a number of custom parameters here that are not data-driven and just a
result of my own experience with flow data that I produce.  I haven't come up
with a good way to generate data-driven axes and given how much individual
reporters vary across the parameter space, I'm not sure I want to.  The
standardized values for each parameter mean that the axes have the same values
across runs, which is nice for comparison purposes.  A related issue has been
positioning the legend in a way that doesn't obscure data.  I tried to do this
in a parameter-driven way previously, but now just put it at "topleft".  This
doesn't seem to affect any of the key plots and I can always move stuff in
inkscape if needed.  Another advantage of custom, user-input axis values is
protection against extreme values.  For example, the TFT ratio can be extremely
high in the untagged strains, because the GFP and RFP signals are a result of
stochastic detector noise.  So, values of RFP = 500 and GFP = 4 yields a TFT
ratio of 500/4 = 125.  A typical TFT ratio doesn't exceed 1.  However, since R
sets the axes based on maximum values, the above scenario would produce a TFT
ratio plot with an improper axis for viewing between groups differences. 

I do use custom code to get the y-axis values of the density plot.  This is
critical for overplotting between-groups data.  In particular, for the TFT
ratio, deletion strains typically have high maximum density values that center around 0
(in log2 space).  In contrast, wild-type strains with high degrons have low
maximum density values and extend into negative side of the number line in the
log2 plot.  Therefore, I get the maximum y value from the density of each group
at each gate level and use this as the y axis value for the between groups
plots.  I multiply this value by a scaling factor (1.1) to ensure that no data
extends out of the plotting area. 

The actual plotting is done via a call to 'Map' using gate and the names of the
gates for grabbing data and file naming, respectively.  Within this 'Map' call,
I loop over (1) parameters via a 'for' loop, (2) strains via a 'Map' loop, and
(3) strain names via a 'Map' loop to generate all combinations of gates and
parameters.  

* [[Between_Groups_Replicates]]
This analysis creates density plots between groups, with individual replicates
plotted as thin lines and the group average plotted as a thick line.  The idea
is to loop over gates, then over parameters, then over strains, then over
individual replicates.  The strain groups and individual replicates are
separately looped via their corresponding objects ('all.groups.e', 'all.data.e',
respectively).

To generate the plots, I make an empty plot for each parameter then use 'Map'
and 'lapply' functions to add the strains and replicates.  The lines for the
individual replicates are added via a nested 'lapply' function.  The key to
visualizing the individual replicates and group averages is using a thin line
for individual replicates and a thick line for group averages.

* [[Between_Gates_Plots]]
This analysis overplots each parameter at the three different gate levels I use
(FSC ['curv'], FSC/SSC ['initial'], and ungated).  The idea behind the analysis
is to examine how each parameter changes as a result of the gating operations I
perform.  In general, the gating reduces variability but does not alter the
parameter mean/median (or has a smaller effect on mean/median).  I apply the
strain colors to each plot and distinguish between gating levels by varying the
line type for each gate level.

I perform these analyses on the grouped data (all replicates of a given genetic
background as a single dataframe).  I use a custom function to get the y limit
value for each density plot.  The ylim will, in practice, almost always come from the
ungated cells, but I run it across gates just to be safe.

I use a 'Map' call with a custom function to do all plotting.  I map across
genetic backgrounds and strain names.  The former get the data for the plot, the
latter get the file name and plot titles.  The initial call to 'plot' starts
uses the 'curv' gate, which actually has the lowest values for most parameters,
but it doesn't matter because the x/y axes limits are set via custom objects.

* [[Replicate_Plots]]
This analysis creates density plots of each replicate of a strain/reporter for
each parameter collected.  The goal is to use a separate color for each
replicate to make identifying outlier samples easier.  In addition to each
replicate, the combination of all replicates as a single sample is plotted for
comparison (in a neutral gray color).  The plotting is performed for each of the
three gating levels (FSC ['curv'], FSC/SSC ['initial'], and ungated).

We start by 'lapply'ing over the 'all.groups.e' object, which groups all of the
replicates as a single strain background.  In general, the code here involves
looping over looping first over the gating level, then over the strain level,
then over the individual replicates.

I use the 'all.groups.e' object to get y axis limits for each plot.  In
practice, this can lead to individual replicates extending outside the plotting
area, but this isn't a critical issue, since I (likely) won't publish these data
anyway.

As in the previous sections, the plot is initially created without lines and I
use 'lapply' over the different levels to actually fill in the plot.  The legend
links each replicate to a unique color, making it easy to identify outliers.

As in most of these analyses, I'm finding 'gsub', which replaces strings in
text, a very valuable function for creating file names.

* [[2D_Scatter_Plots]]
These are traditional 2D scatter plots of fluorescence channels.  They don't
convey the density of cells in a cloud in the way that the 'xyplot' function
does.  Thus, I set the 'cex' value for the points to a low value (0.1).  I use
the 'all.groups.e' object for this function, so I only need to loop over 2
levels (gate - curv, initial, ungated; and strain background).  The new code
colors the plots according to genetic background. 

* [[Between_Groups_Boxplots]]
For this analysis, I merge each strain's dataframe into a single dataframe and
separate the strain backgrounds using a factor, 'strain.factor'.  There is a lot
of pre-processing and object creation that precedes the boxplots.  

The first step is to create a factor that will distinguish between the various
strain backgrounds and can be applied over the three gating levels.  Because the
length of the dataframes at each gating level is different, this requires making
a list of length 3 with a separate factor in each list element.  I make the
factor by counting the number of rows in each dataframe and repeating a unique
integer this many times at each level of 'all.groups.e'.  I then convert each
level of this list to a factor using 'unique' to set the factor levels and
'strain.names' to set the factor labels.  

Then each level of 'all.groups.e' is merged into a single dataframe.  I add each
corresponding level of 'strain.factor' to the resultant dataframes to create a
list of 3 dataframes that can be analyzed using strain background as a factor.  

My general approach to these large dataframes is to loop over them to create,
e.g., box or density plots.  This is not possible w/ a factor, so I create a
logical vector to subset the dataframes to loop over everything EXCEPT the
factor.  The resultant object 'fac.test', is used for subsetting in creating the
boxplots in the next step.  

* [[Replicate_Mean_Stripcharts]]
This analysis starts by computing the mean/median for each of the samples.  So,
it will return one value from, e.g., 10,000 cells.  I typically run 8 biological
replicates for each reporter, and the resultant stripcharts will have 8 dots for
each of 8 replicates.  To compute the mean for each replicate, I create an
object, 'all.data.means'.  I then loop over each level of all.data.e and compute
the mean for each parameter.  I make sure that each gate level, strain,
replicate, and parameter are named using a complicated 'for' loop (can't assign
names via 'lapply').  The 'rdired' view of 'all.data.means' nicely shows the
results of the naming operation.  

After creating 'all.data.means', I then create a related object,
'all.data.mean.lines'.  This object is created by taking the mean of each
strain's replicate mean.  For example, if I have two samples of 10,000 cells of
the BY background, 'all.data.means' will include the mean of the 10,000 cells
for the first BY replicate and the mean of the 10,000 cells for the second BY
replicate.  The mean of these 2 means will then be calculated as part of
'all.data.mean.lines'.  I'll use 'all.data.mean.lines' to create the lines on
the stripchart that indicate the mean or median.  

To merge all of these lists and values into a single dataframe, I perform
several 'lapply' loops that call 'rbind'.  

Finally, I create an object 'strain.rep.factor', that I use to separate the
values into their respective strain backgrounds.  This is similar to what I
do above for the boxplots.  I add this factor to 'all.data.means' to create the
final dataframe for making stripcharts.  

I then create the stripcharts via a three-step process:

    - [1] Create the plots by 'lapply' looping over gates and parameters.  At
      this step, no data is actually shown.  The call to 'stripchart' here is
      merely used to set up the plot

    - [2] Create the lines that show the mean of each strain for each parameter

    - [3] Overplot the individual replicates on top of the mean lines.  If the
      points were plotted in [1], the mean lines would appear over the top of
      the individual points instead, which doesn't look as good.  The 'add = T'
      option of 'stripchart' makes overplotting the points on top of the mean
      lines possible.

A peculiarity of 'stripchart' is the way different pch symbols handle color in a
stripchart.  It would be nice to be able to plot by strain colors, but I don't
think it's possible.  The plots I make need to have a pch that accepts 'col'
*AND* 'bg' arguments.  Without the border color on the points, they tend to
blend together.  However, stripchart handles the application of color by factor
different for 'col' vs. 'bg' arguments.  Specifically, there is no
straightforward way to apply a color factor to a 'bg' argument.  The alternative
is to supply a color factor to 'col', but the results don't look especially
nice.  

* [[Replicate_Median_Stripcharts]]
See: [[Replicate_Mean_Stripcharts]]

The code is identical, except that I take the median of each parameter, rather
than the mean.  The output is stripcharts that use strain background as a factor
to compare the values of all parameters collected during the flow cytometry
run. 

* [[Summary_Tables]]
This code writes the data from 'all.data.means' and 'all.data.medians' to csv
files.  These objects are what my statistical analyses are based on, so it might
be valuable to have them later if I decide to alter my analysis method.  

There are a lot formatting specifications I had to work into this analysis: 

    - [1] needed to use 'format' function w/ 'nsmall' arg to get the correct
          number of decimal places in the table
    - [2] had to use 'col.names = NA' to prevent empty column above rownames in
          the table 
    - [3] had to use 'quote = F' to get proper output from other applications,
          e.g., 'column -t -s ","' 

In addition, setting the decimal precision of 'write.table' was a major
headache.  I ultimately settled on formatting the table via a separate call to
'sprintf' as neither 'write.table' nor 'format' produced satisfactory output.
Note that the formatting needs to be done over a 'for' loop rather than an
'lapply' call or the assignment operation doesn't work.  

* [[Flow_Cytometry_Statistics]]
My statistical analysis is relatively basic.  I apply a simple analysis of
variance using each flow cytometry parameter as a dependent measure and strain
as a main factor.  I then use the liberal LSD postdoc test to test for
significance between individual strains.  

I perform these analyses on both the mean and median estimates of each
replicate.  The results of both the main effects analysis and post-hoc tests are
grabbed via 'capture.output' and written out to separate files, one for the
mean results and one for the median results.  I write the names of each
parameter in a header structure to demarcate the various parameters.  

* [[Cell_Count_Stripcharts]]
The final piece of analysis is to create stripcharts of the cell counts of the
individual replicates at each gating level.  In principle, this should come
earlier in the analysis, but I use the 'strain.rep.factor' object here, so for
now, this will stay late in the analysis.  

The analysis is similar to that used to generate the boxplots for these data.
The basic approach is to use 'nrow' for each replicate and bind these to an
individual dataframe.  I use a factor to distinguish the different strain
backgrounds and perform three plotting operations to generate the stripchart

    - [1] the 'dummy' plot to set up the plot area, axes, titles, etc...
    - [2] the overplot of the mean line for each strain's cell count
    - [3] the overplot of the individual replicate data points so that these
          cover the mean lines. 

* Flow Analysis Source Code
#+NAME: flow_analysis_master
#+BEGIN_SRC R :tangle ~/data/flow/flow_scripts/flow_analysis_master.R
## -----
## <<Required_Packages>>
## check for Bioconductor and install if not available
ifelse(!requireNamespace("BiocManager", quietly = TRUE),
       install.packages("BiocManager",
                        dependencies = TRUE,
                        repos = "http://cran.wustl.edu/",
                        quiet = TRUE),
       paste0("Bioconductor available"))
require("BiocManager")

## requireNamespace checks whether a package is available and loads if it is
## the return value is logical and the function throws an error if not available
## if(!requireNamespace("DNAcopy")) paste0("package not available")
## check that the output of requireNamespace is truly logical:
## requireNamespace("dygraphs") == requireNamespace("lattice")     ## TRUE
## requireNamespace("dygraphs") == requireNamespace("fakepackage") ## FALSE
## ifelse(!requireNamespace("fakepackage"),
##        paste0("no such package"),
##        paste0("there is a package"))


## -----
## load packages or install if not available
## have to split these out by bioconductor vs. non-bioconductor
## non-bioconductor
package_installer <- function(x){
    if(!requireNamespace(x, quietly = TRUE))
        install.packages(x, dependencies = TRUE,
                         repos = "http://cran.wustl.edu/",
                         quiet = TRUE, INSTALL_opts = '--no-lock')}
packages <- c("colorspace", "lattice", "ggvis", "dygraphs", "DescTools")
sapply(X = packages, FUN = package_installer)
sapply(X = packages, FUN = require, character.only = TRUE)


## -----
## bioconductor
bioc_package_installer <- function(x){if(!requireNamespace(x))
                                          BiocManager::install(x, INSTALL_opts = '--no-lock')}
bioc_packages <-  c("flowCore", "flowViz", "flowUtils", "flowStats", "flowFP", "geneplotter", "ggcyto")
sapply(X = bioc_packages, FUN = bioc_package_installer)
sapply(X = bioc_packages, FUN = require, character.only = TRUE)


## -----
## required for merging flowsets into a single flowframe
source(file = "https://raw.githubusercontent.com/mac230/flow_scripts/master/set2frame.R")


##-----
## <<Reading_FCS_Files>>
## user-specified options - these will change for each analysis depending on strains/reporters
##############
## USER INPUT:
##############
## no trailing '/' at the end!
base.dir       <- "~/data/flow/2020.03.14_new_gate_testing"
setwd(base.dir)
needed.dirs <- c("/fcs", "/results", "/tables")
dir.maker <- function(x){if(!dir.exists(paths = paste0(base.dir, x)))
                             dir.create(path = paste0(base.dir, x))}
sapply(X = needed.dirs, FUN = dir.maker)
work.dir       <- paste0(base.dir, "/fcs")
results.dir    <- paste0(base.dir, "/results")
tables.dir     <- paste0(base.dir, "/tables")


##-----
## [x]
## now set regex for getting flowsets of the different strains
## generally, should name fcs files as follows:
## strain    - by, rm, rpn4, rpn10
## reporter  - PSV, TFT, untagged
## replicate - 001, 002, etc... per strain
##############
## USER INPUT:
##############
no.reporter   <- ".*untagged.*fcs"
by.thr.tft    <- "BY.*Thr.*.fcs"
rm.thr.tft    <- "RM.*Thr.*.fcs"
doa10.thr.tft <- "doa10.*Thr.*.fcs"


##############
## USER INPUT:
##############
## for later use in plots
strain.names <- c("no reporter", "BY Thr TFT", "RM Thr TFT", "doa10 Thr TFT")



##-----
## [x]
## bind all regex to a list and use the list to read files
## the result here is a list of ungated flowSets
## each flowset has 'n' tubes (flowframes), where n is the number of replicates
## access a single flowFrame/tube w/ .e.g. "all.set[[1]][[1]]", which would be strain 1, tube 1
##############
## USER INPUT:
##############
setwd(work.dir)
all.strains <- list(no.reporter,
                    by.thr.tft,
                    rm.thr.tft,
                    doa10.thr.tft)

all.set     <- lapply(all.strains, function(x){read.flowSet(files = NULL, path = ".", pattern = x, alter.names = T, min.limit = 1)})
## str(all.set[[1]]@phenoData@data$name)

##################
## END USER INPUT:
##################


## -----
## <<Color_Setup>>
## linking colors to strain names in R
## I think I should be able to make something
## akin to an lisp association list where
## there is a strain name and associated color
col.untagged <- c(color = gray(0.7),   name = "no reporter")
col.by       <- c(color = "#7A9BCCFF", name = ".*BY.*")
col.rm       <- c(color = "#CC7AAAFF", name = ".*RM.*")
col.rpn4     <- c(color = "#CCAB7AFF", name = ".*rpn4.*")
col.ubr1     <- c(color = "#88CCBBFF", name = ".*ubr1.*")
col.doa10    <- c(color = "#A3CC7AFF", name = ".*doa10.*")
cols.list    <- list(col.untagged, col.by, col.rm, col.rpn4, col.ubr1, col.doa10)

col.out <- sapply(X = cols.list, FUN = function(x){
                      grepl(pattern = x["name"], x = strain.names )
                  })
col.out <- as.logical(unlist(sapply(1:ncol(col.out), FUN = function(x){
                      max(col.out[, x])
                      })))
all.cols <- unlist(sapply(X = cols.list[col.out], FUN = function(x){identity(x["color"])}))


## output a dummmy plot to assess strain/color mapping
setwd(results.dir)
pdf(file = "color_mapping.pdf", height = 7, width = 7, bg = "transparent")
barplot(rep(4, length(strain.names)), col = all.cols, ylim = c(0, 5.5))
box()
legend(x = "topleft", legend = strain.names, lty = 1, lwd = 7.5, col = all.cols, bg = "white")
legend(x = "topright", y = NA,
       legend = unlist(lapply(X = cols.list, FUN = function(x){identity(x)["name"]})),
       col = unlist(lapply(X = cols.list, FUN = function(x){identity(x)["color"]})),
       lty = 1, lwd = 7.5,  bg = "white")
dev.off()


##-----
## [x]
## write strain/replicate groupings to a table for inspection
## view w/ 'column -t -s "," ./tables/strain_replicate_groupings.txt'
setwd(tables.dir)
cat("File, Group, Strain", "\n", file = "strain_replicate_groupings.txt", append = F)
strain.group    <- as.list(seq(from = 1, to = length(all.set), by = 1))
replicates.out  <- unlist(lapply(1:length(all.set),
                                 function(x)
                                 {paste0(all.set[[x]]@phenoData@data$name, ", ",
                                         strain.group[[x]], ", ", strain.names[[x]])}))
replicate.table <- function(x){cat(c(x, "\n"), file = "strain_replicate_groupings.txt", append = T, sep = ", ")}
sapply(X = replicates.out, FUN = replicate.table)


##-----
## <<TFT_Transformation>>
## use the transform function to get the TFT/PSV parameters we want
## start by converting 0's in fluors to 1's via truncate transform
trunc.trans   <- truncateTransform("Convert 0's to 1's.", a = 1)
trunc.fluors  <- function(x){
    transform(x,
              `eGFP.A` = trunc.trans(`eGFP.A`),
              `mCherry.A` = trunc.trans(`mCherry.A`))}
all.set <- lapply(all.set, fsApply, trunc.fluors)

PSV.TFT.transform <- function(x){
    transform(x,
              `log_GFP` = log10(`eGFP.A`),
              `log_RFP` = log10(`mCherry.A`),
              `TFT_ratio` = log(`mCherry.A`/`eGFP.A`, base = 2),
              `PSV_ratio` = log(`eGFP.A`/`mCherry.A`, base = 2),
              ## 'no log' TFT ratio
              `nl_TFT_ratio` = (`mCherry.A`/`eGFP.A`)
              )}
all.set <- lapply(all.set, fsApply, PSV.TFT.transform)


##-----
## [x]
## get the total number of cells for each flowFrame
## nrow is passed as an optional arg to fsApply here
total.cells <- lapply(all.set, fsApply, nrow)


##-----
## <<Cell_Gating>>
## [x]
## 02.27.2019 try this w/ curv2Filter w/ a big bandwidth setting to grab the
## main cloud of cells we take only cells in 'area 1' (the gate), not 'rest'
## (the cells outside the gate)
## <<FSC_SSC_Gate>>
initial.split <- function(x) {
    split(x, f = curv2Filter(x = "FSC.A", y = "SSC.A", bwFac = 7, gridsize = c(250,250)),
          population = "area 1", flowSet = TRUE, codeflowSet = TRUE)
}
## this object is a list of flowsets of the cells in the initial gate (area 1)
## each flowset in this list contains only 1 flowFrame
initial.split.all <- lapply(all.set, fsApply, initial.split)


##-----
## [x]
## plot the cells w/ their associated filter gate
setwd(results.dir)
dir.create(path = paste0(results.dir, "/cell_gate_plots"))
cell.gate.dir <- paste0(results.dir, "/cell_gate_plots")
setwd(cell.gate.dir)

xy.initial.pdf <- function(x){
    pdf(file = paste0("initial_", x@description$"TUBE NAME", ".pdf"), height = 7, width = 7)
    print(xyplot(`SSC.A` ~ `FSC.A`, data = x,
                 filter = curv2Filter(x = "FSC.A", y = "SSC.A", bwFac = 10, gridsize = c(250,250)),
                 smooth = F))
    dev.off()
}
lapply(all.set, fsApply, xy.initial.pdf)


##-----
## [x] - 2020.04.19 - no longer using due to fsc gating approach below
## plot the results of the pre-filter plus curv2Filter gating
## start by undoing the complicated list structure the filter operation creates
## this yields a list of flowSets
## initial.curv.split <- unlist(initial.split.all)
##setwd(cell.gate.dir)
##xy.initial.curv.pdf <- function(x) {
##    pdf(file = paste0("curv_", x@description$"TUBE NAME", "_.pdf"), height = 7, width = 7)
##    print(xyplot(`SSC.A` ~ `FSC.A`, data = x,
##                 filter = curv2Filter(x = "FSC.A", y = "SSC.A", bwFac = 2, gridsize = c(250,250)),
##                 smooth = F))
##    dev.off()
##}
##lapply(initial.curv.split, fsApply, xy.initial.curv.pdf)


## -----
## <<FSC_Gate>>
## a function to gate the cells to include only haploids.
## we identify these as a sharp peak in the lower end of
## the fsc density plot.  I take 10% above and below the
## max density value
fsc.gate.generator <- function(x){
    fsc.dens  <- density(exprs(x[, 1]))
    ## return the index of the maximum y value of the density estimate
    fsc.max   <- fsc.dens[[1]][which.max(fsc.dens[[2]])]
    fsc.upper <- (fsc.max * 0.10) + fsc.max
    fsc.lower <- fsc.max - (fsc.max * 0.10)
    fsc.gate  <- c(fsc.lower, fsc.upper)
}

curv.split <- function(x){
    split(x, f = rectangleGate("FSC.A" = fsc.gate.generator(x)),
          population = "defaultRectangleGate+",
          flowSet = T, codeflowSet = T)}
curv.set <- lapply(all.set, fsApply, curv.split)


##-----
## [x]
## plot the results of the pre-filter plus curv2Filter gating
## start by undoing the complicated list structure the filter operation creates
## this yields a list of flowSets
setwd(cell.gate.dir)
xy.fsc.curv.pdf <- function(x){
    pdf(file = paste0("curv_", x@description$"TUBE NAME", "_.pdf"), height = 7, width = 7)
    print(xyplot(`SSC.A` ~ `FSC.A`, data = x, main = x@description$"TUBE NAME",
                 filter = rectangleGate("FSC.A" = fsc.gate.generator(x)),
                 smooth = F))
    dev.off()
    }
lapply(all.set, fsApply, xy.fsc.curv.pdf)

## plot the fsc density and associated gate
## I use 'Map' here to color the plots by strain 
fsc.density.curv.pdf <- function(data, color){
    fsApply(data, function(x){
                pdf(file = paste0("fsc_density_", x@description$"TUBE NAME", "_.pdf"),
                    height = 7, width = 7)
                plot(density(exprs(x[, 1])),
                     xlab = colnames(exprs(x))[1],
                     main = x@description$"TUBE NAME",
                     col = color, lwd = 2.5)
                abline(v = fsc.gate.generator(x),
                       col = gray(0.4),
                       lty = 3, lwd = 2.5)
                dev.off()
            }
            )}

Map(f = fsc.density.curv.pdf, all.set, all.cols)


gated.xy.fsc.curv.pdf <- function(x){
    pdf(file = paste0("xy_sub_population_curv_", x@description$"TUBE NAME", "_.pdf"), height = 7, width = 7)
    print(xyplot(`SSC.A` ~ `FSC.A`, data = x, main = x@description$"TUBE NAME",
                 filter = rectangleGate("FSC.A" = fsc.gate.generator(x)),
                 smooth = F))
    dev.off()
}
lapply(curv.set, function(x){lapply(x, fsApply, gated.xy.fsc.curv.pdf)})


## -----
## <<Gate-Based_Subsetting>>
## [x]
## the output of the filtering operation is a list
## curv.set:
## 1. curv.set -> list of flowsets
##    curv.set[[1]] -> flowSet w/ 4 experiments

##    2. curv.set[[1]][[1]] -> flowSet
##       flowSet of the different curv gates

##       3. curv.set[[1]][[1]][[1]] -> the actual flowframe of each gate
##                                     ("defaultRectangleGate+")

## use unlist to get a simpler list structure
## the result is a list of flowsets


## now convert the list of fsc-gated flowsets into a list of list of
## Start by unlisting the original dataset.
## Then loop over the unlisted data and grab the flowframe of interest.
curv.set <- unlist(curv.set)
c.final.frame  <- list()

for(i in 1:length(curv.set)){
    c.final.frame[[i]] <- curv.set[[i]][[1]]
}


##-----
## [x]
## list of flowsets that result from the first filter
## i.final.frame is a list of flowFrames
i.set <- unlist(initial.split.all)
i.final.frame <- list()
for(i in 1:length(i.set)){
i.final.frame[[i]] <- i.set[[i]][[1]]
}


##-----
## [x]
## list of flowsets of the ungated cells
## u.final.frame is a list of flowFrames
u.set <- unlist(lapply(all.set, fsApply, list))
u.final.frame <- list()
for(i in 1:length(u.set)){
u.final.frame[[i]] <- u.set[[i]]
}


##-----
## [x]
## get the names of the original samples and use them as regex
## 'grepl' returns logical output; w/ 'lapply', test each regex on the list of file/tube names
tube.names <- unlist(lapply(c.final.frame, function(x) {print(x@description$GUID.original)}))
strain.regex.logical <- lapply(all.strains, function(x){grepl(x = tube.names, pattern = x)})


##-----
## [x]
## now use the logical vectors for grouping
all.data <- list(curv = c.final.frame, initial = i.final.frame, ungated = u.final.frame)
names(all.data)


## 1. all.data is a list of 3 lists, each of these 3 lists is a list of 24 ungrouped flowframes
## 2. lapply all.data to pass a list of 24 flowframes to a function
## 3. make that function an lapply to pass each of 24 flowframes to some test
## 4. end result should be a list of 3, with each of these 3 lists having 5 lists (strains)
## 3 levels to all.data -> all.data[[I-gated_set]][[II-strain_replicates]][[III-individual flowframe]]
all.data <- lapply(all.data,
                   function(x){
                       lapply(seq_along(strain.regex.logical),
                              function(y){
                                  x[strain.regex.logical[[y]]]
                              })
                   })


##-----
## [x]
## now we do logicle transform for plotting 
logicle.trans <- logicleTransform(transformationId = "logicle fluor transform")
logicle.func <- function(x){
    transform(x,
              `log_GFP` = logicle.trans(`eGFP.A`),
              `log_RFP` = logicle.trans(`mCherry.A`))}

all.data.l <- lapply(1:length(all.data), function(x){
                         lapply(all.data[[x]], function(y){
                                    lapply(y, function(q){
                                               logicle.func(q)}
                                           )}
                                )})


##-----
## [x]
## logicle plots of individual samples
setwd(results.dir)
dir.create(path = paste0(results.dir, "/logicle_2D_plots_individual"))
logicle.dir <- paste0(results.dir, "/logicle_2D_plots_individual")
setwd(logicle.dir)

lapply(1:length(all.data.l), function(x){
           lapply(all.data.l[[x]], function(y){
                      lapply(y, function(q){
                                 pdf(file = paste0(names(all.data[x]),
                                                   "_",
                                                   q@description$'TUBE NAME',
                                                   ".pdf"),
                                     height = 7,
                                     width = 7)
                                 print(xyplot(`log_RFP` ~ `log_GFP`,
                                              data = q,
                                              smooth = F,
                                              strip = paste0(names(all.data[x]),
                                                             " ",
                                                             gsub("_",
                                                                  " ",
                                                                  q@description$'TUBE NAME')),
                                              prepanel=function(){return(list(xlim = c(0, 4), ylim = c(0, 4)))}))
                      dev.off()
                      })
                  })
           })


##-----
## [x]
## per gate per group logicle plots
## set up lists for each gate
setwd(results.dir)
dir.create(path = paste0(results.dir, "/logicle_2D_plots_groups"))
logicle.groups.dir <- paste0(results.dir, "/logicle_2D_plots_groups")
setwd(logicle.groups.dir)


## set up lists for each gate
c.frame.l   <- vector(mode = "list", length = length(strain.names))
i.frame.l   <- vector(mode = "list", length = length(strain.names))
u.frame.l   <- vector(mode = "list", length = length(strain.names))
all.frame.l <- list(curv = c.frame.l, initial = i.frame.l, ungated = u.frame.l)


## convert individual flowsets to single flowframes
all.frame.l <- lapply(1:length(all.frame.l), function(x){
                          lapply(1:length(all.frame.l[[x]]), function(y){
                                     all.frame.l[[x]][[y]] <- set2Frame(as(unlist(all.data.l[[x]][[y]]), "flowSet"))
                                 })
                      })


## name the frames that will comprise each gate
## 'gsub' removes spaces 
names(all.frame.l) <- names(all.data)
for(i in 1:length(all.frame.l)){
    names(all.frame.l[[i]]) <- gsub(pattern = " ", replacement = "_", x = strain.names)
}


## plot
## 'gsub' here ensures no spaces in file names
lapply(1:length(all.frame.l), function(x){
           lapply(1:length(all.frame.l[[x]]), function(y){
                      pdf(file = paste0(names(all.frame.l[x]),
                                        "_",
                                        gsub(" ", "_",
                                             names(all.frame.l[[x]][y])), ".pdf"),
                          height = 7,
                          width = 7)
                      print(xyplot(`log_RFP` ~ `log_GFP`,
                                   data = all.frame.l[[x]][[y]],
                                   smooth = F,
                                   strip = paste0(names(all.data[x]),
                                                  " ",
                                                  gsub("_", " ", names(all.frame.l[[x]][y]))),
                                   prepanel=function(){
                                       return(list(xlim = c(0, 4),
                                                   ylim = c(0, 4)))
                                   }))
                      dev.off()
                  })
       })


##-----
## <<Cell_Count_Table_and_Plots>>
## [x]
## check that final data result has expected number of cells
## write the number of cells from each gating step to a table
setwd(tables.dir)

c.counts <- unlist(lapply(all.data[[1]], function(x){
                              lapply(x, function(y){
                                         nrow(y)
                                     })
                          }))

i.counts <- unlist(lapply(all.data[[2]], function(x){
                              lapply(x, function(y){
                                         nrow(y)
                                     })
                          }))

u.counts <- unlist(lapply(all.data[[3]], function(x){
                              lapply(x, function(y){
                                         nrow(y)
                                     })
                          }))

table.names <- unlist(lapply(all.data[[1]], function(x){
                                 lapply(x, function(y){
                                            print(y@description$GUID.original)
                                        })
                             }))

table_factor <- vector(mode = "list", length = length(all.set))
for(i in 1:length(all.set)){
    table_factor[[i]] <- rep(i, times = length(all.set[[i]]))
    }
table_factor <- unlist(table_factor)

all.cell.counts <- list(curv_gate = c.counts, initial_gate = i.counts, ungated = u.counts, table.factor = table_factor, names = table.names)
write.table(x = all.cell.counts, file = "cell_counts_by_gate.txt", append = F, sep = ",", quote = F, row.names = F)

cell.data <- read.csv(file = "cell_counts_by_gate.txt", header = T)
cell.data$table.factor <- factor(x = cell.data$table.factor, levels = unique(cell.data$table.factor), labels = strain.names)


##-----
## [x]
## box plots of cell counts x group
setwd(results.dir)
dir.create(path = paste0(results.dir, "/cell_count_plots"))
cell.count.dir <- paste0(results.dir, "/cell_count_plots")
setwd(cell.count.dir)
lapply(1:length(all.data), function(x){
           pdf(file = paste0("cell_count_boxplot_", names(all.data[x]), ".pdf"), height = 7, width = 7, bg = "transparent")
           par(cex.axis = 0.8)
           boxplot(cell.data[, x] ~ cell.data$table.factor, ylab = "Cell Count", col = gray(0.9))
           dev.off()})


## single pdf of all cell counts
par(mfrow = c(3,1))
pdf(file = "all_cell_counts_boxplot_.pdf", height = 7, width = 7, bg = "transparent")
lapply(1:length(all.data), function(x){
           par(cex.axis = 0.8)
           boxplot(cell.data[, x] ~ cell.data$table.factor, ylab = "Cell Count", col = gray(0.9))
       })
dev.off()
par(mfrow = c(1,1))


##-----
## <<Check_Gate_Groupings>>
## [x]
## get tube names for each set of samples
## unlist step results in a list of lists -> out[[I - gate]][[II - strain]]
out <- lapply(all.data, function(x){
                  lapply(x, function(y){
                             unlist(lapply(y, function(q){
                                        print(strsplit(x = q@description$GUID.original, split = "_[0-9]{3}.fcs"))
                                    }))
                         })
              })


##-----
## [x]
## write output to a file that gives replicate grouping across frames of 'out'
setwd(tables.dir)
for(i in 1:length(out)){
    for(j in 1:length(i)){
        for(k in 1:length(j)){
            cat(paste0(out[[i]], "_", names(out[i])), file = "gates_by_groups_list.txt", append = T, sep = "\n")
        }
    }
}


##-----
## <<Data_Frame_Conversion>>
## [x]
## convert to data frames
all.data.e <- lapply(all.data, function(x){
                         lapply(x, function(y){
                                    lapply(y, function(q){
                                               q <- as.data.frame(exprs(q))
                                           })
                                })
                     })


##-----
## [x]
## save the data as an R object for later loading if needed
setwd(base.dir)
dir.create(path = paste0(base.dir, "/R_objects"))
objs.dir <- paste0(base.dir, "/R_objects")
setwd(objs.dir)
## flowsets
saveRDS(all.data, file = "curv_initial_ungated_flowsets")
## exprs matrix
saveRDS(all.data.e, file = "curv_initial_ungated_flowsets_exprs")
## test <- readRDS(file = "curv_initial_ungated_sets")


##-----
## <<Between_Groups_Processing>>
## [x]
## between groups stuff
## start by grouping replicates in a list of lists
all.groups.e <- lapply(all.data.e, function(x){
                           lapply(x, function(y){
                                      x <- do.call("rbind", y)
                                  })
                       })

## name the backgrounds in each dataset
## remember, have to 'for' loop this; can't use 'lapply'
for(i in seq_along(all.groups.e)){
           names(all.groups.e[[i]]) <- strain.names
       }

## write out the total number of cells for each background
setwd(tables.dir)
cell.counts <- vector(mode = "list", length = length(all.groups.e))
names(cell.counts) <- names(all.groups.e)

cell.counts <- lapply(all.groups.e, function(x){
                          unlist(lapply(1:length(x), function(y){
                                            nrow(x[[y]])
                                        }))
                      })

## assign names
for(i in 1:length(cell.counts)){
    names(cell.counts[[i]]) <- strain.names
}

## create a new table to dump output into 
cat(paste0("Cell_Count, Strain, Gate,", "\n"), file = "total_cells_per_group_gate.txt")

## loop over the data to write the table 
for(i in seq_along(cell.counts)){
    for(h in seq_along(cell.counts[[i]])){
        cat(paste0(cell.counts[[i]][[h]], ", ", 
                   gsub(" ", "_", names(cell.counts[[i]][h])), ", ",
                   names(cell.counts[i])),
                   file = "total_cells_per_group_gate.txt",
                   append = T,
                   sep = "\n")
        }
    }


##-----
## <<Between_Groups_Plots>>
## [x]
## need to add names to individual elements
setwd(results.dir)
dir.create(path = paste0(results.dir, "/between_groups_plots"))
between.groups.dir <- paste0(results.dir, "/between_groups_plots")
setwd(between.groups.dir)

## set up names and limits for parameters - these may have to change
## these are for density plots, so x axis is what's below
## "FSC.A" "SSC.A" "eGFP.A" "mCherry.A" "Time"
## "log_GFP" "log_RFP" "TFT_ratio" "PSV_ratio" "nl_TFT_ratio"
x.lab   <- gsub(pattern = "_", replacement = " ", names(all.groups.e[[1]][[1]]))
x.min   <- c(0, 0, 0, 0, 0, 2, 2, -6, -2, 0)
x.max   <- c(2.5e5, 2e5, 2e4, 2e4, 2.5e3, 5, 5, 2, 6, 1)
leg.pos <- c(rep("topright", 5), "topleft", rep("topright", 3))

## ylim takes the min and max of the density each parameter
## i.e., the values will always be low
y.lim <- vector(mode = "list", length = 3)
for(h in 1:length(y.lim)){
    for(i in 1:length(x.lab)){
        y.lim[[h]][i] <- max(
            unlist(lapply(all.groups.e[[h]],
                          function(x){1.1 * max(density(x[, i])$y)
                                           })
                   ))}}


Map(f = function(gate, name){
        for(i in 1:length(x.lab)){
            ## get y limit for density plot
            lapply(1:length(all.groups.e[[1]]),
                   function(x){
                       ## plot
                       pdf(file = paste0(name, "_",
                                         gsub(" ", "_", x.lab[i]),
                                         "_between_groups", ".pdf"),
                           height = 7, width = 7, bg = "transparent")
                       plot(density(all.groups.e[[gate]][[x]][, i], adjust = 0.75),
                            col = "white",
                            ylim = c(0, y.lim[[gate]][i]),
                            xlim = c(x.min[i], x.max[i]),
                            xlab = x.lab[i], main = name)

                       ## map across gates and do so on a per-strain basis
                       Map(f = function(x, y){
                               lines(density(all.groups.e[[gate]][[x]][, i],
                                             adjust = 0.75),
                                     col = y, lwd = 2)},
                           x = 1:length(all.groups.e[[gate]]), y = all.cols)

                       ## legend
                       legend(x = "topleft", legend = strain.names,
                              lty = 1, lwd = 5,
                              col = all.cols, bg = "white")
                       dev.off()

                   })
        }}, gate = seq_along(all.groups.e), name = names(all.groups.e))


##-----
## <<Between_Groups_Replicates>>
## [x]
## between groups w/ replicates
setwd(results.dir)
dir.create(path = paste0(results.dir, "/between_groups_w_replicates_plots"))
between.groups.replicates.dir <- paste0(results.dir, "/between_groups_w_replicates_plots")
setwd(between.groups.replicates.dir)

Map(f = function(gate, name){
        for(i in 1:length(x.lab)){

            ## get y limit for density plot
            lapply(1:length(all.groups.e[[1]]),
                   function(x){
                       ## plot
                       pdf(file = paste0(name, "_",
                                         gsub(" ", "_", x.lab[i]),
                                         "_between_groups_w_replicates.pdf"),
                           height = 7,
                           width = 7,
                           bg = "transparent")
                       
                       plot(density(all.groups.e[[gate]][[x]][, i], adjust = 0.75),
                            col = "white",
                            ylim = c(0, y.lim[[gate]][i]),
                            xlim = c(x.min[i], x.max[i]),
                            xlab = x.lab[i],
                            main = name)

                       ## map across gates and do so on a per-strain basis
                       Map(f = function(x, y){
                        lines(density(all.groups.e[[gate]][[x]][, i],
                                      adjust = 0.75), col = y, lwd = 3)
                            lapply(1:length(all.data.e[[gate]][[x]]),
                                   function(n){
                                       lines(density(all.data.e[[gate]][[x]][[n]][, i],
                                                     adjust = 0.75),
                                             col = y,
                                             lwd = 0.8)})},
                            x = seq_along(all.groups.e[[gate]]), y = all.cols)

                       ## legend
                       legend(x = "topleft",
                              legend = strain.names,
                              lty = 1, lwd = 5,
                              col = all.cols, bg = "transparent")
                       dev.off()
                   }
        )}}, gate = 1:length(all.groups.e), name = names(all.groups.e))


## -----
## <<Between_Gates_Plots>>
## [x]
## between gates plots
setwd(results.dir)
dir.create(path = paste0(results.dir, "/between_gates_plots"))
between.gates.dir <- paste0(results.dir, "/between_gates_plots")
setwd(between.gates.dir)

Map(f = function(strain, name){
        for(i in 1:length(x.lab)){

            ## get y limit for density plot
            y.lim <- c(0, max(unlist(lapply(1:3,function(x)
                                            {max(density(all.groups.e[[x]][[strain]][, i])$y)
                                            }))))

            ## plot 
            pdf(file = paste0(gsub(" ", "_", x.lab[i]), "_",
                              gsub(" ", "_", name),
                              "_between_gates.pdf"),
                height = 7,
                width = 7,
                bg = "transparent")
            plot(density(all.groups.e[[1]][[strain]][, i],
                         adjust = 0.75),
                 col = gray(0.8),
                 ylim = y.lim,
                 xlim = c(x.min[i], x.max[i]),
                 xlab = x.lab[i],
                 main = name)

            ## map across gates and do so on a per-strain basis
            Map(f = function(x, y){
                    lines(density(all.groups.e[[x]][[strain]][, i],
                                  adjust = 0.75),
                          col = all.cols[strain],
                          lty = y,
                          lwd = 2)},
                x = 1:3, y = 1:3)

            ## legend
            legend(x = "topleft",
                   legend = c("curv", "initial", "ungated"),
                   lty = 1:3,
                   lwd = 5,
                   col = all.cols[strain],
                   bg = "white",
                   seg.len = 3)
            dev.off()

        }
    }, strain = seq_along(strain.names), name = strain.names)


## <<Replicate_Plots>>
##-----
## [x]
## replicate plots
## this gives a nice layout w/ replicates separately and grouped 
setwd(results.dir)
dir.create(path = paste0(results.dir, "/replicate_plots"))
replicates.dir <- paste0(results.dir, "/replicate_plots")
setwd(replicates.dir)

lapply(1:length(all.groups.e), function(x){
           lapply(1:length(all.groups.e[[x]]), function(y){
                      for(i in 1:length(x.lab)){
                          pdf(file = paste0(gsub(" ", "_", names(all.groups.e[x])),
                                            "_",
                                            gsub(" ", "_", x.lab[i]),
                                            "_",
                                            gsub(" ", "_", strain.names[y]),
                                            "_replicate_plot.pdf"),
                              height = 7, width = 7,
                              bg = "transparent")

                          y.i.lim <- c(0, 1.2 * max(density(all.groups.e[[x]][[y]][, i])$y))
                              plot(density(all.groups.e[[x]][[y]][, i], adjust = 0.75),
                                   xlab = x.lab[i],
                                   main = strain.names[y],
                                   xlim = c(x.min[i], x.max[i]),
                                   ylim = y.i.lim,
                                   col = "white")

                              cols <- rainbow(n = length(all.data.e[[x]][[y]]),
                                              s = 0.7,
                                              v = 0.7,
                                              alpha = 1,
                                              end = 0.8)

                              ## the individual replicates line
                          lapply(seq_along(all.data.e[[x]][[y]]),
                                 function(r){lines(density(all.data.e[[x]][[y]][[r]][, i],
                                                           adjust = 0.75),
                                                   col = cols[r])})
                              
                              names <- fsApply(all.set[[y]], function(x){
                                                   paste0(x@description$"TUBE NAME")})

                              ## the overall group line
                              lines(density(all.groups.e[[x]][[y]][, i], adjust = 0.75),
                                    col = gray(0.7), lwd = 2)
                              
                              legend(x = "topleft",
                                     legend = c(names, "all replicates"),
                                     lty = 1,
                                     lwd = 5,
                                     col = c(cols, gray(0.7)),
                                     bty = "",
                                     bg = "transparent")

                          dev.off()
                      }
                  })
                  }
           )


##-----
## <<2D_Scatter_Plots>>
## [x]
setwd(results.dir)
dir.create(path = paste0(results.dir, "/2D_scatter_plots"))
scatterplot.dir <- paste0(results.dir, "/2D_scatter_plots")
setwd(scatterplot.dir)

lapply(1:length(all.groups.e), function(x){
           lapply(1:length(all.groups.e[[x]]), function(y){

                      pdf(file = paste0(names(all.groups.e[x]),
                                        "_",
                                        strain.names[y],
                                        "_GFP_mCh_scatter.pdf"),
                          height = 7, width = 7, bg = "transparent")

                      plot(all.groups.e[[x]][[y]]$log_GFP,
                           all.groups.e[[x]][[y]]$log_RFP,
                           xlim = c(1, 5),
                           ylim = c(1, 5),
                           pch = 19,
                           cex = 0.1,
                           col = all.cols[y],
                           xlab = "log10 sfGFP", ylab = "log 10 mCherry",
                           main = strain.names[y])
                      dev.off()
                  })
       })


##-----
## <<Between_Groups_Boxplots>>
## [x]
## between groups boxplots 
## merge exprs datasets into a single dataframe,
## use nrow to create a factor for each strain

## create a factor for each gate corresponding to the individual strains
## e.g. nrow(all.groups.e[[1]][[1]]) = number of cells of one strain type
strain.factor <- vector(mode = "list", length = length(all.groups.e))
strain.factor <- lapply(all.groups.e, function(x){
                            unlist(lapply(1:length(x), function(y){
                                              rep(x = y, times = nrow(x[[y]]))
                                          }))
                                   })

## now use the 'strain.names' object to label the new factor 
strain.factor <- lapply(1:length(strain.factor), function(x){
                            factor(x = strain.factor[[x]],
                                   levels = unique(strain.factor[[x]]),
                                   labels = strain.names)
                            })

## so, here we merge everything into a single dataset
## at this point, 'strain.factor' is still separate from
## our actual data, so merge it in at each gate level
## the new object 'all.groups.df' remains a list w/ 3
## levels, corresponding to our 3 levels of gating 
all.groups.df <- vector(mode = "list", length = length(all.groups.e))
all.groups.df <- lapply(all.groups.e, function(x){
                            do.call("rbind", x)
})

## add the strain factor to the dataframes
for(i in 1:length(all.groups.df)){
    all.groups.df[[i]]$strain <- strain.factor[[i]]
}

## we'll loop over columns for plotting, so make a list to exclude the 'strain' factor column
fac.test <- lapply(all.groups.df, function(x){
                       unlist(lapply(1:ncol(all.groups.df[[1]]), function(y){
                              !is.factor(x[, y])
                              }))
                       })

fac.test <- lapply(fac.test, function(x){
                       x <- x[x > 0]
                   })

## create pdfs
setwd(results.dir)
dir.create(path = paste0(results.dir, "/between_groups_boxplots"))
boxplots.dir <- paste0(results.dir, "/between_groups_boxplots")
setwd(boxplots.dir)

invisible(lapply(1:length(all.groups.df), function(x){
                     lapply(1:length(fac.test[[x]]), function(y){
                                pdf(file = paste0(names(all.groups.df[x]),
                                                  "_",
                                                  names(all.groups.df[[x]][y]),
                                                  "_strain_boxplot.pdf"),
                                    height = 7,
                                    width = 7,
                                    bg = "transparent")
                                par(cex.axis = 0.8) 
                                boxplot(all.groups.df[[x]][, y] ~ all.groups.df[[x]]$strain,
                                        main = names(all.groups.df[x]),
                                        names = strain.names,
                                        ylab = gsub("_", " ", names(all.groups.df[[x]][y])),
                                        col = gray(0.95),
                                        pars = list(outpch = 19,
                                                    outcol = "#112255AA",
                                                    outcex = 0.4))
                                dev.off()
                            })
                 }))


##-----
## <<Replicate_Mean_Stripcharts>>
## [x]
## start by creating a list of lists identical in size
## to the individual replicates list
all.data.means <- vector(mode = "list", length = length(all.data.e))

## now get the mean of each replicate, typically a sample > 10k cells
## the result of this operation is a list of list that's the same
## structure as 'all.data.e', but instead of, e.g., 10,000 rows, each
## individual sample now has only a single value (the mean) for each
## parameter 
all.data.means <- lapply(1:length(all.data.e), function(x){
                             all.data.means[[x]] <- lapply(1:length(all.data.e[[x]]), function(y){
lapply(1:length(all.data.e[[x]][[y]]), function(i){
           sapply(X = 1:ncol(all.data.e[[x]][[y]][[i]]),
                  FUN = function(m){mean(all.data.e[[x]][[y]][[i]][, m])})
       })
})
})

## name the gates, strains, and replicates
rep.names <- vector()
names(all.data.means) <- names(all.data.e)
## i = 1:3
for(i in seq_along(all.data.means)){
    names(all.data.means[[i]]) <- names(all.groups.e[[i]])
    ## h = 1:4
    for(h in seq_along(all.data.means[[i]])){
        ## g = 1:2        
        for(g in seq_along(all.data.means[[i]][[h]])){
            rep.names[g] <- all.set[[h]][[g]]@description$"TUBE NAME"
            names(all.data.means[[i]][[h]]) <- rep.names
            names(all.data.means[[i]][[h]][[g]]) <- names(all.groups.e[[1]][[1]])
        }}}


## create a similar list that gets the mean of the replicate means
## you'll use this later for plotting and statistics
## in the first step, bind each replicate into a single list that represents
## a strain
all.data.mean.lines <- lapply(all.data.means, function(x){
                                  lapply(1:length(x), function(y){
                                             colMeans(do.call("rbind", x[[y]]))
                                         })
                              })

for(i in seq_along(all.data.mean.lines)){
    names(all.data.mean.lines[[i]]) <- strain.names
}


## now bind the list of strains together via 'rbind'
all.data.mean.lines <- lapply(all.data.mean.lines, function(x){
                                  as.data.frame(do.call("rbind", x))
                              })

all.data.means <- lapply(all.data.means, function(x){
                             lapply(x, function(y){
                                        as.data.frame(do.call("rbind", y))
                                    })
                         })

all.data.means <- lapply(all.data.means, function(x){
                             do.call("rbind", x)
                         })


strain.rep.factor <- vector(mode = "list",
                            length = length(all.data.e))
strain.rep.factor <- lapply(1:length(all.data.e), function(x){
                                strain.rep.factor[[x]] <- factor(x = unlist(lapply(1:length(all.data.e[[x]]), function(y){
rep(y, times = length(all.data.e[[x]][[y]]))
})), labels = strain.names)
})


for(i in 1:length(all.data.means)){
    all.data.means[[i]]$strain <- strain.rep.factor[[i]]
}


## now plot across gates/parameters
## set up some dirs first
setwd(results.dir)
dir.create(path = paste0(results.dir, "/between_groups_mean_stripcharts"))
mean.stripcharts.dir <- paste0(results.dir, "/between_groups_mean_stripcharts")
setwd(mean.stripcharts.dir)

lapply(1:length(all.data.means), function(x){
           lapply(1:(ncol(all.data.means[[x]]) - 1), function(y){
                      pdf(file = paste0(names(all.data.means[x]), "_",
                                        names(all.data.means[[x]][y]),
                                        "_mean_betw_groups_strip.pdf"),
                          height = 7,
                          width = 7,
                          bg = "transparent")
                      ## first plot is 'dummy' plot so I can add lines
                      ## for the means.  After the lines are added,
                      ## overplot the same data again so individual
                      ## points aren't hidden behind the mean lines
                      stripchart(all.data.means[[x]][, y] ~ all.data.means[[x]]$strain,
                                 vertical = T,
                                 pch = NA,
                                 cex.axis = 0.8,
                                 main = names(all.data.means[x]),
                                 ylab = gsub("_", " ", names(all.data.means[[x]][y])))
                      lapply(1:length(strain.names),
                             function(q){
                                 lines(x = c(q - 0.25, q + 0.25),
                                       y = rep(all.data.mean.lines[[x]][q, y], 2),
                                       lwd = 2.5,
                                       col = "black")})
                      stripchart(all.data.means[[x]][, y] ~ all.data.means[[x]]$strain,
                                 vertical = T,
                                 cex.axis = 0.8,
                                 pch = 21,
                                 lwd = 1.25,
                                 col = gray(0.2),
                                 bg = gray(0.8),
                                 add = T,
                                 method = "jitter",
                                 jitter = 0.1,
                                 cex = 1.25)
                      dev.off()
                             })
                  })


## -----
## <<Replicate_Mean_Stripcharts>>
## [x]
## start by creating a list of lists identical in size
## to the individual replicates list
all.data.medians <- vector(mode = "list", length = length(all.data.e))

## now get the mean of each replicate, typically a sample > 10k cells
## the result of this operation is a list of list that's the same
## structure as 'all.data.e', but instead of, e.g., 10,000 rows, each
## individual sample now has only a single value (the mean) for each
## parameter 
all.data.medians <- lapply(1:length(all.data.e), function(x){
                             all.data.means[[x]] <- lapply(1:length(all.data.e[[x]]), function(y){
lapply(1:length(all.data.e[[x]][[y]]), function(i){
           sapply(X = 1:ncol(all.data.e[[x]][[y]][[i]]),
                  FUN = function(m){median(all.data.e[[x]][[y]][[i]][, m])})
       })
})
})

## name the gates, strains, and replicates
rep.names <- vector()
names(all.data.medians) <- names(all.data.e)
## i = 1:3
for(i in seq_along(all.data.medians)){
    names(all.data.medians[[i]]) <- names(all.groups.e[[i]])
    ## h = 1:4
    for(h in seq_along(all.data.medians[[i]])){
        ## g = 1:2        
        for(g in seq_along(all.data.medians[[i]][[h]])){
            rep.names[g] <- all.set[[h]][[g]]@description$"TUBE NAME"
            names(all.data.medians[[i]][[h]]) <- rep.names
            names(all.data.medians[[i]][[h]][[g]]) <- names(all.groups.e[[1]][[1]])
        }}}


## create a similar list that gets the mean of the replicate medians
## you'll use this later for plotting and statistics
## in the first step, bind each replicate into a single list that represents
## a strain
all.data.median.lines <- lapply(all.data.medians, function(x){
                                  lapply(1:length(x), function(y){
                                             colMeans(do.call("rbind", x[[y]]))
                                         })
                              })

for(i in seq_along(all.data.median.lines)){
    names(all.data.median.lines[[i]]) <- strain.names
}


## now bind the list of strains together via 'rbind'
all.data.median.lines <- lapply(all.data.median.lines, function(x){
                                  as.data.frame(do.call("rbind", x))
                              })

all.data.medians <- lapply(all.data.medians, function(x){
                             lapply(x, function(y){
                                        as.data.frame(do.call("rbind", y))
                                    })
                         })

all.data.medians <- lapply(all.data.medians, function(x){
                             do.call("rbind", x)
                         })


strain.rep.factor <- vector(mode = "list",
                            length = length(all.data.e))
strain.rep.factor <- lapply(1:length(all.data.e), function(x){
                                strain.rep.factor[[x]] <- factor(x = unlist(lapply(1:length(all.data.e[[x]]), function(y){
rep(y, times = length(all.data.e[[x]][[y]]))
})), labels = strain.names)
})


for(i in 1:length(all.data.medians)){
    all.data.medians[[i]]$strain <- strain.rep.factor[[i]]
}


## now plot across gates/parameters
## set up some dirs first
setwd(results.dir)
dir.create(path = paste0(results.dir, "/between_groups_median_stripcharts"))
median.stripcharts.dir <- paste0(results.dir, "/between_groups_median_stripcharts")
setwd(median.stripcharts.dir)


lapply(1:length(all.data.medians), function(x){
           lapply(1:(ncol(all.data.medians[[x]]) - 1), function(y){
                      pdf(file = paste0(names(all.data.medians[x]), "_",
                                        names(all.data.medians[[x]][y]),
                                        "_median_betw_groups_strip.pdf"),
                          height = 7,
                          width = 7,
                          bg = "transparent")
                      ## 'dummy' plot that we'll overplot on 
                      stripchart(all.data.medians[[x]][, y] ~ all.data.medians[[x]]$strain,
                                 vertical = T,
                                 pch = NA,
                                 cex.axis = 0.8,
                                 main = names(all.data.medians[x]),
                                 ylab = gsub("_", " ", names(all.data.medians[[x]][y])))
                      ## add mean lines
                      lapply(1:length(strain.names), function(q){
                                 lines(x = c(q - 0.25, q + 0.25),
                                       y = rep(all.data.median.lines[[x]][q, y], 2),
                                       lwd = 2.5,
                                       col = gray(0))})
                      ## overplot medians
                      stripchart(all.data.medians[[x]][, y] ~ all.data.medians[[x]]$strain,
                                 vertical = T,
                                 cex.axis = 0.8,
                                 pch = 21,
                                 lwd = 1.25,
                                 col = gray(0.2),
                                 bg = gray(0.8),
                                 add = T,
                                 method = "jitter",
                                 jitter = 0.1,
                                 cex = 1.25)
                      dev.off()
                             })
                  })


## -----
## <<Summary_Tables>>
## [x]
## write the data we use for statistics to tables
## I format the decimal places to 3 to make reading
## the output easier.  This is accomplished via
## 'sprintf', which converts to character, so make
## separate objects for writing table output 
setwd(tables.dir)
all.data.means.round <- all.data.means
for(i in seq_along(all.data.means.round)){
        for(h in seq_along(all.data.means.round[[i]])){
            if(!is.factor(all.data.means.round[[i]][, h]))
                all.data.means.round[[i]][, h] <- sprintf("%.3f", all.data.means.round[[i]][, h])
}}


lapply(seq_along(all.data.means.round), function(x){
           write.table(x = all.data.means.round[[x]], 
                       file = paste0(names(all.data.means.round[x]),
                                   "_sample_means_table.csv"),
                       ## necessary to prevent empty column
                       ## where rownames inserted 
                       col.names = NA,
                       row.names = T,
                       ## don't enclose everything in double quotes
                       quote = F,
                       sep = ",")}
       )


## same operation but for medians 
all.data.medians.round <- all.data.medians
setwd(tables.dir)
all.data.medians.round <- all.data.medians
for(i in seq_along(all.data.medians.round)){
        for(h in seq_along(all.data.medians.round[[i]])){
            if(!is.factor(all.data.medians.round[[i]][, h]))
                all.data.medians.round[[i]][, h] <- sprintf("%.3f", all.data.medians.round[[i]][, h])
}}


lapply(seq_along(all.data.medians.round), function(x){
           write.table(x = all.data.medians.round[[x]],
                       file = paste0(names(all.data.medians.round[x]),
                                     "_sample_medians_table.csv"),
                       ## necessary to prevent empty column
                       ## where rownames inserted 
                       col.names = NA,
                       row.names = T,
                       ## don't enclose everything in double quotes
                       quote = F,
                       sep = ",")}
       )



##-----
## <<Flow_Cytometry_Statistics>>
## [x]
## set up directories
setwd(base.dir)
dir.create(path = paste0(base.dir, "/statistical_analysis"))
stats.dir <- paste0(base.dir, "/statistical_analysis")
setwd(stats.dir)

lapply(1:length(all.data.means), function(x){
           lapply(1:(ncol(all.data.means[[x]])), function(y){
                      if(!is.factor(all.data.means[[x]][, y])){
                          mean.aov <- aov(all.data.means[[x]][, y] ~
                                              all.data.means[[x]]$strain)
                          s.mean   <- capture.output(summary(mean.aov))
                          ptest    <- capture.output(PostHocTest(x = mean.aov,
                                                                 method = "lsd",
                                                                 conf.level = 0.95))
                      cat(c("\n\n-----",
                            paste0(names(all.data.means[[x]][y])),
                            "-----\n",
                            s.mean, ptest),
                          file = paste0(names(all.data.means[x]),
                                        "_means_statistics.txt"),
                          sep = "\n",
                          append = T)
                      }
                  })
       })


lapply(1:length(all.data.medians), function(x){
           lapply(1:(ncol(all.data.medians[[x]])-1), function(y){
                      if(!is.factor(all.data.means[[x]][, y])){
                          median.aov <- aov(all.data.medians[[x]][, y] ~
                                                all.data.medians[[x]]$strain)
                          s.median   <- capture.output(summary(median.aov))
                          ptest      <- capture.output(PostHocTest(x = median.aov,
                                                                   method = "lsd",
                                                                   conf.level = 0.95))
                      cat(c("\n\n-----",
                            paste0(names(all.data.medians[[x]][y])),
                            "-----\n",
                            s.median, ptest),
                          file = paste0(names(all.data.medians[x]),
                                        "_medians_statistics.txt"),
                          sep = "\n",
                          append = T)
                          }
                  })
       })


##-----
## <<Cell_Count_Stripcharts>> 
## [x]
## last thing is the replicate cell count plots
## put these into the stripchart format I used above
## this uses the object 'strain.rep.factor' that isn't 
## created until late in the code, so this piece of analysis
## ends up here. 
setwd(cell.count.dir)
individual.cell.counts <- lapply(all.data.e, function(x){
                                     lapply(x, function(y){
                                                lapply(y, function(q){
                                                           nrow(q)
                                                       })
                                            })
                                 })

individual.cell.counts <- lapply(individual.cell.counts, function(x){
                                     unlist(lapply(x, function(y){
                                                       unlist(y)
                                                   }))
                                 })

individual.cell.dataframe <- Map(f = function(x, y){data.frame(count = x, strain = y)},
                                 x = individual.cell.counts, y = strain.rep.factor)

individual.mean.lines <- lapply(individual.cell.dataframe, function(x){
                                    unlist(lapply(strain.names, function(y){
                                                      mean(x[x$strain == y, 1])
                                                  }))
                                })

lapply(1:length(individual.cell.dataframe), function(x){
           pdf(file = paste0(names(individual.cell.dataframe[x]),
                             "_individual_cell_count_strip.pdf"),
               height = 7, width = 7, bg = "transparent")
           ## dummy chart
           stripchart(count ~ strain, data = individual.cell.dataframe[[x]],
                      vertical = T, cex.axis = 0.8, pch = NA, lwd = 1.25,
                      method = "jitter", jitter = 0.1, ylab = "Cell Count", 
                      main = names(individual.cell.dataframe[x]))
           ## plot the mean lines
           lapply(1:length(strain.names), function(q){
                                 lines(x = c(q - 0.25, q + 0.25),
                                       y = rep(individual.mean.lines[[x]][q], 2),
                                       lwd = 2.5, col = gray(0))})
           ## overplot the actual values
           stripchart(count ~ strain,
                      data = individual.cell.dataframe[[x]],
                      vertical = T,
                      cex.axis = 0.8,
                      pch = 21,
                      lwd = 1.25,
                      col = gray(0.2),
                      bg = gray(0.8),
                      cex = 1.25,
                      method = "jitter",
                      jitter = 0.1, add = T)
           dev.off()
       })



#+END_SRC
