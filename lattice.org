# My notes on the use-R lattice book
file+emacs:~/foundational_books/lattice.pdf 

* Links
https://www.stat.auckland.ac.nz/~paul/useR2015-grid/grid-slides.html
https://www.stat.auckland.ac.nz/~paul/useR2015-grid/
+ better link to the full course, including R code
file+emacs:~/foundational_books/grid_lattice_slides_murrell.pdf 

https://bookdown.org/rdpeng/RProgDA/the-grid-package.html
+ another grid tutorial 

* Useful Commands
#+BEGIN_SRC R
## find the viewport for the plot you're working on
grid.ls(viewport = T, grobs = F)

x <- -10:10
y <- x^2 - (2 * x)

## make a plot object
pl <- xyplot(y ~ x, type = c("l", "g"))

## print the plot
print(pl)

pg <- grid.grabExpr(print(pl))

print(pl)
trellis.grobname(pl)

vp_1 <- viewport(x = 3, y = 7,
               height = 14,
               width = 6,
               default.units = "in",
               name = "mac_1")

dev.new()
pushViewport(vp_1)

pdf(file = "~/Desktop/grid_test.pdf", height = 14, width = 6)
print(pl, newpage = F)
grid.text(label = "this test", x = 3, y = 3, default.units = "in")
dev.off()
#+END_SRC
* Table of Contents
[[elisp:(mplink "~/foundational_books/lattice.pdf" 13)]]

[[elisp:(mplink "~/foundational_books/lattice.pdf" 49)]] - chapter 3
[[elisp:(mplink "~/foundational_books/lattice.pdf" 81)]] - chapter 5

* REVIEW Notes
file+emacs:~/foundational_books/lattice.pdf 

** All Lattice Plots
[[elisp:(mplink "~/foundational_books/lattice.pdf" 26)]]
+ all forms of lattice plots

    - histogram()   ::
    - densityplot() ::
    - qqmath()	    :: theoretrical
    - qq()	    ::
    - stripplot()   ::
    - bwplot()	    :: boxplot 
    - dotplot()	    ::
    - barchart()    ::
    - xyplot()	    ::
    - splom()	    :: all x all scatter plot matrix
    - levelplot()   :: heatmap
    - wireframe()   ::
    - cloud()	    ::
    - parallel	    :: 


[[elisp:(mplink "~/foundational_books/lattice.pdf" 46)]]
+ *critical early section on the panel function*

** Overall and Key Concepts
The structure of lattice functions is as follows:

    - [1] display type :: e.g., histogram, density plot
                          + this is the function you cal
    - [2] variable role :: dependent measure, conditioning, superpositioing
                           + conditioning = multiple panels
                           + superpositioning = all in the same plot
    - [3] aspect ratio :: height/width
                          + often have to trial and error this
                          + in lattice, can be a number (v/h)
                          + "fill" - make panels as big as possible
                          + "xy" - 45 degree banking rule
                          + "iso" - use when data have same scale
    - [4] layout :: numeric vector specifying n. columns, rows, pages
                    + don't need to supply pages arg. 
    - [5] as.table :: T means plot the first panel in the top left
                      + I think this is usually what I want
    - [6] t(trellis.obj) :: this can improve the layout of the plot 
                            + see [[tp_oats_example]]

A key concept is the 'auto.key' parameter, which specifies how the legend is
formatted.  e.g., auto.key = list(columns = 4) says use 4 columns in the
legend. 

**** Printing Multiple Plots to the Same Page
#+BEGIN_SRC R :results graphics :file /tmp/lat_page.pdf
## -----
## make several plots and put them on the same page
a <- rnorm(500, mean = 100, sd = 10)
b <- runif(n = 500, min = 10, max = 150)
c <- rcauchy(n = 500, location = 1, scale = 2)
d <- as.factor(rep(c(1, 2, 3, 4), 500/4))
dat <- data.frame(a = a, b = b, c = c, fac = d)

## first store plots as objects
library("lattice")
aplot <- densityplot(~ a | fac,
                     data = dat,
                     ref = T,
                     plot.points = F,
                     )
bplot <- densityplot(~ b | fac,
                     data = dat,
                     ref = T,
                     plot.points = F,
                     )
cplot <- densityplot(~ c | fac,
                     data = dat,
                     ref = T,
                     plot.points = F,
                     )

## now specify a layout as (x, y, nx, ny)
## put 'a' as the first plot in a row of three
## make sure to include 'newpage = F' too!
print(aplot, split = c(1, 1, 3, 1))
print(plot(bplot, split = c(2, 1, 3, 1), newpage = F))
print(plot(cplot, split = c(3, 1, 3, 1), newpage = F))

#+END_SRC

#+RESULTS:
[[file:/tmp/lat_page.pdf]]

** Tips and Tricks

    - [1] pch = "." makes nice little dots
          + works well w/ xyplot 
          + can evidently use any string for pch
            - e.g., pch = "a" also works 
          + pair w/ cex = 2 for better sizing

* 1 - Introduction
[[elisp:(mplink "~/foundational_books/lattice.pdf" 18)]]

**** 1.1 - Multipanel Conditioning
[[elisp:(mplink "~/foundational_books/lattice.pdf" 19)]]

#+BEGIN_SRC R
## -----
## load some data
## British chemical exam performance 
if(!requireNamespace("mlmRev"))
   install.packages("mlmRev")
requireNamespace("mlmRev")

library("mlmRev")
xtabs(~ score, data = Chem97)

## we'll use GCSE score to predict chem score
library("lattice")
histogram(~ gcsescore | factor(score), data = Chem97)

#+END_SRC

#+RESULTS:

In the code above, the "|" denotes the conditioning factor.  For this specific
piece of code, the dependent variable (chem exam score) actually becomes the
conditioning variable via a call to 'factor'.  

Note that multiple conditioning variables can be used: 

#+BEGIN_SRC R
if(!requireNamespace("mlmRev"))
   install.packages("mlmRev")
requireNamespace("mlmRev")
xtabs(~ score, data = Chem97)

## we'll use GCSE score to predict chem score
library("lattice")
histogram(~ gcsescore | factor(age) * factor(score), data = Chem97)

#+END_SRC

**** 1.1.3 Kernel Density Plots
[[elisp:(mplink "~/foundational_books/lattice.pdf" 21)]]
The lattice equivalent to a density plot is accessed via 'densityplot':

#+BEGIN_SRC R :results graphics :file /tmp/density.pdf
## -----
## set up a multi-conditioned density plot
if(!requireNamespace("mlmRev"))
   install.packages("mlmRev")
requireNamespace("mlmRev")

## more histogram fiddling 
library("mlmRev")
library("lattice")
histogram(~ gcsescore | factor(gender), data = Chem97)

## now do it as a density plot for comparison
## ref adds a reference line at 0
densityplot(~ gcsescore | factor(gender),
            data = Chem97,
            plot.points = F,
            ref = T)

## the actual example from the text
## ref adds a reference line at 0
print(densityplot(~ gcsescore | factor(score),
            data = Chem97,
            plot.points = F,
            ref = T))
#+END_SRC

#+RESULTS:
[[file:/tmp/density.pdf]]

** 1.2 Superposition
[[elisp:(mplink "~/foundational_books/lattice.pdf" 22)]]
This section introduces a key concept, superposition, and by doing so creates a
relevant contrast with the previous concept of conditioning:

    - [1] conditioning :: creating multiple /panels/ in a single plot across the
         various levels of some factor

    - [2] superpositing :: plotting all of the various levels of some factor in
         a single plot and distinguishing factor levels by, e.g., lty

Compare the plots below: 

#+BEGIN_SRC R :results graphics :file /tmp/super.pdf
## -----
## setup
if(!requireNamespace("mlmRev"))
    install.packages("mlmRev")
library("mlmRev")
library("lattice")
densityplot(~ gcsescore,
            data = Chem97,
            groups = score,
            plot.points = F,
            ref = T,
            auto.key = list(columns = 3))

## compare conditioning versus superposition
## use gender for conditioning; score for superposition
print(
densityplot(~ gcsescore | gender,
            data = Chem97,
            groups = score,
            plot.points = F,
            ref = T,
            auto.key = list(columns = 2))
)
## 'auto.key' sets the legend (here we specify 3 columns for it)
#+END_SRC

#+RESULTS:
[[file:/tmp/super.pdf]]

** 1.3 the "Trellis" Object
[[elisp:(mplink "~/foundational_books/lattice.pdf" 23)]]
This section deals with the need to call 'print' in order to display the results
of a lattice plot.  It contains a few additional 'under-the-hood' notes about
how R works:

    - [1] most functions in R do not produce output; instead they return an object
          + makes a distinction betw. output vs. object clearer

    - [2] lattice functions don't draw anything; they return 'trellis' objects.
      Calling print with these objects will return the graphical display, but
      more interestingly, the trellis objects themselves contain high-level
      summary information that can be viewed:

#+BEGIN_SRC R :results graphics :file /tmp/trellis.png
library("mlmRev")
library("lattice")

## make a 'trellis' object
t.obj <- densityplot(~ gcsescore | score,
                     data = Chem97,
                     groups = gender,
                     plot.points = F,
                     ref = T,
                     auto.key = list(columns = 2,
                                     space = "top",
                                     title = "score"))
                     
## a call to 'print' will display the object
## equiv. to 'plot()'
print(t.obj)
## or plot(t.obj)

## grab useful summary information from the 'trellis' object
## in particular, the contingency table is cool 
summary(t.obj)

#+END_SRC

#+RESULTS:
[[file:/tmp/trellis.png]]

The notion that lattice plots are R objects allows them to be easily and readily
put together in multiplot pages, as in the following example: 

#+BEGIN_SRC R :results graphics :file /tmp/multipanel.png
## -----
## setup
library("mlmRev")
library("lattice")

## make a 'trellis' density plot object
t1.obj <- densityplot(~ gcsescore,
                      groups = score,
                      data = Chem97,
                      plot.points = F,
                      ref = T,
                      auto.key = list(columns = 2,
                                      space = "top",
                                      title = "score"))

t2.obj <- histogram(~ gcsescore | score * gender,
                    data = Chem97,
                    )

## now do the print call and specify the layout
## so that we get both plots in the same page
print(t2.obj, split = c(1, 1, 1, 2))
print(t1.obj, split = c(1, 2, 1, 2),
      newpage = F)

#+END_SRC

#+RESULTS:
[[file:/tmp/multipanel.png]]

* 2 - A Technical Overview of Lattice
[[elisp:(mplink "~/foundational_books/lattice.pdf" 28)]]

#+BEGIN_SRC R

library("mlmRev")
library("lattice")

## make a 'trellis' density plot object
## I think for a 1D plot, you can't do x ~ y formulas
densityplot(score ~ gcsescore,
            groups = gender,
            data = Chem97,
            plot.points = F,
            ref = T,
            auto.key = list(columns = 2,
                            space = "top",
                            title = "Score",
                            lwd = 4,
                            cex = 0.75,
                            size = 4))

## but, w/ a 2D plot setup, you can do x~y: 
xyplot(score ~ gcsescore,
       groups = gender,
       data = Chem97,
       pch = 19,
       auto.key = list(columns = 2,
                       space = "top",
                       title = "Score",
                       lwd = 2,
                       cex = 0.75,
                       size = 4))

xyplot(score ~ gender,
       data = Chem97,
       pch = 19,
       auto.key = list(columns = 2,
                       space = "top",
                       title = "Score",
                       lwd = 2,
                       cex = 0.75,
                       size = 4))


#+END_SRC

**** 2.1.2 The 'data' Argument
[[elisp:(mplink "~/foundational_books/lattice.pdf" 29)]]
This section mentions that the 'data' argument:

    - [1] occurs as the second arg in high-level lattice functions
    - [2] does not have to be named (but can be)

In regards to [2], I think this would mean that you could avoid having to make
calls like "flow_object$FSC.A" and simply replace it with "FSC.A", provided you
supplied "data = flow_object" to the plot (and note how using 'data = ' makes
for cleaner axis labeling in the plots): 

#+BEGIN_SRC R :results graphics :file /tmp/data.png
library("lattice")
dat <- data.frame(x = rnorm(100, mean = 100, sd = 10),
                  y = runif(n = 100, min = 10, max = 140))

## two separate ways to plot the same data
## and notice how using 'data = ' produces a cleaner legend! 
one <- xyplot(x ~ y, data = dat)
two <- xyplot(dat$x ~ dat$y)

print(one, split = c(1, 1, 1, 2))
print(two, split = c(1, 2, 1, 2), newpage = F)

#+END_SRC

#+RESULTS:
[[file:/tmp/data.png]]

**** REVIEW 2.1.4 Shingles
[[elisp:(mplink "~/foundational_books/lattice.pdf" 30)]]
This section discusses the concept of 'shingles', which are interval bins used
to condition continuous variables.  i.e., shingles allow you to condition on a
continuous variable.  There's a nice detail on: 

[[elisp:(mplink "~/foundational_books/lattice.pdf" 31)]]
about how to create intervalic bins for shingles.  The 'equal.count' function
uses an algorithm to make bins for a continuous variate.

A nice use of this functionality would be to bin across FSC and plot the various
other parameters.  Ideally, you'd see that while the GFP and RFP levels depend
on FSC, that's not true of the TFT ratio.  

------------
/2020.11.28/
------------
I found the description of shingles in the text and the help page confusing.
The best way to understand it, I think, is to use the example code found in the
help page.  It provides tools for visualizing a shingle.  This works better than
inspecting the data from evaluating the shingle object, which isn't especially
informative.  

#+NAME: 2020.11.29_final_shingle_example_code
#+BEGIN_SRC R 
## setup
library("lattice")

###########################################################
## EQUAL.COUNT - generate shingles w/ equal count algorithm
###########################################################
## this example uses the 'equal.count' function
## to generate the shingle
## start with a continuous variable 's' that
## we'll make a shingle from 
s <- runif(n = 500, min = 0, max = 1000)
s_shingle <- equal.count(s)

## THIS IS THE MOST IMPORTANT command
## inspect the shingle graphically
plot(s_shingle)

## now make a data frame and some conditional plots
d  <- rnorm(n = 500, mean = 100, sd = 20)
f  <- as.factor(rep(1:4, length.out = length(d)))
df <- data.frame(d = d, s_shingle = s_shingle, f = f)

## boxplot conditioned on shingle and discrete factor
bwplot(~ d | s_shingle * f,
       data = df)

## some additional useful arguments to 'equal.count':
## 1. number - the number of bins
## 2. overlap - the percentage overlap between shingles
old_s_shingle <- equal.count(s)
new_s_shingle <- equal.count(s, number = 10, overlap = 0.01)
plot(new_s_shingle)

d <- rnorm(n = 500, mean = 100, sd = 20)
f <- as.factor(rep(1:4, length.out = length(d)))
df <- data.frame(d = d, new_s_shingle = new_s_shingle,
                 old_s_shingle = old_s_shingle, f = f)

## plot the new shingle w/ pre-specified n. intervals
## and % overlap between intervals 
densityplot(~ d | new_s_shingle,
            data = df,
            plot.points = F)

## notice how 'equal.count' w/o the addn. args.
## produces a cleaner result
densityplot(~ d | old_s_shingle,
            data = df,
            plot.points = F)

###########################################################
## EQUAL.COUNT - generate shingles w/ equal count algorithm
###########################################################
## syntax for this one is hard to find, but finally found some
## information.  the shingle function isn't well documented,
## but the basic idea is that w/ no interval argument supplied,
## lattice makes every possible value a level of the shingle.
## The trick to supplying levels to the shingle function is
## rbind'ing them in the syntax as shown below:

## continuous variable we'll condition on 
shingle_var   <- rnorm(500, mean = 100, sd = 20)
discrete_var  <- rep(1:4, times = length(shingle_var))
dependent_var <- runif(n = 500, min = 10, max = 200)

## now make a shingle w/ 4 intervals: 
my_shingle <- shingle(shingle_var,
                      intervals = rbind(c(10, 50),
                                        c(51, 100),
                                        c(101, 150),
                                        c(151, 200)))

## notice the summary information you get from
## this command, incl. overlap 
my_shingle

## inspect visually
plot(my_shingle)

## now make a data frame and plot
my_frame <- data.frame(discrete_var = discrete_var,
                       dependent_var = dependent_var)

densityplot(~ dependent_var | my_shingle * discrete_var,
            data = my_frame)
#+END_SRC

#+NAME: FSC_as_shingle_plot
#+BEGIN_SRC R :results graphics :file /tmp/fsc_shingle.png
## -----
## basic example of how to use a continuous variable
## as a factor in lattice plots
dep <- rnorm(500, mean = 100, sd = 10)
fac <- equal.count(runif(n = 500, min = 10, max = 210))
Fac <- as.factor(rep(c(1, 2, 3, 4), 500/4))
dat <- data.frame(dep = dep, fac = fac, Fac = Fac)

## separate panels for the continuous factor 
## multipanel plot conditioned on continuous factor 
densityplot(~ dep | fac,
            data = dat,
            ref = T,
            plot.points = F)

## multipanel plot conditioned on discrete factor 
densityplot(~ dep | Fac,
            data = dat,
            ref = T,
            plot.points = F)

## single plot split by group levels
## this doesn't work 
densityplot(~ dep,
            groups = fac,
            data = dat,
            ref = T,
            plot.points = F,
            auto.key = list(columns = 2))

## single plot split by discrete factor 
densityplot(~ dep,
            groups = Fac,
            data = dat,
            ref = T,
            plot.points = F,
            auto.key = list(columns = 2,
                            title = "Group"))


## -----
## now try it w/ some flow data
f.name <- "~/data/flow/2020.04.28_OFA0652_TDH3pr_dsRed_TFT_flow/fcs/BY_0652_dsRed_TFT_003.fcs"
fl <- read.flowSet(files = f.name,
                   min.limit = 1,
                   alter.names = T)

trunc.trans   <- truncateTransform("Convert 0's to 1's.", a = 1)
trunc.fluors  <- function(x){
    transform(x,
              `eGFP.A` = trunc.trans(`eGFP.A`),
              `DsRed.A` = trunc.trans(`DsRed.A`))}

fl <- fsApply(x = fl, FUN = trunc.fluors)

PSV.TFT.transform <- function(x){
    transform(x,
              `log_GFP` = log10(`eGFP.A`),
              `log_RFP` = log10(`DsRed.A`),
              `TFT_ratio` = log(`DsRed.A`/`eGFP.A`, base = 2),
              `PSV_ratio` = log(`eGFP.A`/`DsRed.A`, base = 2),
              ## 'no log' TFT ratio
              `nl_TFT_ratio` = (`DsRed.A`/`eGFP.A`)
              )}

fl <- fsApply(x = fl, FUN = PSV.TFT.transform)
fld <- as.data.frame(exprs(fl[[1]]))
fld$fac <- equal.count(fld$FSC.A)
str(fld)


gplot <- densityplot(~ log_GFP | fac,
                     data = fld,
                     ref = T,
                     plot.points = F)

rplot <- densityplot(~ log_RFP | fac,
                     data = fld,
                     ref = T,
                     plot.points = F)

tplot <- densityplot(~ TFT_ratio | fac,
                     data = fld,
                     ref = T,
                     plot.points = F)

plot(gplot, split = c(1, 1, 1, 3))
plot(rplot, split = c(1, 2, 1, 3),
     newpage = F)
plot(tplot, split = c(1, 3, 1, 3),
     newpage = F)

print(tplot)
#+END_SRC

#+RESULTS: FSC_as_shingle_plot
[[file:/tmp/fsc_shingle.png]]

** 2.2 Dimension and Physical Layout
[[elisp:(mplink "~/foundational_books/lattice.pdf" 31)]]

Functions used:

    - [1] xtabs :: create a contingency table of 2 or more factor levels
                   + tells you n. obs. per combination of factor levels
                   + xtabs(~var_1 + var_2, data = dataframe)
                     xtabs(~strain + replicate,
                           data = fsc_gate_exprs)

:xtabs-output:
        replicate
strain     1    2    3    4    5    6    7    8
  BY    2757 2611 2697 2458 2530 2737 2944 2629
  RM    2835 2665 2684 2612 2585 2890 2892 2741
  rpn4  2801 2593 2040 2041 2516 1879 1948 2464
  ubr1  2584 2526 3840 2411 2547 2478 2602 2730
  doa10 2750 2749 2656 2480 2594 2584 2710 3073
:END:

#+BEGIN_SRC R
if(!requireNamespace("MEMSS"))
    install.packages("MEMSS")

library("MEMSS")

tp1.oats <- xyplot(yield ~ nitro | Variety * Block,
                   data = Oats,
                   type = "o")

plot(tp1.oats)

dim(tp1.oats) ## 3 6 -> varities * 6 blocks (see next line)
dimnames(tp1.oats)

## nice cross-tab table of data
xtabs(~Variety + Block, data = Oats)

## even more summarization
summary(tp1.oats)

## we can subset elements of the the trellis object
summary(tp1.oats[, 1])
summary(tp1.oats[, 4])
summary(tp1.oats[2, 1])

print(tp1.oats[, 1]) ## or
plot(tp1.oats[, 1])
plot(tp1.oats[1 , ])

## extract a plot of a single level
plot(tp1.oats[3, 4])

## grab a subset of plots
dim(tp1.oats)
plot(tp1.oats[1:2, 3:4])
plot(tp1.oats[c(1,2), c(1,2)])
## seems they need to be contiguous though...
plot(tp1.oats[c(1,4), c(1,6)])
#+END_SRC

**** 2.2.1 Aspect Ratio
[[elisp:(mplink "~/foundational_books/lattice.pdf" 34)]]

    - [1] aspect ratio :: height/width
                          + often have to trial and error this
                          + can be a number 
                          + "xy"
                            - tries to make slope = 45°
                          + "iso"
                            - use when data have same scale

#+BEGIN_SRC R
if(!requireNamespace("MEMSS"))
    install.packages("MEMSS")

library("MEMSS")

## the "xy" argument attempts to put the slope of the lines
## in the plot on a 45 degree angle - here, with a small
## slope, the plot gets squishy
tp1.oats <- xyplot(yield ~ nitro | Variety * Block,
                   data = Oats,
                   type = "o",
                   aspect = "xy")
plot(tp1.oats)

## yeesh
tp1.oats <- xyplot(yield ~ nitro | Variety * Block,
                   data = Oats,
                   type = "o",
                   aspect = "iso")
plot(tp1.oats)

## not bad...
tp1.oats <- xyplot(yield ~ nitro | Variety * Block,
                   data = Oats,
                   type = "o",
                   aspect = 5)
plot(tp1.oats)


#+END_SRC

**** 2.2.2 Layout
[[elisp:(mplink "~/foundational_books/lattice.pdf" 35)]]
The "xy" aspect ratio is a good way to show rates of change in an xyplot, but
can lead to a squished layout.  By altering the "layout" parameter, we can get
around this issue. 

#+BEGIN_SRC R :results graphics :file /tmp/layout.png
library("lattice")
library("MEMSS")

## <<tp_oats_example>>
## start with a plot; use "xy" aspect ratio to make
## the differences across time points more clear
tp1.oats <- xyplot(yield ~ nitro | Variety + Block,
                   data = Oats,
                   type = "o",
                   aspect = "xy",
                   as.table = T)

plot(tp1.oats)

## but the plot is squished now; let's fix that.

## one option is to transpose the matrix:
plot(t(tp1.oats))
## surprisingly better!
## notice how the layout improves as well


## -----
## using the 'layout' option
## update can be used to change lattice objects
## layout sets bounds on n. panels per page
tp1.oats <- xyplot(yield ~ nitro | Variety + Block,
                   data = Oats,
                   type = "o",
                   aspect = "xy",
                   as.table = F,
                   layout = c(0, 18))

tp1.oats <- xyplot(yield ~ nitro | Variety + Block,
                   data = Oats,
                   type = "o",
                   aspect = "xy",
                   as.table = F,
                   layout = c(0, 18),
                   between = list(x = c(0, 0, 0.5),
                                  y = 0.5))

print(tp1.oats)

#+END_SRC

#+RESULTS:
[[file:/tmp/layout.png]]

** 2.3 Grouped Displays
[[elisp:(mplink "~/foundational_books/lattice.pdf" 39)]]
Here, we expand on the familiar formula call to create what is effectively an xy
plot of a continuous variable (x axis) and a discrete variable (y axis).  The
effect is to see the different values that the x axis variable takes at the
different levels of the y axis variable.  

#+BEGIN_SRC R

dotplot(variety ~ yield | site,
        data = barley,
        layout = c(1, 6),
        aspect = c(0.7),
        groups = year,
        auto.key = list(space = "top"))

#+END_SRC

** 2.4 Annotation
[[elisp:(mplink "~/foundational_books/lattice.pdf" 41)]]
There is considerable flexibility in how the legends are produced by lattice.
The main point of this section seems to be that 'auto.key' is the way to
customize a legend, rather than via explicit calls to formatting parameters.
Also of note is the mention that outside of 'auto.key', the following are
available for customizing the plot:

    - [1] xlab
    - [2] ylab
    - [3] main

A brief example of customizing a legend follows: 
#+BEGIN_SRC R :results graphics :file /tmp/leg.png
library("lattice")
library("MEMSS")
## -----
## make a legend then apply it to a lattice plot
key.variety <- list(space = "right",
                    text = list(levels(Oats$Variety)),
                    points = list(pch = 1:3,
                                  col = "black"),
                    columns = 1)

print(
xyplot(yield ~ nitro | Block,
       data = Oats,
       type = "o",
       aspect = "xy",
       groups = Variety,
       key = key.variety,
       lty = 1,
       pch = seq_along(levels(Oats$Variety)),
       col.line = "darkgrey",
       col.symbol = "black",
       xlab = "Nitrogen conc. (cwt/acre)",
       ylab = "Yield (bushels/acre)",
       main = "Yield of three varieties of oats",
       sub = "A 3 x 4 split-plot experiment with 6 blocks")
)
       
#+END_SRC

#+RESULTS:
[[file:/tmp/leg.png]]

**** 2.5.1 Scales and Axes
[[elisp:(mplink "~/foundational_books/lattice.pdf" 43)]]
The default choice for axes in a lattice plot is the smallest window that
encompasses the range of the data.  This may not produce a satisfactory plotting
result if there are large differences in range across panels, as in the
following example:

#+BEGIN_SRC R :results graphics :file /tmp/axes.png
## -----
## use the Titanic dataset
td <- as.data.frame(Titanic)

## in the default setting of scales, the x axis
## is constant across panels.  this doesn't work
## well when the number/range in the panels is
## highly divergent
barchart(Class ~ Freq | Sex + Age,
         groups = Survived,
         data = td,
         stack = T,
         layout = c(4, 1),
         auto.key = list(title = "Survived",
                         columns = 2,
                         space = "top"))

## setting the scales arg to "free" provides
## better visualization of highly variable numbers
## of observations.  notice how this example is
## particularly well-suited to this approach due to
## the fact that each panel visualizes a proportion
## through the use of stacked bars 
barchart(Class ~ Freq | Sex + Age,
         groups = Survived,
         data = td,
         stack = T,
         layout = c(4, 1),
         auto.key = list(title = "Survived",
                         columns = 2,
                         space = "top"),
         scales = list(x = "free"))

#+END_SRC

**** 2.5.2 the Panel Function
[[elisp:(mplink "~/foundational_books/lattice.pdf" 45)]]
"By convention, the name of the panel function is given by 'panel.' followed by
the name of the high-level function.  For example, the default panel function for barchart() is called panel.barchart." 

#+BEGIN_SRC R
## -----
## setup
t.bc <- barchart(Class ~ Freq | Sex + Age,
                 as.data.frame(Titanic),
                 groups = Survived,
                 stack = T,
                 layout = c(4, 1),
                 auto.key = list(title = "Survived",
                                 columns = 2),
                 scales = list(x = "free")
                 )
print(t.bc)

## calling 'update' seems to re-print the trellis obj.
update(t.bc, layout = c(1, 4))

## but the update isn't preserved if we call print ourselves
print(t.bc)

## but, the text says we can assign the updated object
u.bc <- update(t.bc, layout = c(1, 4))
print(u.bc,
      split = c(1, 1, 1, 2))
print(t.bc,
      split = c(1, 2, 1, 2),
      newpage = F)


## -----
## we can specify the panel function with a call to 'update'
update(t.bc, panel = panel.barchart)
## I think this gets at the difference between trellis objects
## and the graphics they produce.  notice that calling the
## barchart trellis object with a stripplot function leads
## to a stripplot
update(t.bc, panel = panel.stripplot)
update(t.bc, panel = panel.xyplot)
update(t.bc, panel = panel.dotplot)

#+END_SRC

**** REVIEW 2.5.3 the Panel Function Demystified
[[elisp:(mplink "~/foundational_books/lattice.pdf" 46)]]
This is a critical section.  Re-read this and be sure to understand it.

This section deals with the idea that *panel functions are themselves functions*
*and they are applied to lattice functions to generate the desired plot.*

A key concept is the notion of the "..." function argument listing.  With this
listing we can supply arguments to functions without needing to explicitly know
the name of those functions' arguments.  (can I do this w/ my own functions?).  

#+BEGIN_SRC R
## -----
## setup
t.bc <- barchart(Class ~ Freq | Sex + Age,
                 as.data.frame(Titanic),
                 groups = Survived,
                 stack = T,
                 layout = c(4, 1),
                 auto.key = list(title = "Survived",
                                 columns = 2),
                 scales = list(x = "free")
                 )
print(t.bc)


## -----
## now with a custom panel function that we use when printing
update(t.bc,
       panel = function(...){
           panel.barchart(...)
       })

## now with some actual modifications
## I think the idea here is that we call panel.barchart
## without knowing what formal arguments it requires
## (and indeed, a quick inspection of the args via
## eldoc shows we would need many args)
update(t.bc,
       panel = function(...){
           ## add vertical grid lines
           panel.grid(h = 0, v = -1)
           panel.barchart(...)
       })


update(t.bc,
       panel = function(...){
           ## add vertical grid lines
           panel.grid(h = 0, v = -1)
           panel.barchart(...,
                          ## remove box borders
                          border = "transparent")
       })


## -----
## impressively, we don't even have to call the function
## to supply these addn. args, we can just directly
## supply extra args and they get used appropriately
update(t.bc, border = "transparent")

## you can call this after, but notice how terrible it looks 
panel.grid(h = 0, v = -1)
#+END_SRC

* 3 - Visualizing Univariate Distributions
[[elisp:(mplink "~/foundational_books/lattice.pdf" 49)]]
Common distribution functions:

    - [1] CDF
          + ecdf
          + plot.ecdf

    - [2] density function
          + e.g., dnorm, dunif, etc...

    - [3] quantile function
          + qnorm, qunif, etc...
#+BEGIN_SRC R
## -----
## variations on a simple density plot

## basic version
densityplot(~ eruptions,
            data = faithful,
            plot.points = F,
            ref = T)

## change the density estimation method
densityplot(~ eruptions,
            data = faithful,
            plot.points = F,
            ref = T,
            ## kernel and bw are the parameters
            ## of the density estimate
            kernel = "rect",
            bw = 0.2)

## add the plotted points
densityplot(~ eruptions,
            data = faithful,
            plot.points = "rug",
            ref = T)

## seems we can specify how many points to use
## in the density estimate as well
## BUT THAT DOESN'T AFFECT THE RUG!!!!
densityplot(~ eruptions,
            data = faithful,
            plot.points = "rug",
            ref = T,
            kernel = "rect",
            n = 50)

densityplot(~ eruptions,
            data = faithful,
            plot.points = "rug",
            ref = T,
            n = 10)

## wide bandwidth gives a narrow density 
densityplot(~ eruptions,
            data = faithful,
            plot.points = "rug",
            ref = T,
            bw = 0.1,
            n = 200)

densityplot(~ eruptions,
            data = faithful,
            plot.points = "rug",
            ref = T,
            bw = 1,
            n = 200)

densityplot(~ eruptions,
            data = faithful,
            plot.points = "rug",
            ref = T,
            bw = 0.01,
            n = 200)

densityplot(~ eruptions,
            data = faithful,
            plot.points = "rug",
            ref = T,
            n = 200)

densityplot(~ eruptions,
            data = faithful,
            plot.points = T,
            ref = T,
            n = 200)

#+END_SRC

**** 3.2 Large Datasets
[[elisp:(mplink "~/foundational_books/lattice.pdf" 51)]]
Working with some flow data in this section: 

#+BEGIN_SRC R
## -----
## setup
library("lattice")
library("latticeExtra")

data(gvhd10)
summary(gvhd10)


## -----
## plot
fp <- densityplot(~ log(FSC.H) | Days,
                  data = gvhd10,
                  plot.points = F,
                  ref = T,
                  layout = c(2, 4),
                  )
plot(fp)

xp <- xyplot(FSC.H ~ SSC.H | Days,
             data = gvhd10,
             layout = c(2, 4))
plot(xp)

fl <- densityplot(~ log(FL4.H) | equal.count(FSC.H),
                  data = gvhd10,
                  ref = T,
                  plot.points = F
                  )
plot(fl)
#+END_SRC

**** 3.3 Histograms
[[elisp:(mplink "~/foundational_books/lattice.pdf" 53)]]
Just buries the concept of a histogram in the opening sentence of this
section....

In all seriousness, the text convincingly argues against the use of histograms
in favor of density plots for continuous variates. 

#+BEGIN_SRC R
## -----
## setup
library("lattice")
library("latticeExtra")

data(gvhd10)
summary(gvhd10)

histogram(~ log(FL1.H) | Days,
          data = gvhd10,
          xlab = "Fluorescent Parameter 1",
          type = "density",
          nint = 50,
          layout = c(2, 4)
)

#+END_SRC

**** REVIEW 3.4 Normal Q-Q Plots
[[elisp:(mplink "~/foundational_books/lattice.pdf" 54)]]
This is a explanation of the purpose of a Q-Q plot:

"Graphs quantiles of the observed data against similar quantiles of a
probability distribution conjectured to be a reasonable match.
*For a good fit, the plot is roughly linear.*"

"Q-Q plots are particularly effective because the human eye finds it easier to
perceive deviations from a straight line than from a curve."

#+BEGIN_SRC R
## -----
## notice how the plot below tests normality at all factor levels
## this would be useful, e.g., in looking at whether something like
## strains or treatment conditions BOTH have a normal distribution
library("mlmRev")
qqmath(~ gcsescore | factor(score),
       data = Chem97,
       f.value = ppoints(100))

## the variable "ppoints" indicates how many quantiles (intervals)
## to plot 
qqmath(~ gcsescore | factor(score),
       data = Chem97,
       f.value = ppoints(1000))

## add some annotation
## note that we can supply an 'aspect' arg here
qqmath(~ gcsescore | factor(score),
       data = Chem97,
       f.value = ppoints(100),
       auto.key = list(space = "right"),
       xlab = "Standard Normal Quantiles",
       ylab = "Average GCSE Score",
       aspect = "xy"
       )

qqmath(~ gcsescore | gender,
       groups = factor(score),
       data = Chem97,
       f.value = ppoints(100),
       auto.key = list(space = "right"),
       xlab = "Standard Normal Quantiles",
       ylab = "Average GCSE Score",
       aspect = "iso"
)

#+END_SRC

**** REVIEW 3.4.1 Normality and the Box-Cox Transformation
[[elisp:(mplink "~/foundational_books/lattice.pdf" 56)]]
The Box-Cox transformation is a procedure that helps normalize data according to
the transformation: 

\( f_\lambda(x) = \frac{x^\lambda -1}{\lambda} \)

The "MASS" package can compute an optimum lambda value for a transformation. 

*lot of cool stuff in this section*

#+BEGIN_SRC R :results graphics :file /tmp/box-cox.png
## -----
## setup
packs <- c("lattice", "latticeExtra", "MASS", "mlmRev")
lapply(X = packs, FUN = require, character.only = T)


## have to remove scores of 0 for the transformation
## as n/0 = Inf
chem <- subset(Chem97, gcsescore > 0)
with(chem,
     boxcox(gcsescore ~ score * gender,
            lambda = seq(0, 4, 1/10)))

## now do the transform and re-plot
chem.t <- transform(Chem97,
                    gcsescore.trans = gcsescore^2.34)
print(
qqmath(~ gcsescore.trans | gender,
       data = chem.t,
       groups = score,
       f.value = ppoints(200),
       aspect = "xy",
       auto.key = list(space = "right",
                       title = "score"),
       xlab = "Standard Normal Quantiles",
       ylab = "Transformed GCSE Score"
       ))
#+END_SRC

#+RESULTS:
[[file:/tmp/box-cox.png]]

* 5 - Scatter Plots and Extensions
[[elisp:(mplink "~/foundational_books/lattice.pdf" 81)]]

Functions used:

    - [1] xyplot :: standard xy scatter
    - [2] splom  :: scatter plot matrix

** 5.1 - the Standard Scatter Plot
[[elisp:(mplink "~/foundational_books/lattice.pdf" 81)]]
This section uses the 'quakes' example dataset:

#+NAME: first_example_defaults
#+BEGIN_SRC R

library("lattice")
xyplot(lat ~ long | cut(depth, 2),
       data = quakes)

## note that 'cut':
## divides the range of ‘x’ into intervals and codes the values
## in ‘x’ according to which interval they fall.  The leftmost
## interval corresponds to level one, the next leftmost to level two
## and so on.

cut(quakes$depth, 2)
range(quakes$depth, 2)

## basically, this makes 'depth' a two-level factor that spans 
## two intervals (notice how the output is written in interval notation)

## quakes
## 'data.frame':	1000 obs. of  5 variables:
##  $ lat     : num  -20.4 -20.6 -26 -18 -20.4 ...
##  $ long    : num  182 181 184 182 182 ...
##  $ depth   : int  562 650 42 626 649 195 82 194 211 622 ...
##  $ mag     : num  4.8 4.2 5.4 4.1 4 4 4.8 4.4 4.7 4.3 ...
##  $ stations: int  41 15 43 19 11 12 43 15 35 19 ...


#+END_SRC

#+NAME: second_example_customized
#+BEGIN_SRC R :results graphics :file /tmp/quake.pdf

library("lattice")
## add 3 levels to depth
q <- xyplot(lat ~ long | cut(depth, 3),
       data = quakes,
       aspect = "iso",
       pch = ".",
       cex = 2,
       type = c("p", "g"),
       xlab = "Longitude",
       ylab = "Latitude",
       strip = strip.custom(strip.names = T, var.name = "Depth"),
       scales = list(alternating = F))
print(q)
#+END_SRC

#+RESULTS: second_example_customized
[[file:/tmp/quake.pdf]]

#+NAME: third_example_gray_gradient
#+BEGIN_SRC R :results graphics :file /tmp/gray.pdf

library("lattice")
depth.col <- grey.colors(n = 100)[cut(quakes$depth, 100, label = F)]
depth.ord <- rev(order(quakes$depth))
xyplot(lat ~ long, 
       data = quakes[depth.ord, ],
       aspect = "iso", typ = c("p", "g"),
       col = "black", pch = 21,
       fill = depth.col[depth.ord], 
       cex = 2)

#+END_SRC

*** 5.2 - Advanced Indexing Using Subscripts
[[elisp:(mplink "~/foundational_books/lattice.pdf" 85)]]

#+BEGIN_SRC R
library("lattice")

## use the quakes dataset and make a shingle of the 
## continuous variable magnitude (earthquake magnitude)
## use 'equal.count', rather than 'cut' for this purpose
quakes$Magnitude <- equal.count(quakes$mag, 4)

depth.col    <- grey.colors(n = 100)[cut(quakes$depth, 100, label = F)]

grey.colors(n = 100)[500]

depth.ord    <- rev(order(quakes$depth))
quakes$color <- depth.col
quakes.ordered <- quakes[depth.ord, ]

length(unique(depth.col))

xyplot(lat ~ long | Magnitude,
       data = quakes.ordered, 
       col = "black", aspect = "iso", 
       fill.color = quakes.ordered$color,
       cex = 2,
       panel = function(x, y, fill.color, subscripts, ...) {
           fill <- fill.color[subscripts]
           panel.grid(h = -1, v = 1)
           panel.xyplot(x, y, pch = 21, fill = fill, ...)
},
xlab = "Longitude", ylab = "Latitude")

#+END_SRC

* 13 - Advanced Panel Functions
[[elisp:(mplink "~/foundational_books/lattice.pdf" 238)]]

* My Data
#+BEGIN_SRC R
##### OLD CODE START POINT - 2020.11.25
setwd("~/data/flow/lattice_testing/fcs/")
fl <- read.FCS(filename = "~/data/flow/lattice_testing/fcs/BY_0648_dsRed_TFT_001.fcs",
               min.limit = 1,
               alter.names = T)

fr <- read.FCS(filename = "~/data/flow/lattice_testing/fcs/RM_0649_dsRed_TFT_001.fcs",
               min.limit = 1,
               alter.names = T)


fld           <- as.data.frame(exprs(fl))
frd           <- as.data.frame(exprs(fr))

fld$strain <- rep("BY", nrow(fld))
frd$strain <- rep("RM", nrow(frd))

all <- rbind(fld, frd)
all$strain = as.factor(all$strain)

densityplot(~ eGFP.A, data = all,
            groups = strain)

<<stopping_point>>
fld$log_GFP   <- log10(fld$eGFP.A)
fld$log_RFP   <- log10(fld$DsRed.A)
fld$TFT_ratio <- log2(fld$DsRed.A/fld$eGFP.A)

xyplot(eGFP.A ~ DsRed.A,
       data = fld)

xyplot(log_GFP ~ log_RFP,
       data = fld)

dcols <- colorRampPalette(rev(rainbow(n = 10, s = 0.7, v = 0.7, alpha = 1, end = 4/6)))

xyplot(SSC.A ~ FSC.A,
       data = c,
       pch = ".",
       )

<<stopping_point>>


## no truncation of log10 fluors
fl <- transform(fl,
                `log_GFP`   = log10(`eGFP.A`),
                `log_RFP`   = log10(`DsRed.A`)
                )

densityplot(~ `log_RFP`, data = fl,
            xlim = c(0, 7))

densityplot(exprs(fl$log_RFP),
            ref = T,
            plot.points = "rug")

summary(exprs(fl$log_RFP))
xyplot(`log_RFP` ~ `log_GFP`, data = fl)

fl <- transform(fl,
                `log_GFP`   = trunc.trans(log10(`eGFP.A`)),
                `log_RFP`   = trunc.trans(log10(`DsRed.A`))
                )



summary(exprs(fl$TFT_ratio))
## plot(density(exprs(fl$TFT_ratio)))
densityplot(~ `TFT_ratio`,
            data = fl)
scaleTransform


exprs(fl$TFT_ratio)
xyplot(`log_GFP` ~ `log_RFP`,
       data = fl,
       smooth = F)

log10(5e5)

xyplot(`DsRed.A` ~ `eGFP.A`,
       data = fl,
       smooth = F)

densityplot(log2(`DsRed.A`/`FSC.A`, data = fl), data = fl)

xyplot(`TFT_ratio` ~ `FSC.A`,
       data = fl,
       smooth = F)

densityplot(~ `TFT_ratio`, data = fl)
xyplot(fl@exprs[, 9] ~ fl@exprs[, 1])

unique(is.na(fuck))
fuck <- exprs(fl$TFT_ratio)
densityplot(fuck)
xyplot(1:10000 ~ fuck)
range(fuck)
fuck[is.na(fuck) == T]
#+END_SRC

#+BEGIN_SRC R
## -----
## load all the required packages
source("~/emacs/R/functions/load_flow_packages.R")

#############
## USER INPUT
#############
reporter_names <- c("Gln_TFT", "Asn_TFT", "Glu_TFT", "Asp_TFT",
                    "Ile_TFT", "His_TFT", "Tyr_TFT", "Trp_TFT",
                    "Leu_TFT", "Phe_TFT", "Lys_TFT", "Arg_TFT",
                    "Thr_TFT", "Met_TFT", "Pro_TFT", "Val_TFT",
                    "Gly_TFT", "Ser_TFT", "Ala_TFT", "Cys_TFT")

base_dir       <- "~/data/flow/N-end_all_reporters/"
work_dir       <- paste0(base_dir, "fcs/")
frame_dir      <- paste0(base_dir, "dataframes/")
gated_dir      <- paste0(frame_dir, "gated/")
ungated_dir    <- paste0(frame_dir, "ungated/")
## reporter_name <- "rpn4_TFT"
## reporter_name <- "0662_TFT"
#################
## END USER INPUT
#################


## -----
## we'll loop over all the reporter names to
## [1] read in all the fcs files for a given reporter
## [2] gate each file based on fsc
## [3] write each collection of files to a data table
## [4] add variables for downstream processing (strain/reporter names, e.g.)
for (k in 1:length(reporter_names)) {

## -----
## [x]
## name the strains based on reporter, then set
## regex for getting flowsets of the different strains
## generally, should name fcs files as follows:
## strain    - by, rm, rpn4, rpn10
## reporter  - PSV, TFT, untagged
## replicate - 001, 002, etc... per strain
## e.g., "RM_Arg_TFT_001.fcs"

## 2020.05.09
## this is my current approach to reading in files.  the idea is to
## put all the various strains I've used in the past here and filter this
## complete set to those strains present in the actual data I'm analyzing.  I
## pre-filter using 'grepl' because 'read.flowset' throws an error if any term
## you supply it doesn't match.
no_reporter  <- paste0(".*untagged.*", reporter_names[k], ".*fcs") 
by_strain    <- paste0("BY.*", reporter_names[k], ".*fcs") 
rm_strain    <- paste0("RM.*", reporter_names[k], ".*fcs") 
rpn4_strain  <- paste0("rpn4.*", reporter_names[k], ".*fcs") 
ubr1_strain  <- paste0("ubr1.*", reporter_names[k], ".*fcs") 
doa10_strain <- paste0("doa10.*", reporter_names[k], ".*fcs") 
pop_1_strain <- paste0("SFA.*pop_001.*", reporter_names[k], ".*fcs") 
pop_5_strain <- paste0("SFA.*pop_005.*", reporter_names[k], ".*fcs") 
pop_6_strain <- paste0("SFA.*pop_006.*", reporter_names[k], ".*fcs") 

all_strains <- c(no_reporter, by_strain, rm_strain,
                 rpn4_strain, ubr1_strain, doa10_strain,
                 pop_1_strain, pop_5_strain, pop_6_strain)

## 'dir' lists the contents of a directory - test whether each strain regex
## matches any files in the list produced by 'dir'.  if a match occurs, the
## value returned by 'max' will be 1, else 0.  take only the strains that
## returned a match in the 2nd step below w/ 'all.strains <- ...'
true_strains <- sapply(all_strains, function(strain){
                           as.logical(max(grepl(pattern = strain,
                                                x = dir(path = work_dir,
                                                        pattern = ".*.fcs",
                                                        include.dirs = F,
                                                        ignore.case = T,
                                                        recursive = F,
                                                        no.. = T))))
                       })

all_strains <- as.list(all_strains[true_strains])

all_set     <- lapply(all_strains, function(strain){
                          read.flowSet(files = NULL,
                                       path = work_dir,
                                       pattern = strain,
                                       alter.names = T,
                                       min.limit = 1)
                      })
## str(all_set[[1]]@phenoData@data$name)

name_list <- strsplit(x = names(true_strains)[true_strains == T],
                      split = "\\.\\*")

names(all_set) <- unlist(lapply(X = name_list, FUN = function(x) {
                                    x[1] }))

## -----
## <<Color_Setup>>
## linking colors to strain names in R
## I think I should be able to make something
## akin to an lisp association list where
## there is a strain name and associated color
col_untagged <- c(color = gray(0.7),   name = "no reporter")
col_by       <- c(color = "#7A9BCCFF", name = ".*BY.*")
col_rm       <- c(color = "#CC7AAAFF", name = ".*RM.*")
col_rpn4     <- c(color = "#CCAB7AFF", name = ".*rpn4.*")
col_ubr1     <- c(color = "#88CCBBFF", name = ".*ubr1.*")
col_doa10    <- c(color = "#A3CC7AFF", name = ".*doa10.*")
col_pop_1    <- c(color = gray(0.7),   name = ".*population.*1.*")
col_pop_5    <- c(color = "#AA1111FF", name = ".*population.*5.*")
col_pop_6    <- c(color = gray(0),     name = ".*population.*6.*")

cols_list    <- list(col_untagged, col_by, col_rm, 
                     col_rpn4, col_ubr1, col_doa10,
                     col_pop_1, col_pop_5, col_pop_6)

col_out <- sapply(X = cols_list, FUN = function(x){
                      grepl(pattern = x["name"],
                            x = name_list)
                  })

col_out <- as.logical(unlist(sapply(1:ncol(col_out),
                                    FUN = function(x){
                                        max(col_out[, x])
                                    })))

all_cols <- unlist(sapply(X = cols_list[col_out],
                          FUN = function(x){identity(x["color"])}))

names(all_cols) <- names(all_set)

## output a dummmy plot to assess strain/color mapping
## setwd(results.dir)
## pdf(file = "color_mapping.pdf", height = 7, width = 7, bg = "transparent")
barplot(rep(4, length(name_list)), col = all_cols, ylim = c(0, 7))
box()
legend(x = "topleft", legend = names(all_set),
       lty = 1, lwd = 7.5, col = all_cols,
       bg = "white")
legend(x = "topright", y = NA,
       legend = unlist(lapply(X = cols_list, FUN = function(x){identity(x)["name"]})),
       col = unlist(lapply(X = cols_list, FUN = function(x){identity(x)["color"]})),
       lty = 1, lwd = 7.5,  bg = "white")
## dev.off()


## a function to gate the cells to include only haploids.
## we identify these as a sharp peak in the lower end of
## the fsc density plot.  I take 10% above and below the
## max density value
fsc_gate_generator <- function(fl_frame){
    fsc_dens  <- density(exprs(fl_frame[, 1]))
    ## return the index of the maximum y value of the density estimate
    fsc_max   <- fsc_dens[[1]][which.max(fsc_dens[[2]])]
    fsc_upper <- (fsc_max * 0.10) + fsc_max
    fsc_lower <- fsc_max - (fsc_max * 0.10)
    fsc_gate  <- c(fsc_lower, fsc_upper)
}

fsc_split <- function(x){
    split(x, f = rectangleGate("FSC.A" = fsc_gate_generator(x)),
          population = "defaultRectangleGate+",
          flowSet = T, codeflowSet = T)}

## gate all samples on FSC
fsc_set <- lapply(all_set, fsApply, fsc_split)

## convert gated samples from flowsets to flowframes 
fsc_frame <- lapply(fsc_set, function(set) {
                        lapply(set, set2Frame)
                    })

## pull dataframes from flowframes for gated and
## ungated sets of samples, then rename 
fsc_gate_exprs <- vector(mode = "list", length = length(all_set))
no_gate_exprs  <- fsc_gate_exprs

for(j in 1:length(fsc_frame)) {
    for (i in 1:length(fsc_frame[[j]])) {
        fsc_gate_exprs[[j]][[i]] <- as.data.frame(exprs(fsc_frame[[j]][[i]]))
        fsc_gate_exprs[[j]][[i]]$strain <- as.factor(names(fsc_frame[j]))
        fsc_gate_exprs[[j]][[i]]$replicate <- as.factor(i)
    }
    fsc_gate_exprs[[j]] <- do.call("rbind", fsc_gate_exprs[[j]])
} 

## bind into a single dataframe
fsc_gate_exprs <- do.call("rbind", fsc_gate_exprs)

## add transformation parameters
fsc_gate_exprs$log_GFP   <- log10(fsc_gate_exprs$eGFP.A)
fsc_gate_exprs$log_RFP   <- log10(fsc_gate_exprs$mCherry.A)
fsc_gate_exprs$TFT_ratio <- log2(fsc_gate_exprs$mCherry.A / fsc_gate_exprs$eGFP.A)
fsc_gate_exprs$reporter  <- as.factor(rep(x = gsub(pattern = "_",
                                                  replacement = " ",
                                                  x = reporter_names[k]),
                                         times = nrow(fsc_gate_exprs)))

## nested loops for the ungated data
for (j in 1:length(all_set)){
    for (i in 1:length(all_set[[j]])) {
        no_gate_exprs[[j]][[i]] <- as.data.frame(exprs(all_set[[j]][[i]]))
        no_gate_exprs[[j]][[i]]$strain <- as.factor(names(all_set[j]))
        no_gate_exprs[[j]][[i]]$replicate <- as.factor(i)
    }
    no_gate_exprs[[j]] <- do.call("rbind", no_gate_exprs[[j]])
}

## bind into a single dataframe
no_gate_exprs <- do.call("rbind", no_gate_exprs)

## add transformation parameters and reporter var
no_gate_exprs$log_GFP   <- log10(no_gate_exprs$eGFP.A)
no_gate_exprs$log_RFP   <- log10(no_gate_exprs$mCherry.A)
no_gate_exprs$TFT_ratio <- log2(no_gate_exprs$mCherry.A / no_gate_exprs$eGFP.A)
no_gate_exprs$reporter  <- as.factor(rep(x = gsub(pattern = "_",
                                                  replacement = " ",
                                                  x = reporter_names[k]),
                                         times = nrow(no_gate_exprs)))

## write the ungated data to the appropriate dir
write.table(x = no_gate_exprs,
            file = paste0(ungated_dir,
                          reporter_names[k],
                          "_all_ungated.csv"),
            append = F, sep = ",",
            quote = F, row.names = F)

## write the gated data to the appropriate dir
write.table(x = fsc_gate_exprs,
            file = paste0(gated_dir,
                          reporter_names[k],
                          "_all_gated.csv"),
            append = F, sep = ",",
            quote = F, row.names = F)

    }

## now, read each reporter's dataframe in and
## combine into a single dataframe
## generate a list of files in a directory using
## the 'dir' command, e.g.:
## dir(gated_dir)
## dir(ungated_dir)

## '_u' = ungated
out_u <- vector(mode = "list", length = length(dir(ungated_dir)))
for (o in 1:length(dir(gated_dir))) {
    out_u[[o]] <- read.table(file = paste0(ungated_dir, dir(ungated_dir)[o]),
                             header = T, sep = ",")
       }

## '_g' = gated
out_g <- vector(mode = "list", length = length(dir(gated_dir)))
for (o in 1:length(dir(gated_dir))) {
    out_g[[o]] <- read.table(file = paste0(gated_dir, dir(gated_dir)[o]),
                             header = T, sep = ",")
       }

## for the ungated set, it'll be
## 1e5 cells * 5 strains/reporter * 20 reporters = 1e7 rows
## fsc gating reduces 1e5 to ~2e4, so ~2e6 rows
## nrow(out_all) = 2284942
out_all <- do.call("rbind", out_g)
str(out_all)
levels(out_all$reporter)

## Ac/N-end alphabetized
## ala, cys, gly, met, pro, ser, thr, val
## TODO - which of these is the right order? 
aa_order <- c(2, 3, 4, 6, 7, 9, 10, 11, 12, 14, 18, 19, 1, 5, 8, 13, 15, 16, 17, 20)
## seems the above is the correct order, but keep below just in case...
## aa_order <- c(20, 17, 16, 15, 13, 8, 5, 1, 19, 18, 14, 12, 11, 10, 9, 7, 6, 4, 3, 2)

## get the strain factor in the desired order 
out_all$strain <- factor(out_all$strain,
                         levels = levels(out_all$strain)[c(1, 3, 4, 5, 2)])

strain_paste <- expand.grid(unique(out_all$replicate),
                          levels(out_all$strain))

strain_paste <- paste0(strain_paste$Var2, "_", strain_paste$Var1)

out_all$strain_rep <- factor(paste0(out_all$strain, "_", out_all$replicate),
                             levels = strain_paste)

rep_cols <- unlist(lapply(X = 1:length(all_cols), FUN = function(x) {
                       rep(all_cols[x],
                           times = sum(grepl(pattern = names(all_cols[x]), 
                                             x = levels(out_all$strain_rep))))
                   }))

## need to order levels of 'strain_rep' like 'strain'
out_all$o_reporter <- factor(out_all$reporter,
                             levels = levels(out_all$reporter)[aa_order])


fs <- read.table(file = paste0(gated_dir, dir(gated_dir)), header = T, sep = ",")

## [x] pathway text 
## [x] x label 
## [x] strain names in legend densityplot
## [x] strain names in stripplots 
## [x] strain names in heatmap
## [ ] parameter loop

params <- colnames(out_all)[unlist(lapply(X = out_all, FUN = is.numeric))]
params[10] <- "log2 TFT Ratio"

## <<density_plot_final>>
## have to set up parameters for a custom legend first...
## drop everything for building a custom legend
## into a list.  loop over the list by position
## ('top' or 'bottom') and strain to make 2
## legends in the panels 
top_legend_params <- list()
top_legend_params$names <- c("BY", "RM",
                         expression(paste("BY rpn4", Delta)), 
                         expression(paste("BY ubr1", Delta)), 
                         expression(paste("BY doa10", Delta)))
top_legend_params$line_x1     <- rep(0.8, 5)
top_legend_params$line_x2     <- rep(1.15, 5)    
top_legend_params$x_positions <- rep(x = 1.2, times = 5)
top_legend_params$y_positions <- rev(seq(from = 12.7, to = 13.45, length.out = 5))
top_legend_params$color       <- all_cols
bot_legend_params <- top_legend_params
top_legend_params$y_positions <- rev(seq(from = 4.75, to = 5.5, length.out = 5))
legend_params <- list(top_legend_params, bot_legend_params)

{
pdf(file = "~/Desktop/den_full_test.pdf", height = 14.5, width = 14)
print(

densityplot(~ TFT_ratio | reporter,
            groups = strain_rep,
            data = out_all,
            xlim = c(-7, 1.5),
            ## set alternating = F for one side, same side labeling
            scales = list(alternating = 3),
            grid = T,
            plot.points = F,
            lwd = 2,
            main = list(label = "Arg/N-end Reporters"),
            sub = list(label = "Ac/N-end Reporters"),
            between = list(x = c(0, 0, 0),
                           y = c(0, 0, 3)),
            as.table = T,
            ylab = ",,",
            xlab = gsub(pattern = "_",
                        replacement = " ",
                        params[10]),
            index.cond = list(aa_order),
            par.settings = list(strip.background = list(col = gray(0.9)),
                                clip = list(panel = FALSE),
                                par.main.text = list(font = 2,
                                                     cex = 1.25,
                                                     just = "center", 
                                                     x = grid::unit(7, "in")),
                                par.sub.text = list(font = 2,
                                                    just = "center",
                                                    cex = 1.25,
                                                    x = grid::unit(7.05, "in"),
                                                    y = grid::unit(5.95, "in")),
                                axis.text = list(cex = 1),
                                par.ylab.text = list(cex = 1.25,
                                                     col = "white"),
                                par.xlab.text = list(cex = 1.25)),
            ## legend = list(inside = list(fun = grid.legend,
            ##                             args = list(labels = c("BY", "RM",
            ##                                   expression(paste("BY rpn4", Delta)), 
            ##                                   expression(paste("BY ubr1", Delta)), 
            ##                                   expression(paste("BY doa10", Delta))),
            ##                                   do.lines = T,
            ##                                   nrow = 5,
            ##                                   draw = T,
            ##                                   hgap = 1,
            ##                                   vgap = 0.25,
            ##                                   gp = gpar(col = all_cols,
            ##                                             lwd = 5,
            ##                                             cex = 1,
            ##                                             lineend = "butt",
            ##                                             npc = 50
            ##                                                   )))),
            ## key = list(text = list(c("BY", "RM",
            ##                           expression(paste("BY rpn4", Delta)),
            ##                           expression(paste("BY ubr1", Delta)),
            ##                           expression(paste("BY doa10", Delta)))),
            ##             lines = list(col = all_cols,
            ##                          lwd = 5),
            ##            corner = c(0, 1),
            ##            y = 0.98),
            panel = function(x, y, q, subscripts, ...) {
                panel.grid(h = -1, v = -1)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = out_all$strain_rep,
                                  subscripts = subscripts,
                                  as.table = T,
                                  lty = 1,
                                  col = rep_cols,
                                  lwd = 0.75)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = out_all$strain,
                                  subscripts = subscripts,
                                  as.table = t,
                                  lty = 1,
                                  lwd = 1.5,
                                  col = all_cols,
                                  ylim = c(0, 2))
            })
)
## <<plot_legend>>
## this gets placed outside the 'print' call
## write out a legend using 'grid.text' and 'grid.lines'
## because I separate the 2 N-end pathways, doubling
## the legend makes for a better visual layout.
## turns out there's not a straightforward way to
## double or position legends built using the lattice
## 'key' argument or grid.legend.  the code below works,
## but it's a bit hacky...
for (k in 1:length(legend_params)) {
    for (l in 1:length(legend_params[[1]])) {
        grid.text(label = legend_params[[k]]$names[l],
                  x = legend_params[[k]]$x_positions[l],
                  y = legend_params[[k]]$y_positions[l],
                  default.units = "in",
                  just = "left",
                  gp = gpar(col = "black", cex = 1))
        grid.lines(x = c(legend_params[[k]]$line_x1[l],
                         legend_params[[k]]$line_x2[l]),
                   y = c(legend_params[[k]]$y_positions[l],
                         legend_params[[k]]$y_positions[l]),
                   default.units = "in",
                   gp = gpar(lwd = 4, lineend = "butt",
                             col = legend_params[[k]]$color[l]))
    }
}

## replace improper y label positioning w/ custom text
## and double it since we've split the plot into 2 panels
grid.text(label = "Density",
          x = c(0.15, 0.15),
          y = c(7.5, 2),
          rot = 90,
          default.units = "in",
          gp = gpar(col = "black", cex = 1.25)
          )

dev.off()
}


## <<example_density_plot_trp_met_final>>
## grab a set of reporters that illustrate
## the deletion phenotypes.  for now, we'll
## use Met and Trp TFTs for this purpose.
out_tw <- out_all[out_all$reporter == "Met TFT" | out_all$reporter == "Trp TFT", ]

{
pdf(file = "~/Desktop/example_density_2_panel.pdf", height = 8, width = 5)
print(
densityplot(~ TFT_ratio | reporter,
            groups = strain_rep,
            data = out_tw,
            xlim = c(-8, 1.5),
            ## set alternating = F for one side, same side labeling
            scales = list(alternating = 1,
                          tck = c(1, 0)),
            grid = T,
            plot.points = F,
            lwd = 2,
            as.table = F,
            ylab = ",",
            xlab = "log2 TFT ratio",
            par.settings = list(strip.background = list(col = gray(0.9)),
                                clip = list(panel = FALSE),
                                par.main.text = list(font = 2,
                                                     cex = 1.25,
                                                     just = "center", 
                                                     x = grid::unit(7, "in")),
                                par.sub.text = list(font = 2,
                                                    just = "center",
                                                    cex = 1.25,
                                                    x = grid::unit(7.05, "in"),
                                                    y = grid::unit(5.95, "in")),
                                axis.text = list(cex = 1),
                                par.ylab.text = list(cex = 1.25,
                                                     col = "white"),
                                par.xlab.text = list(cex = 1.25)),
            panel = function(x, y, q, subscripts, ...) {
                panel.grid(h = -1, v = -1)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = out_tw$strain_rep,
                                  subscripts = subscripts,
                                  as.table = T,
                                  lty = 1,
                                  col = rep_cols,
                                  lwd = 0.75)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = out_tw$strain,
                                  subscripts = subscripts,
                                  as.table = t,
                                  lty = 1,
                                  lwd = 1.5,
                                  col = all_cols,
                                  ylim = c(0, 2))
            })
)
## this gets placed outside the 'print' call
## write out a legend using 'grid.text' and 'grid.lines'
## because I separate the 2 N-end pathways, doubling
## the legend makes for a better visual layout.
## turns out there's not a straightforward way to
## double or position legends built using the lattice
## 'key' argument or grid.legend.  the code below works,
## but it's a bit hacky...
## legend parameters
## drop everything for building a custom legend
## into a list.  loop over the list by position
## ('top' or 'bottom') and strain to make 2
## legends in the panels 
ex_top_legend_params <- list()
ex_top_legend_params$names <- c("BY", "RM",
                                expression(paste("BY rpn4", Delta)), 
                                expression(paste("BY ubr1", Delta)), 
                                expression(paste("BY doa10", Delta)))
## starting point of the lines in 'x'
ex_top_legend_params$line_x1     <- rep(0.9, 5)
## endind position of the lines in 'x'
ex_top_legend_params$line_x2     <- rep(1.25, 5)    
## position of the text in x - rep this 5 times for 5 strains
ex_top_legend_params$x_positions <- rep(x = 1.35, times = 5)
## position of the text in x - rep this 5 times for 5 strains
ex_top_legend_params$y_positions <- rev(seq(from = 6.55, to = 7.25, length.out = 5))
ex_top_legend_params$color       <- all_cols
ex_bot_legend_params <- ex_top_legend_params
ex_top_legend_params$y_positions <- rev(seq(from = 3.1, to = 3.85, length.out = 5))
ex_legend_params <- list(ex_top_legend_params, ex_bot_legend_params)
for (k in 1:length(ex_legend_params)) {
    for (l in 1:length(ex_legend_params[[1]])) {
        grid.text(label = ex_legend_params[[k]]$names[l],
                  x = ex_legend_params[[k]]$x_positions[l],
                  y = ex_legend_params[[k]]$y_positions[l],
                  default.units = "in",
                  just = "left",
                  gp = gpar(col = "black", cex = 1))
        grid.lines(x = c(ex_legend_params[[k]]$line_x1[l],
                         ex_legend_params[[k]]$line_x2[l]),
                   y = c(ex_legend_params[[k]]$y_positions[l],
                         ex_legend_params[[k]]$y_positions[l]),
                   default.units = "in",
                   gp = gpar(lwd = 4, lineend = "butt",
                             col = ex_legend_params[[k]]$color[l]))
    }
}
## replace improper y label positioning w/ custom text
## and double it since we've split the plot into 2 panels
grid.text(label = "Density",
          x = c(0.2, 0.2),
          y = c(2.3, 5.7),
          rot = 90,
          gp = gpar(cex = 1.25),
          default.units = "in")
dev.off()
}



## <<strip_plots>>
## these plots are built by extracting the mean/median
## of each biological replicate of each strain.  Thus,
## we reduce 10,000 observations of a replicate to a
## single value.  w/ 8 biological replicates per strain,
## we can make a nice stripplot of strain * reporter
## for the different parameters.  We'll also use this
## to make a levelplot/heatmap

## 'aggregate' creates a new dataframe from x by applying FUN to
## all unique combinations of the factors supplied to the 'by'
## argument - in this case, grab the mean of numeric data and
## keep everything else a factor 
out_agg <- aggregate.data.frame(x = out_all,
                                by = list(out_all$strain,
                                          out_all$reporter,
                                          out_all$replicate),
                            FUN = function(x) {
                                ifelse(is.numeric(x), mean(x), as.factor(x))
                            })

## 'aggregate' seems to strip the levels from factors, so add
## these back using the values present in the original dataframe
out_agg$strain <- factor(out_agg$strain,
                     levels = unique(out_agg$strain),
                     labels = levels(out_all$strain))

out_agg$reporter <- factor(out_agg$reporter,
                     levels = unique(out_agg$reporter),
                     labels = levels(out_all$reporter))

out_agg$strain_rep <- factor(out_agg$strain_rep,
                             levels = unique(out_agg$strain_rep),
                             labels = levels(out_all$strain_rep))

## need a color vector that maps to strains that's the
## length of levels(strain) * levels(replicate) (usually 40)
out_agg_cols <- vector()
for (i in 1:nrow(out_agg)) {
    out_agg_cols[i] <- all_cols[out_agg$strain[i] == names(all_cols)]
}


{
pdf(file = "~/Desktop/strip_full_test.pdf", height = 14.5, width = 14)
print(
stripplot(TFT_ratio ~ strain | reporter,
          data = out_agg,
          col = gray(0),
          fill = out_agg_cols,
          pch = 21,
          cex = 1.1,
          scales = list(alternating = 3,
                        x = list(labels = c("BY", "RM",
                         expression(paste("BY rpn4", Delta)), 
                         expression(paste("BY ubr1", Delta)), 
                         expression(paste("BY doa10", Delta))),
                         rot = 45)),
          layout = c(4, 5),
          grid = T,
          main = list(label = "Arg/N-end Reporters"),
          sub = list(label = "Ac/N-end Reporters"),
          between = list(x = c(0, 0, 0),
                         y = c(0, 0, 3)),
          as.table = T,
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.main.text = list(font = 2,
                                                   cex = 1.25,
                                                   just = "center", 
                                                   x = grid::unit(7, "in"),
                                                   y = grid::unit(13, "in")),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.25,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(6.25, "in")),
                              axis.text = list(cex = 1),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.25)),
          jitter.data = T,
          ## factor for jittering
          factor = 1.5,
          index.cond = list(aa_order),
          horizontal = F)
)

## main title, not sure why this doesn't show up otherwise
## probably some par setting re: going outside the grid....
grid.text(label = "Arg/N-end Reporters",
          x = 7.0,
          y = 14.2,
          default.units = "in",
          gp = gpar(cex = 1.25, font = 2))

## y axis labels for the strip
grid.text(label = "log2 TFT ratio",
          x = c(0.15, 0.15),
          y = c(7.75, 2.25),
          rot = 90,
          default.units = "in",
          gp = gpar(col = "black", cex = 1.25)
          )
dev.off()
}


## let's try to convert to Z scores 
i <- 1

out_z <- list()
reporter <- levels(out_agg$reporter)
for (i in 1:length(reporter)) {
    
    z_mean <- mean(out_agg$TFT_ratio[out_agg$reporter == reporter[i]])
    z_sd   <- sd(out_agg$TFT_ratio[out_agg$reporter == reporter[i]])
    z_out  <- function(x) { ((x - z_mean) / (z_sd))  }
    out_subset <- out_agg[out_agg$reporter == reporter[i], ]
    
    for (j in 1:nrow(out_subset)) {
        out_subset$zTFT[j] <- z_out(out_subset$TFT_ratio[j])
        out_z[[i]] <- out_subset
}}

out_z <- do.call("rbind", out_z)
range(out_z$zTFT)

out_z$r_order <- factor(out_z$reporter,
                        levels = levels(out_z$reporter)[rev(aa_order)])

## works, but we don't use this....
levelplot(zTFT ~ strain * r_order,
          strip = T,
          xlab = "Strain",
          ylab = "Reporter",
          data = out_z,
          pretty = T,
          scales = list(alternating = F,
                        x = list(labels = c("BY", "RM",
                                            expression(paste("BY rpn4", Delta)), 
                                            expression(paste("BY ubr1", Delta)), 
                                            expression(paste("BY doa10", Delta))),
                                 rot = 45)),
          col.regions = gray(level = 29:0/29),
          at = seq(from = -2, to = 2.1, length.out = 30),
          colorkey = list(at = seq(from = -2, to = 2.1, length.out = 30)),
          border = gray(0.3),
          as.table = T,
          ## index.cond = list(aa_order),
          border.lwd = 2)



## aggregate into a smaller data frame for the actual heatmap
out_m <- aggregate.data.frame(x = out_z,
                               by = list(out_z$strain,
                                         out_z$reporter),
                               FUN = function(x) {
                                   ifelse(is.numeric(x), mean(x), as.factor(x))
                               })

out_m$strain <- factor(out_m$strain,
                        levels = unique(out_m$strain),
                        labels = levels(out_all$strain))

out_m$reporter <- factor(out_m$reporter,
                          levels = unique(out_m$reporter),
                          labels = levels(out_all$reporter))


range(out_m$zTFT)

out_m$r_order <- factor(out_m$reporter,
                        levels = levels(out_m$reporter)[rev(aa_order)])



{
pdf(file = "~/Desktop/heat_test.pdf", height = 14, width = 6)
print(
levelplot(zTFT ~ strain * r_order,
          strip = T,
          xlab = "normalized TFT score",
          ylab = "Reporter",
          data = out_m,
          pretty = T,
          ylab.right = "Z score",
          scales = list(alternating = F,
                        x = list(labels = c("BY", "RM",
                                            expression(paste("BY rpn4", Delta)), 
                                            expression(paste("BY ubr1", Delta)), 
                                            expression(paste("BY doa10", Delta))),
                                 rot = 45),
                        ## scales only on left/bottom
                        tck = c(1, 0)),
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.25,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(6.25, "in")),
                              layout.heights=list(xlab.key.padding = 1),
                              axis.text = list(cex = 1.25),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.25),
                              list(layout.widths = list(axis.key.padding = 0, 
                                                        ylab.right = 2))), 
##          col.regions = gray(level = 29:0/29),
          at = seq(from = -2, to = 2, length.out = 30),
          colorkey = list(at = seq(from = -2, to = 2, length.out = 30),
                          cex = 1.25,
                          title = "normalized TFT score",
                          space = "bottom",
                          columns = 1,
                          row = 10),
          border = gray(0.3),
          as.table = T,
          ## index.cond = list(aa_order),
          border.lwd = 2)
)
## Ac/N-end reporter lines
grid.lines(x = c(0.32, 0.32),
           y = c(2.4, 6.42),
           default.units = "in",
           gp = gpar(lwd = 2, col = gray(0)))
## Ac/N-end reporter text
grid.text(x = 0.15, y = 4.41,
          label = "Ac/N-end Reporters",
          default.units = "in",
          rot = 90,
          gp = gpar(cex = 1.25))
## Arg/N-end reporter lines
grid.lines(x = c(0.32, 0.32),
           y = c(6.95, 13.25),
           default.units = "in",
           gp = gpar(lwd = 2, col = gray(0)))
## Arg/N-end reporter text
grid.text(x = 0.15, y = 10.1,
          label = "Arg/N-end Reporters",
          default.units = "in",
          rot = 90,
          gp = gpar(cex = 1.25))
dev.off()
}


## <<Z_score_stripplot_final>>
{
pdf(file = "~/Desktop/z_strip_full_test.pdf", height = 14.5, width = 14)
print(
stripplot(zTFT ~ strain | reporter,
          data = out_z,
          col = gray(0),
          fill = out_agg_cols,
          pch = 21,
          cex = 1.1,
          scales = list(alternating = 3,
                        x = list(labels = c("BY", "RM",
                         expression(paste("BY rpn4", Delta)), 
                         expression(paste("BY ubr1", Delta)), 
                         expression(paste("BY doa10", Delta))),
                         rot = 45)),
          layout = c(4, 5),
          grid = T,
          main = list(label = "Arg/N-end Reporters"),
          sub = list(label = "Ac/N-end Reporters"),
          between = list(x = c(0, 0, 0),
                         y = c(0, 0, 3)),
          as.table = T,
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.main.text = list(font = 2,
                                                   cex = 1.25,
                                                   just = "center", 
                                                   x = grid::unit(7, "in"),
                                                   y = grid::unit(13, "in")),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.25,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(6.25, "in")),
                              axis.text = list(cex = 1),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.25)),
          jitter.data = T,
          ## factor for jittering
          factor = 1.5,
          index.cond = list(aa_order),
          horizontal = F)
)
## main title, not sure why this doesn't show up otherwise
## probably some par setting re: going outside the grid....
grid.text(label = "Arg/N-end Reporters",
          x = 7.0,
          y = 14.2,
          default.units = "in",
          gp = gpar(cex = 1.25, font = 2))
## y axis labels for the strip
grid.text(label = "normalized TFT score",
          x = c(0.15, 0.15),
          y = c(10.17, 3.9),
          rot = 90,
          default.units = "in",
          gp = gpar(col = "black", cex = 1.25)
          )
dev.off()
}

## <<example_stripplots_final>>
## use met and trp for this purpose
## these will go into figure 1, but
## are just for illustration purposes...
out_x <- out_z[out_z$reporter == "Met TFT" | out_z$reporter == "Trp TFT", ]

{
pdf(file = "~/Desktop/example_strip_2_panel.pdf", height = 8, width = 5)
print(
stripplot(zTFT ~ strain | reporter,
          data = out_x,
          col = gray(0),
          fill = out_agg_cols,
          pch = 21,
          cex = 1.25,
          scales = list(alternating = 1,
                        tck = c(1, 0),
                        x = list(labels = c("BY", "RM",
                         expression(paste("BY rpn4", Delta)), 
                         expression(paste("BY ubr1", Delta)), 
                         expression(paste("BY doa10", Delta))),
                         rot = 45)),
          layout = c(1, 2),
          grid = T,
          as.table = F,
          jitter = T,
          factor = 1.7,
          ylab = "Z-score",
          xlab = "Strain",
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.main.text = list(font = 2,
                                                   cex = 1.25,
                                                   just = "center", 
                                                   x = grid::unit(7, "in"),
                                                   y = grid::unit(13, "in")),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.25,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(6.25, "in")),
                              axis.text = list(cex = 1.25),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.25)),
          horizontal = F)
)
grid.text(label = "normalized TFT score",
          x = c(0.2, 0.2),
          y = c(2.75, 5.85),
          rot = 90,
          gp = gpar(cex = 1.25),
          default.units = "in")
dev.off()
}

## no longer using this, as the TFT score colorkey
## goes on the bottom, but might want to come back to this later...
## TFT_hm$legend$right <- 
##     list(fun = mergedTrellisLegendGrob(TFT_hm$legend$right, 
##                                        list(fun = textGrob, 
##                                             args = list("Z score", 
##                                                         rot = 90,
##                                                         gp = gpar(cex = 1.25))), 
##                                        vertical = FALSE))

## <<BY_RM_plot>>
## nrow(out_agg) = 800, so 300 should be BY or RM 
out_by_rm <- grepl(pattern = "[BR][YM]",
                   x = as.character(out_agg$strain))

out_br <- out_agg[out_by_rm, ]

out_br_cols <- vector

for (i in 1:nrow(out_br)) {
out_br_cols[i] <- all_cols[out_br$strain[i] == names(all_cols)]
}

{
pdf(file = "~/Desktop/by_rm_test.pdf", height = 14.5, width = 14)
print(
## need to make a TFT ratio amino acid index 
stripplot(TFT_ratio ~ strain | reporter,
          data = out_br,
          type = c("g", "p"),
          col = gray(0),
          fill = out_br_cols,
          pch = 21,
          cex = 1.1,
          scales = list(alternating = 3,
                        x = list(labels = c("BY", "RM"))),
          layout = c(4, 5),
          grid = T,
          main = list(label = "Arg/N-end Reporters"),
          sub = list(label = "Ac/N-end Reporters"),
          between = list(x = c(0, 0, 0),
                         y = c(0, 0, 3)),
          as.table = T,
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.main.text = list(font = 2,
                                                   cex = 1.25,
                                                   just = "center", 
                                                   x = grid::unit(7, "in"),
                                                   y = grid::unit(13, "in")),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.25,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(5.95, "in")),
                              axis.text = list(cex = 1),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.25)),
          jitter.data = T,
          ## factor for jittering
          factor = 1.5,
          index.cond = list(aa_order),
          horizontal = F)
)
## main title, not sure why this doesn't show up otherwise
## probably some par setting re: going outside the grid....
grid.text(label = "Arg/N-end Reporters",
          x = 7.0,
          y = 14.2,
          default.units = "in",
          gp = gpar(cex = 1.25, font = 2))

## y axis labels for the strip
grid.text(label = "log2 TFT ratio",
          x = c(0.15, 0.15),
          y = c(7.45, 1.85),
          rot = 90,
          default.units = "in",
          gp = gpar(col = "black", cex = 1.25))
dev.off() 
}


## TODO 
## - [1] add reporter variable and transforms (GFP, RFP, TFT)
## - [2] extract replicate mean/media parameters
##       + possibly as separate frames, though maybe not necessary
reporter_var <- as.factor(gsub(pattern = "_",
                               replacement = " ",
                               x = reporter_name))


## working plots
## 5 plots by strain, split by replciates
densityplot(~ TFT_ratio | strain,
            data = fsc_gate_exprs,
            groups = replicate,
            layout = c(5, 1),
            plot.points = F,
            auto.key = list(space = "right"))

## single plot split by strain
densityplot(~ TFT_ratio,
            groups = strain,
            data = fsc_gate_exprs,
            plot.points = F,
            auto.key = list(space = "right"))

## strain by replicate heat map (but cols scaled wrong)
levelplot(TFT_ratio ~ strain * replicate,
          data = fsc_gate_exprs,
          border = gray(0.9),
          border.lwd = 4,
          scales = list(x=list(rot=45)),
          aspect = "iso") 

## single row heatmap
levelplot(TFT_ratio ~ strain * sample_id,
          data = fsc_gate_exprs,
          border = gray(0.9),
          border.lwd = 4,
          scales = list(x=list(rot=45)),
          aspect = "iso")

## recall that you can summarize trellis objects 
## and view high-level information about them:
t_obj <- densityplot(~ TFT_ratio | strain,
            data = fsc_gate_exprs,
            groups = replicate,
            layout = c(5, 1),
            plot.points = F,
            auto.key = list(space = "right"))
summary(t_obj)
## and plot
print(t_obj)

## 2D plot allow conditioning via x ~ y formulas
## these nicely show no relationship betw. FSC and TFT ratio
xyplot(TFT_ratio ~ FSC.A | strain,
       data = fsc_gate_exprs)
xyplot(TFT_ratio ~ FSC.A | strain,
       data = no_gate_exprs)

## no strong relationship betw. GFP and TFT ratio either 
xyplot(TFT_ratio ~ log_GFP | strain,
       data = fsc_gate_exprs)

## TFT ratio directly related to RFP
xyplot(TFT_ratio ~ log_RFP | strain,
       data = fsc_gate_exprs)
## not as much GFP
xyplot(log_RFP ~ log_GFP | strain,
       data = fsc_gate_exprs)

## this plot nicely shows that relative
## differences between strains don't
## change at various levels of FSC/SSC
a <- equal.count(no_gate_exprs$FSC.A)
plot(a)
b <- equal.count(no_gate_exprs$SSC.A)
plot(b)
f_shingle <- equal.count(no_gate_exprs$FSC.A)
densityplot(~ TFT_ratio | b,
            groups = strain,
            data = no_gate_exprs,
            plot.points = F,
            auto.key = list(col = 1))

## same plot w/ a custom shingle 
c_shingle <- equal.count(no_gate_exprs$FSC.A, number = 5, overlap = 0.1)
densityplot(~ TFT_ratio | c_shingle,
            groups = strain,
            data = no_gate_exprs,
            plot.points = F,
            auto.key = list(col = 1)) 


## nice cross-contingency table of n. cells
## per strain per replicate
xtabs(~strain + replicate,
      data = fsc_gate_exprs)

write.table(x = fsc_gate_exprs,
            file = paste0("~/Desktop/fsc_gated_", reporter_name, ".csv"),
            append = F, quote = F, sep = ",",
            row.names = F, col.names = T)


## basic example of reading in 
a <- read.table("~/Desktop/fsc_gated_rpn4_TFT.csv",
                header = T, sep = ",")
a$reporter <- as.factor(rep("Rpn4 TFT", nrow(a)))

b <- read.table("~/Desktop/fsc_gated_0662_TFT.csv",
                header = T, sep = ",")
b$reporter <- as.factor(rep("Tyr TFT", nrow(b)))

c <- rbind(a, b)

## basic levelplot conditioned on strain and reporter
levelplot(TFT_ratio ~ strain * reporter,
          data = c)


my.at=c(min(values(r)), 0,1,5,10,15,20,25,30,40,50,75,100,150,200, max(values(r)))
my.brks=seq(0, 200, by=13)

TFT_cols   <- diverging_hcl(n = 11, h = c(90, 180), c = 70, l = 90)
TFT_breaks <- seq(from = -4, to = 1, by = 0.5)
TFT_labels <- TFT_breaks

TFT_key <- list(at = TFT_breaks,
                labels = list(at = TFT_labels,
                              labels = TFT_labels),
                space = "right")

out <- levelplot(TFT_ratio ~ strain * reporter,
                 data = c,
                 colorkey = TFT_key,
                 col.regions = TFT_cols,
                 at = TFT_breaks)
print(out)


## basic density plot that compares groups w/in a 
## plot and splits reporter into separate plots
## line cols, x axis limits, and line width custom set
densityplot(~ TFT_ratio | reporter,
            groups = strain,
            data = c,
            plot.points = F,
            auto.key = list(space = "top"),
            par.settings = list(superpose.line = list(col = all_cols)),
            scales = list(alternating = F),
            lwd = 2.5,
            xlim = c(-4, 1))

str(make.groups(c$replicate, c$strain))
combn(x = letters[1:4], 2)

b$strain_rep <- as.factor(paste0(b[, "strain"], "_", b[, "replicate"]))
sr_cols <- list()
for (i in 1:length(all_cols)) {
    sr_cols[[i]] <- rep(all_cols[i], 8)
}
sr_cols <- unlist(sr_cols)

densityplot(replicate ~ TFT_ratio | reporter,
            groups = strain_rep,
            data = c,
            plot.points = F,
            auto.key = F,
            par.settings = list(superpose.line = list(col = sr_cols)),
            scales = list(alternating = F),
            lwd = 1,
            xlim = c(-4, 1))

densityplot(~ TFT_ratio | reporter,
            data = c,
            plot.points = F,
            auto.key = F,
            panel = function(x, ...){
                panel.densityplot(x = x,
                                  plot.points = F)
            },
            scales = list(alternating = F),
            lwd = 1,
            xlim = c(-4, 1))


## implement xy scatter plots
## https://rstudio-pubs-static.s3.amazonaws.com/12556_4e02f5564dc24b57b7a8f6d95d2a5cf7.html
## xyplot(y ~ z, asp = 1, panel = panel.smoothScatter, nbin = 150)
xyplot(log_RFP ~ log_GFP | reporter * strain,
       data = c,
       panel = panel.smoothScatter,
       nbin = 140,
       xlim = c(2.5, 5))

xyplot(log_RFP ~ log_GFP | reporter,
       groups = strain,
       data = c,
       pch = ".",
       cex = 2,
       nbin = 140,
       xlim = c(2.5, 5))


c$strain[1] == names(all_cols[])

c$strain_rep <- as.factor(paste0(c$strain, "_", c$replicate))



densityplot(~ TFT_ratio | reporter,
            groups = strain_rep,
            data = c,
            plot.points = F,
            xlim = c(-4, 1))


densityplot(~ TFT_ratio | reporter,
            groups = strain,
            data = c,
            xlim = c(-4, 1),
            scales = list(alternating = F),
            grid = T,
            plot.points = F,
            lwd = 2,
            col = all_cols,
            par.settings = list(strip.background = list(col = gray(0.9))),
            key = list(text = list(names(all_cols)),
                       rectangles = list(col = all_cols)))


ord <- order(c$strain)
kk <- c[ord, ]
cc <- order(names(all_cols))
all_cols <- all_cols[cc]



## 2020.11.30 - needs to incorporate the ordering above
## plus figure out a way to code the replicate colors -
## basically needs to be a repetition of each color n replciate times
## demo of using logical subsetting
## ddd$strain[1] == names(all_cols)
## regexp filter on unique(c$strain_rep)?
pdf(file = "~/Desktop/density_test.pdf", height = 5, width = 10)
print(
densityplot(~ TFT_ratio | reporter,
            groups = strain_rep,
            data = c,
            xlim = c(-4, 1.25),
            scales = list(alternating = F),
            grid = T,
            plot.points = F,
            lwd = 2,
            col = all_cols,
            par.settings = list(strip.background = list(col = gray(0.9))),
            key = list(text = list(names(all_cols[c(1, 3, 4, 5, 2)])),
                       rectangles = list(col = all_cols[c(1, 3, 4, 5, 2)])),
            panel = function(x, y, q, subscripts, ...) {
                xx <- rep(all_cols, each = 8)
                panel.grid(h = -1, v = -1)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = c$strain_rep,
                                  subscripts = subscripts,
                                  lty = 1,
                                  col = xx,
                                  lwd = 1)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = c$strain,
                                  subscripts = subscripts,
                                  lty = 1,
                                  lwd = 4,
                                  col = all_cols,
                                  ylim = c(0, 2))
            })
)
dev.off()

levelplot(TFT_ratio ~ reporter * strain,
          strip = T,
          data = c,
          pretty = T,
          border = gray(0.7),
          border.lwd = 2)
          


## basic working TFT_ratio ~ strain plot
## this shows all values, so not
## esp. useful 
stripplot(TFT_ratio ~ strain | reporter,
          data = c,
          jitter = T)

stripplot(TFT_ratio ~ strain | reporter,
          groups = strain_rep,
          data = c,
          panel = function(x, y, q, subscripts, ...) {
              panel.points( )
              panel.stripplot(x, y,
                              subscripts = subscripts,
                              groups = c$strain,
                              jitter.data = T,
                              horizontal = F,
                              factor = 2.5)
              })

ccc <- aggregate(x = c, by = list(c$strain_rep), FUN = function(x) {
          ifelse(is.numeric(x), mean(x), as.factor(x))
          })

## 'aggregate' creates a new dataframe from x by applying FUN to
## all unique combinations of the factors supplied to the 'by'
## argument - in this case, grab the mean of numeric data and
## keep everything else a factor 
ddd <- aggregate.data.frame(x = c,
                            by = list(c$strain, c$reporter, c$replicate),
                            FUN = function(x) {
                                ifelse(is.numeric(x), mean(x), as.factor(x))
                            })

## 'aggregate' seems to strip the levels from factors, so add
## these back using the values present in the original dataframe
ddd$strain <- factor(ddd$strain,
                     levels = unique(ddd$strain),
                     labels = levels(c$strain))

ddd$reporter <- factor(ddd$reporter,
                     levels = unique(ddd$reporter),
                     labels = levels(c$reporter))

## need a color vector that maps to strains that's the
## length of levels(strain) * levels(replicate) (usually 40)
ddd_cols <- vector()
for (i in 1:nrow(ddd)) {
    ddd_cols[i] <- all_cols[ddd$strain[i] == names(all_cols)]
}

## now, re-order strain to present levels in the order
## I'd like (BY, RM, rpn4, ubr1, doa10) instead of the
## default alphabetical order
ddd$out_fac <- factor(ddd$strain, levels = levels(ddd$strain)[c(1, 3, 4, 5, 2)])

pdf(file = "~/Desktop/strip_test.pdf", height = 6, width = 10)
print(
stripplot(TFT_ratio ~ out_fac | reporter,
          data = ddd,
          col = gray(0),
          fill = ddd_cols,
          pch = 21,
          cex = 1.1,
          
          scales = list(alternating = F),
          layout = c(2, 1),
          grid = T,
          par.settings = list(strip.background = list(col = gray(0.9))),
          jitter.data = T,
          ## factor for jittering
          factor = 1.25,
          horizontal = F)
)
dev.off()
expression(paste("rpn4", Delta))

rr <- colorRampPalette(c(gray(0.4), "white", "#882255"))
rr <- colorRampPalette(c("white", "#C92AA4"))
rr <- colorRampPalette(c("white", "black"))
## needs x axis label

pdf(file = "~/Desktop/heat_test.pdf", height = 4, width = 9)
print(
levelplot(TFT_ratio ~ out_fac * reporter,
          strip = T,
          xlab = "Strain",
          ylab = "Reporter",
          data = ddd,
          pretty = T,
          ## col.regions = gray(100:0/100)),
          col.regions = rr(20),
          border = gray(0.3),
          border.lwd = 2)
)
dev.off()


## adds a grid via 'type = c("g")'
xyplot(log_GFP ~ log_RFP,
       data = c,
       panel = function(x, y, ...) {
           panel.fill(col = gray(1))
           panel.grid(h = -1, v = -1,
                      col.line = gray(0.9), lwd = 1.5)
           panel.xyplot(x, y,
                        type = "p",
                        pch = ".",
                        cex = 2,
                        col.symbol = rgb(0, 0, 0, 0.01)
                      )
}
)


## you can 'rbind' the dataframes together 
## a <- data.frame(a = 1:5, b = 11:15)
## b <- data.frame(a = 6:10, b = 16:20)
## c <- rbind(a, b) ## works

#+END_SRC

# need to figure out how to plot delta symbols
# https://stats.idre.ucla.edu/r/codefragments/greek_letters/
#+BEGIN_SRC R :results graphics :file /tmp/delta.pdf
barplot(c(4,4,4), ylab = expression(paste("BY rpn4", Delta)))
#+END_SRC

#+RESULTS:
[[file:/tmp/delta.pdf]]

* TFT Ratio Heatmap
#+BEGIN_SRC R :tangle ~/Desktop/N-end_TFT_heatmap.R
## -----
## load all the required packages
source("~/emacs/R/functions/load_flow_packages.R")

#############
## USER INPUT
#############
reporter_names <- c("Gln_TFT", "Asn_TFT", "Glu_TFT", "Asp_TFT",
                    "Ile_TFT", "His_TFT", "Tyr_TFT", "Trp_TFT",
                    "Leu_TFT", "Phe_TFT", "Lys_TFT", "Arg_TFT",
                    "Thr_TFT", "Met_TFT", "Pro_TFT", "Val_TFT",
                    "Gly_TFT", "Ser_TFT", "Ala_TFT", "Cys_TFT")
base_dir       <- "~/data/flow/N-end_all_reporters/"
work_dir       <- paste0(base_dir, "fcs/")
frame_dir      <- paste0(base_dir, "dataframes/")
gated_dir      <- paste0(frame_dir, "gated/")
ungated_dir    <- paste0(frame_dir, "ungated/")
## reporter_name <- "rpn4_TFT"
## reporter_name <- "0662_TFT"
#################
## END USER INPUT
#################

#############
## USER INPUT
#############
reporter_names <- c("Gln_TFT", "Asn_TFT", "Glu_TFT", "Asp_TFT",
                    "Ile_TFT", "His_TFT", "Tyr_TFT", "Trp_TFT",
                    "Leu_TFT", "Phe_TFT", "Lys_TFT", "Arg_TFT",
                    "Thr_TFT", "Met_TFT", "Pro_TFT", "Val_TFT",
                    "Gly_TFT", "Ser_TFT", "Ala_TFT", "Cys_TFT")
base_dir       <- "~/data/flow/N-end_all_reporters/"
work_dir       <- paste0(base_dir, "fcs/")
frame_dir      <- paste0(base_dir, "dataframes/")
gated_dir      <- paste0(frame_dir, "gated/")
ungated_dir    <- paste0(frame_dir, "ungated/")
## reporter_name <- "rpn4_TFT"
## reporter_name <- "0662_TFT"
#################
## END USER INPUT
#################


## -----
## we'll loop over all the reporter names to
## [1] read in all the fcs files for a given reporter
## [2] gate each file based on fsc
## [3] write each collection of files to a data table
## [4] add variables for downstream processing (strain/reporter names, e.g.)
for (k in 1:length(reporter_names)) {

## -----
## [x]
## name the strains based on reporter, then set
## regex for getting flowsets of the different strains
## generally, should name fcs files as follows:
## strain    - by, rm, rpn4, rpn10
## reporter  - PSV, TFT, untagged
## replicate - 001, 002, etc... per strain
## e.g., "RM_Arg_TFT_001.fcs"

## 2020.05.09
## this is my current approach to reading in files.  the idea is to
## put all the various strains I've used in the past here and filter this
## complete set to those strains present in the actual data I'm analyzing.  I
## pre-filter using 'grepl' because 'read.flowset' throws an error if any term
## you supply it doesn't match.
no_reporter  <- paste0(".*untagged.*", reporter_names[k], ".*fcs") 
by_strain    <- paste0("BY.*", reporter_names[k], ".*fcs") 
rm_strain    <- paste0("RM.*", reporter_names[k], ".*fcs") 
rpn4_strain  <- paste0("rpn4.*", reporter_names[k], ".*fcs") 
ubr1_strain  <- paste0("ubr1.*", reporter_names[k], ".*fcs") 
doa10_strain <- paste0("doa10.*", reporter_names[k], ".*fcs") 
pop_1_strain <- paste0("SFA.*pop_001.*", reporter_names[k], ".*fcs") 
pop_5_strain <- paste0("SFA.*pop_005.*", reporter_names[k], ".*fcs") 
pop_6_strain <- paste0("SFA.*pop_006.*", reporter_names[k], ".*fcs") 

all_strains <- c(no_reporter, by_strain, rm_strain,
                 rpn4_strain, ubr1_strain, doa10_strain,
                 pop_1_strain, pop_5_strain, pop_6_strain)

## 'dir' lists the contents of a directory - test whether each strain regex
## matches any files in the list produced by 'dir'.  if a match occurs, the
## value returned by 'max' will be 1, else 0.  take only the strains that
## returned a match in the 2nd step below w/ 'all.strains <- ...'
true_strains <- sapply(all_strains, function(strain){
                           as.logical(max(grepl(pattern = strain,
                                                x = dir(path = work_dir,
                                                        pattern = ".*.fcs",
                                                        include.dirs = F,
                                                        ignore.case = T,
                                                        recursive = F,
                                                        no.. = T))))
                       })

all_strains <- as.list(all_strains[true_strains])

all_set     <- lapply(all_strains, function(strain){
                          read.flowSet(files = NULL,
                                       path = work_dir,
                                       pattern = strain,
                                       alter.names = T,
                                       min.limit = 1)
                      })
## str(all_set[[1]]@phenoData@data$name)

name_list <- strsplit(x = names(true_strains)[true_strains == T],
                      split = "\\.\\*")

names(all_set) <- unlist(lapply(X = name_list, FUN = function(x) {
                                    x[1] }))

## -----
## <<Color_Setup>>
## linking colors to strain names in R
## I think I should be able to make something
## akin to an lisp association list where
## there is a strain name and associated color
col_untagged <- c(color = gray(0.7),   name = "no reporter")
col_by       <- c(color = "#7A9BCCFF", name = ".*BY.*")
col_rm       <- c(color = "#CC7AAAFF", name = ".*RM.*")
col_rpn4     <- c(color = "#CCAB7AFF", name = ".*rpn4.*")
col_ubr1     <- c(color = "#88CCBBFF", name = ".*ubr1.*")
col_doa10    <- c(color = "#A3CC7AFF", name = ".*doa10.*")
col_pop_1    <- c(color = gray(0.7),   name = ".*population.*1.*")
col_pop_5    <- c(color = "#AA1111FF", name = ".*population.*5.*")
col_pop_6    <- c(color = gray(0),     name = ".*population.*6.*")

cols_list    <- list(col_untagged, col_by, col_rm, 
                     col_rpn4, col_ubr1, col_doa10,
                     col_pop_1, col_pop_5, col_pop_6)

col_out <- sapply(X = cols_list, FUN = function(x){
                      grepl(pattern = x["name"],
                            x = name_list)
                  })

col_out <- as.logical(unlist(sapply(1:ncol(col_out),
                                    FUN = function(x){
                                        max(col_out[, x])
                                    })))

all_cols <- unlist(sapply(X = cols_list[col_out],
                          FUN = function(x){identity(x["color"])}))

names(all_cols) <- names(all_set)

## output a dummmy plot to assess strain/color mapping
## setwd(results.dir)
## pdf(file = "color_mapping.pdf", height = 7, width = 7, bg = "transparent")
barplot(rep(4, length(name_list)), col = all_cols, ylim = c(0, 7))
box()
legend(x = "topleft", legend = names(all_set),
       lty = 1, lwd = 7.5, col = all_cols,
       bg = "white")
legend(x = "topright", y = NA,
       legend = unlist(lapply(X = cols_list, FUN = function(x){identity(x)["name"]})),
       col = unlist(lapply(X = cols_list, FUN = function(x){identity(x)["color"]})),
       lty = 1, lwd = 7.5,  bg = "white")
## dev.off()


## a function to gate the cells to include only haploids.
## we identify these as a sharp peak in the lower end of
## the fsc density plot.  I take 10% above and below the
## max density value
fsc_gate_generator <- function(fl_frame){
    fsc_dens  <- density(exprs(fl_frame[, 1]))
    ## return the index of the maximum y value of the density estimate
    fsc_max   <- fsc_dens[[1]][which.max(fsc_dens[[2]])]
    fsc_upper <- (fsc_max * 0.10) + fsc_max
    fsc_lower <- fsc_max - (fsc_max * 0.10)
    fsc_gate  <- c(fsc_lower, fsc_upper)
}

fsc_split <- function(x){
    split(x, f = rectangleGate("FSC.A" = fsc_gate_generator(x)),
          population = "defaultRectangleGate+",
          flowSet = T, codeflowSet = T)}

## gate all samples on FSC
fsc_set <- lapply(all_set, fsApply, fsc_split)

## convert gated samples from flowsets to flowframes 
fsc_frame <- lapply(fsc_set, function(set) {
                        lapply(set, set2Frame)
                    })

## pull dataframes from flowframes for gated and
## ungated sets of samples, then rename 
fsc_gate_exprs <- vector(mode = "list", length = length(all_set))
no_gate_exprs  <- fsc_gate_exprs

for(j in 1:length(fsc_frame)) {
    for (i in 1:length(fsc_frame[[j]])) {
        fsc_gate_exprs[[j]][[i]] <- as.data.frame(exprs(fsc_frame[[j]][[i]]))
        fsc_gate_exprs[[j]][[i]]$strain <- as.factor(names(fsc_frame[j]))
        fsc_gate_exprs[[j]][[i]]$replicate <- as.factor(i)
    }
    fsc_gate_exprs[[j]] <- do.call("rbind", fsc_gate_exprs[[j]])
} 

## bind into a single dataframe
fsc_gate_exprs <- do.call("rbind", fsc_gate_exprs)

## add transformation parameters
fsc_gate_exprs$log_GFP   <- log10(fsc_gate_exprs$eGFP.A)
fsc_gate_exprs$log_RFP   <- log10(fsc_gate_exprs$mCherry.A)
fsc_gate_exprs$TFT_ratio <- log2(fsc_gate_exprs$mCherry.A / fsc_gate_exprs$eGFP.A)
fsc_gate_exprs$reporter  <- as.factor(rep(x = gsub(pattern = "_",
                                                  replacement = " ",
                                                  x = reporter_names[k]),
                                         times = nrow(fsc_gate_exprs)))

## nested loops for the ungated data
for (j in 1:length(all_set)){
    for (i in 1:length(all_set[[j]])) {
        no_gate_exprs[[j]][[i]] <- as.data.frame(exprs(all_set[[j]][[i]]))
        no_gate_exprs[[j]][[i]]$strain <- as.factor(names(all_set[j]))
        no_gate_exprs[[j]][[i]]$replicate <- as.factor(i)
    }
    no_gate_exprs[[j]] <- do.call("rbind", no_gate_exprs[[j]])
}

## bind into a single dataframe
no_gate_exprs <- do.call("rbind", no_gate_exprs)

## add transformation parameters and reporter var
no_gate_exprs$log_GFP   <- log10(no_gate_exprs$eGFP.A)
no_gate_exprs$log_RFP   <- log10(no_gate_exprs$mCherry.A)
no_gate_exprs$TFT_ratio <- log2(no_gate_exprs$mCherry.A / no_gate_exprs$eGFP.A)
no_gate_exprs$reporter  <- as.factor(rep(x = gsub(pattern = "_",
                                                  replacement = " ",
                                                  x = reporter_names[k]),
                                         times = nrow(no_gate_exprs)))

## write the ungated data to the appropriate dir
write.table(x = no_gate_exprs,
            file = paste0(ungated_dir,
                          reporter_names[k],
                          "_all_ungated.csv"),
            append = F, sep = ",",
            quote = F, row.names = F)

## write the gated data to the appropriate dir
write.table(x = fsc_gate_exprs,
            file = paste0(gated_dir,
                          reporter_names[k],
                          "_all_gated.csv"),
            append = F, sep = ",",
            quote = F, row.names = F)

    }

## now, read each reporter's dataframe in and
## combine into a single dataframe
## generate a list of files in a directory using
## the 'dir' command, e.g.:
## dir(gated_dir)
## dir(ungated_dir)

## '_u' = ungated
out_u <- vector(mode = "list", length = length(dir(ungated_dir)))
for (o in 1:length(dir(gated_dir))) {
    out_u[[o]] <- read.table(file = paste0(ungated_dir, dir(ungated_dir)[o]),
                             header = T, sep = ",")
       }

## '_g' = gated
out_g <- vector(mode = "list", length = length(dir(gated_dir)))
for (o in 1:length(dir(gated_dir))) {
    out_g[[o]] <- read.table(file = paste0(gated_dir, dir(gated_dir)[o]),
                             header = T, sep = ",")
       }

## for the ungated set, it'll be
## 1e5 cells * 5 strains/reporter * 20 reporters = 1e7 rows
## fsc gating reduces 1e5 to ~2e4, so ~2e6 rows
## nrow(out_all) = 2284942
out_all <- do.call("rbind", out_g)
str(out_all)
levels(out_all$reporter)


## get the strain factor in the desired order 
out_all$strain <- factor(out_all$strain,
                         levels = levels(out_all$strain)[c(1, 3, 4, 5, 2)])

strain_paste <- expand.grid(unique(out_all$replicate),
                          levels(out_all$strain))

strain_paste <- paste0(strain_paste$Var2, "_", strain_paste$Var1)

out_all$strain_rep <- factor(paste0(out_all$strain, "_", out_all$replicate),
                             levels = strain_paste)

rep_cols <- unlist(lapply(X = 1:length(all_cols), FUN = function(x) {
                       rep(all_cols[x],
                           times = sum(grepl(pattern = names(all_cols[x]), 
                                             x = levels(out_all$strain_rep))))
                   }))

## need to order levels of 'strain_rep' like 'strain'
## 2021.01.20 - split by type I/II Arg/N-end 
aa_order <- c(2, 3, 4, 6, 7, 9, 12, 10, 11, 14, 18, 19, 1, 5, 8, 13, 15, 16, 17, 20)
out_all$o_reporter <- factor(out_all$reporter,
                             levels = levels(out_all$reporter)[aa_order])
levels(out_all$o_reporter)
params <- colnames(out_all)[unlist(lapply(X = out_all, FUN = is.numeric))]
params[10] <- "log2 TFT Ratio"

## <<density_plot_final>>
## have to set up parameters for a custom legend first...
## drop everything for building a custom legend
## into a list.  loop over the list by position
## ('top' or 'bottom') and strain to make 2
## legends in the panels 
top_legend_params <- list()
top_legend_params$names <- c("BY", "RM",
                         expression(paste("BY rpn4", Delta)), 
                         expression(paste("BY ubr1", Delta)), 
                         expression(paste("BY doa10", Delta)))
top_legend_params$line_x1     <- rep(0.8, 5)
top_legend_params$line_x2     <- rep(1.15, 5)    
top_legend_params$x_positions <- rep(x = 1.2, times = 5)
top_legend_params$y_positions <- rev(seq(from = 12.7, to = 13.45, length.out = 5))
top_legend_params$color       <- all_cols
bot_legend_params <- top_legend_params
top_legend_params$y_positions <- rev(seq(from = 4.75, to = 5.5, length.out = 5))
legend_params <- list(top_legend_params, bot_legend_params)

{
pdf(file = "~/Desktop/2021.01.20_density_full_final.pdf", height = 14.5, width = 14)
print(

densityplot(~ TFT_ratio | reporter,
            groups = strain_rep,
            data = out_all,
            xlim = c(-7, 1.5),
            ## set alternating = F for one side, same side labeling
            scales = list(alternating = 3),
            grid = T,
            plot.points = F,
            lwd = 2,
            main = list(label = "Arg/N-end Reporters"),
            sub = list(label = "Ac/N-end Reporters"),
            between = list(x = c(0, 0, 0),
                           y = c(0, 0, 3)),
            as.table = T,
            ylab = ",,",
            xlab = gsub(pattern = "_",
                        replacement = " ",
                        params[10]),
            index.cond = list(aa_order),
            par.settings = list(strip.background = list(col = gray(0.9)),
                                clip = list(panel = FALSE),
                                par.main.text = list(font = 2,
                                                     cex = 1.25,
                                                     just = "center", 
                                                     x = grid::unit(7, "in")),
                                par.sub.text = list(font = 2,
                                                    just = "center",
                                                    cex = 1.25,
                                                    x = grid::unit(7.05, "in"),
                                                    y = grid::unit(5.95, "in")),
                                axis.text = list(cex = 1),
                                par.ylab.text = list(cex = 1.25,
                                                     col = "white"),
                                par.xlab.text = list(cex = 1.25)),
            ## legend = list(inside = list(fun = grid.legend,
            ##                             args = list(labels = c("BY", "RM",
            ##                                   expression(paste("BY rpn4", Delta)), 
            ##                                   expression(paste("BY ubr1", Delta)), 
            ##                                   expression(paste("BY doa10", Delta))),
            ##                                   do.lines = T,
            ##                                   nrow = 5,
            ##                                   draw = T,
            ##                                   hgap = 1,
            ##                                   vgap = 0.25,
            ##                                   gp = gpar(col = all_cols,
            ##                                             lwd = 5,
            ##                                             cex = 1,
            ##                                             lineend = "butt",
            ##                                             npc = 50
            ##                                                   )))),
            ## key = list(text = list(c("BY", "RM",
            ##                           expression(paste("BY rpn4", Delta)),
            ##                           expression(paste("BY ubr1", Delta)),
            ##                           expression(paste("BY doa10", Delta)))),
            ##             lines = list(col = all_cols,
            ##                          lwd = 5),
            ##            corner = c(0, 1),
            ##            y = 0.98),
            panel = function(x, y, q, subscripts, ...) {
                panel.grid(h = -1, v = -1)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = out_all$strain_rep,
                                  subscripts = subscripts,
                                  as.table = T,
                                  lty = 1,
                                  col = rep_cols,
                                  lwd = 0.75)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = out_all$strain,
                                  subscripts = subscripts,
                                  as.table = t,
                                  lty = 1,
                                  lwd = 1.5,
                                  col = all_cols,
                                  ylim = c(0, 2))
            })
)
## <<plot_legend>>
## this gets placed outside the 'print' call
## write out a legend using 'grid.text' and 'grid.lines'
## because I separate the 2 N-end pathways, doubling
## the legend makes for a better visual layout.
## turns out there's not a straightforward way to
## double or position legends built using the lattice
## 'key' argument or grid.legend.  the code below works,
## but it's a bit hacky...
for (k in 1:length(legend_params)) {
    for (l in 1:length(legend_params[[1]])) {
        grid.text(label = legend_params[[k]]$names[l],
                  x = legend_params[[k]]$x_positions[l],
                  y = legend_params[[k]]$y_positions[l],
                  default.units = "in",
                  just = "left",
                  gp = gpar(col = "black", cex = 1))
        grid.lines(x = c(legend_params[[k]]$line_x1[l],
                         legend_params[[k]]$line_x2[l]),
                   y = c(legend_params[[k]]$y_positions[l],
                         legend_params[[k]]$y_positions[l]),
                   default.units = "in",
                   gp = gpar(lwd = 4, lineend = "butt",
                             col = legend_params[[k]]$color[l]))
    }
}

## replace improper y label positioning w/ custom text
## and double it since we've split the plot into 2 panels
grid.text(label = "Density",
          x = c(0.15, 0.15),
          y = c(7.5, 2),
          rot = 90,
          default.units = "in",
          gp = gpar(col = "black", cex = 1.25)
          )

dev.off()
}

## <<example_density_plot_trp_met_final>>
## grab a set of reporters that illustrate
## the deletion phenotypes.  for now, we'll
## use Met and Trp TFTs for this purpose.
out_tw <- out_all[out_all$reporter == "Met TFT" | out_all$reporter == "Trp TFT", ]

{
pdf(file = "~/Desktop/2021.01.20_example_density_2_panel_final.pdf", height = 8, width = 5)
print(
densityplot(~ TFT_ratio | reporter,
            groups = strain_rep,
            data = out_tw,
            xlim = c(-8, 1.5),
            ## set alternating = F for one side, same side labeling
            scales = list(alternating = 1,
                          tck = c(1, 0)),
            grid = T,
            plot.points = F,
            lwd = 2,
            as.table = F,
            ylab = ",",
            xlab = "log2 TFT ratio",
            par.settings = list(strip.background = list(col = gray(0.9)),
                                clip = list(panel = FALSE),
                                par.main.text = list(font = 2,
                                                     cex = 1.25,
                                                     just = "center", 
                                                     x = grid::unit(7, "in")),
                                par.sub.text = list(font = 2,
                                                    just = "center",
                                                    cex = 1.25,
                                                    x = grid::unit(7.05, "in"),
                                                    y = grid::unit(5.95, "in")),
                                axis.text = list(cex = 1),
                                par.ylab.text = list(cex = 1.25,
                                                     col = "white"),
                                par.xlab.text = list(cex = 1.25)),
            panel = function(x, y, q, subscripts, ...) {
                panel.grid(h = -1, v = -1)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = out_tw$strain_rep,
                                  subscripts = subscripts,
                                  as.table = T,
                                  lty = 1,
                                  col = rep_cols,
                                  lwd = 0.75)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = out_tw$strain,
                                  subscripts = subscripts,
                                  as.table = t,
                                  lty = 1,
                                  lwd = 1.5,
                                  col = all_cols,
                                  ylim = c(0, 2))
            })
)
## this gets placed outside the 'print' call
## write out a legend using 'grid.text' and 'grid.lines'
## because I separate the 2 N-end pathways, doubling
## the legend makes for a better visual layout.
## turns out there's not a straightforward way to
## double or position legends built using the lattice
## 'key' argument or grid.legend.  the code below works,
## but it's a bit hacky...
## legend parameters
## drop everything for building a custom legend
## into a list.  loop over the list by position
## ('top' or 'bottom') and strain to make 2
## legends in the panels 
ex_top_legend_params <- list()
ex_top_legend_params$names <- c("BY", "RM",
                                expression(paste("BY rpn4", Delta)), 
                                expression(paste("BY ubr1", Delta)), 
                                expression(paste("BY doa10", Delta)))
## starting point of the lines in 'x'
ex_top_legend_params$line_x1     <- rep(0.9, 5)
## endind position of the lines in 'x'
ex_top_legend_params$line_x2     <- rep(1.25, 5)    
## position of the text in x - rep this 5 times for 5 strains
ex_top_legend_params$x_positions <- rep(x = 1.35, times = 5)
## position of the text in x - rep this 5 times for 5 strains
ex_top_legend_params$y_positions <- rev(seq(from = 6.55, to = 7.25, length.out = 5))
ex_top_legend_params$color       <- all_cols
ex_bot_legend_params <- ex_top_legend_params
ex_top_legend_params$y_positions <- rev(seq(from = 3.1, to = 3.85, length.out = 5))
ex_legend_params <- list(ex_top_legend_params, ex_bot_legend_params)
for (k in 1:length(ex_legend_params)) {
    for (l in 1:length(ex_legend_params[[1]])) {
        grid.text(label = ex_legend_params[[k]]$names[l],
                  x = ex_legend_params[[k]]$x_positions[l],
                  y = ex_legend_params[[k]]$y_positions[l],
                  default.units = "in",
                  just = "left",
                  gp = gpar(col = "black", cex = 1))
        grid.lines(x = c(ex_legend_params[[k]]$line_x1[l],
                         ex_legend_params[[k]]$line_x2[l]),
                   y = c(ex_legend_params[[k]]$y_positions[l],
                         ex_legend_params[[k]]$y_positions[l]),
                   default.units = "in",
                   gp = gpar(lwd = 4, lineend = "butt",
                             col = ex_legend_params[[k]]$color[l]))
    }
}
## replace improper y label positioning w/ custom text
## and double it since we've split the plot into 2 panels
grid.text(label = "Density",
          x = c(0.2, 0.2),
          y = c(2.3, 5.7),
          rot = 90,
          gp = gpar(cex = 1.25),
          default.units = "in")
dev.off()
}

## <<horizontal_orientation>>_
{
pdf(file = "~/Desktop/2021.01.29_horizontal_example_density_2_panel_new_colors.pdf", height = 5, width = 9)
print(
densityplot(~ TFT_ratio | o_reporter,
            groups = strain_rep,
            data = out_tw,
            xlim = c(-8, 1.5),
            ## set alternating = F for one side, same side labeling
            scales = list(alternating = 1,
                          tck = c(1, 0),
                          cex = 1.5),
            grid = T,
            plot.points = F,
            par.strip.text = list(cex = 1.5),
            lwd = 2,
            as.table = T,
            ylab = ",",
            xlab = "log2 RFP / GFP",
            par.settings = list(strip.background = list(col = gray(0.9)),
                                clip = list(panel = FALSE),
                                par.main.text = list(font = 2,
                                                     cex = 1.5,
                                                     just = "center", 
                                                     x = grid::unit(7, "in")),
                                par.sub.text = list(font = 2,
                                                    just = "center",
                                                    cex = 1.5,
                                                    x = grid::unit(7.05, "in"),
                                                    y = grid::unit(5.95, "in")),
                                axis.text = list(cex = 1.5),
                                par.ylab.text = list(cex = 1.5,
                                                     col = "white"),
                                par.xlab.text = list(cex = 1.5)),
            panel = function(x, y, q, subscripts, ...) {
                panel.grid(h = -1, v = -1)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = out_tw$strain_rep,
                                  subscripts = subscripts,
                                  as.table = T,
                                  lty = 1,
                                  col = rep_cols,
                                  lwd = 1)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = out_tw$strain,
                                  subscripts = subscripts,
                                  as.table = t,
                                  lty = 1,
                                  lwd = 2,
                                  col = all_cols,
                                  ylim = c(0, 2))
            })
)
## this gets placed outside the 'print' call
## write out a legend using 'grid.text' and 'grid.lines'
## because I separate the 2 N-end pathways, doubling
## the legend makes for a better visual layout.
## turns out there's not a straightforward way to
## double or position legends built using the lattice
## 'key' argument or grid.legend.  the code below works,
## but it's a bit hacky...
## legend parameters
## drop everything for building a custom legend
## into a list.  loop over the list by position
## ('top' or 'bottom') and strain to make 2
## legends in the panels 
ex_top_legend_params <- list()
ex_top_legend_params$names <- c("BY", "RM",
                                expression(paste("BY rpn4", Delta)), 
                                expression(paste("BY ubr1", Delta)), 
                                expression(paste("BY doa10", Delta)))
## starting point of the lines in 'x'
ex_top_legend_params$line_x1     <- rep(1, 5)
## ending position of the lines in 'x'
ex_top_legend_params$line_x2     <- rep(1.3, 5)    
## position of the text in x - rep this 5 times for 5 strains
ex_top_legend_params$x_positions <- rep(x = 1.4, times = 5)
## position of the text in x - rep this 5 times for 5 strains
ex_top_legend_params$y_positions <- rev(seq(from = 3.1, to = 4.15, length.out = 5))
ex_top_legend_params$color       <- all_cols
ex_bot_legend_params <- ex_top_legend_params
ex_bot_legend_params$line_x1 <- rep(4.875, 5)
ex_bot_legend_params$line_x2 <- rep(5.175, 5)
ex_bot_legend_params$x_positions <- rep(x = 5.275, times = 5)
ex_legend_params <- list(ex_top_legend_params, ex_bot_legend_params)
for (k in 1:length(ex_legend_params)) {
    for (l in 1:length(ex_legend_params[[1]])) {
        grid.text(label = ex_legend_params[[k]]$names[l],
                  x = ex_legend_params[[k]]$x_positions[l],
                  y = ex_legend_params[[k]]$y_positions[l],
                  default.units = "in",
                  just = "left",
                  gp = gpar(col = "black", cex = 1.5))
        grid.lines(x = c(ex_legend_params[[k]]$line_x1[l],
                         ex_legend_params[[k]]$line_x2[l]),
                   y = c(ex_legend_params[[k]]$y_positions[l],
                         ex_legend_params[[k]]$y_positions[l]),
                   default.units = "in",
                   gp = gpar(lwd = 5, lineend = "butt",
                             col = ex_legend_params[[k]]$color[l]))
    }
}
## replace improper y label positioning w/ custom text
## and double it since we've split the plot into 2 panels
grid.text(label = "Density",
          x = 0.2,
          y = 2.45, 
          rot = 90,
          gp = gpar(cex = 1.5),
          default.units = "in")
dev.off()
}

## <<strip_plots>>
## these plots are built by extracting the mean/median
## of each biological replicate of each strain.  Thus,
## we reduce 10,000 observations of a replicate to a
## single value.  w/ 8 biological replicates per strain,
## we can make a nice stripplot of strain * reporter
## for the different parameters.  We'll also use this
## to make a levelplot/heatmap

## 'aggregate' creates a new dataframe from x by applying FUN to
## all unique combinations of the factors supplied to the 'by'
## argument - in this case, grab the mean of numeric data and
## keep everything else a factor 
out_agg <- aggregate.data.frame(x = out_all,
                                by = list(out_all$strain,
                                          out_all$reporter,
                                          out_all$replicate),
                            FUN = function(x) {
                                ifelse(is.numeric(x), mean(x), as.factor(x))
                            })

## 'aggregate' seems to strip the levels from factors, so add
## these back using the values present in the original dataframe
out_agg$strain <- factor(out_agg$strain,
                     levels = unique(out_agg$strain),
                     labels = levels(out_all$strain))

out_agg$reporter <- factor(out_agg$reporter,
                     levels = unique(out_agg$reporter),
                     labels = levels(out_all$reporter))

out_agg$strain_rep <- factor(out_agg$strain_rep,
                             levels = unique(out_agg$strain_rep),
                             labels = levels(out_all$strain_rep))

## need a color vector that maps to strains that's the
## length of levels(strain) * levels(replicate) (usually 40)
out_agg_cols <- vector()
for (i in 1:nrow(out_agg)) {
    out_agg_cols[i] <- all_cols[out_agg$strain[i] == names(all_cols)]
}


{
pdf(file = "~/Desktop/2021.01.20_strip_full_final_no_Z.pdf", height = 14.5, width = 14)
print(
stripplot(TFT_ratio ~ strain | reporter,
          data = out_agg,
          col = gray(0),
          fill = out_agg_cols,
          pch = 21,
          cex = 1.1,
          scales = list(alternating = 3,
                        x = list(labels = c("BY", "RM",
                         expression(paste("BY rpn4", Delta)), 
                         expression(paste("BY ubr1", Delta)), 
                         expression(paste("BY doa10", Delta))),
                         rot = 45)),
          layout = c(4, 5),
          grid = T,
          main = list(label = "Arg/N-end Reporters"),
          sub = list(label = "Ac/N-end Reporters"),
          between = list(x = c(0, 0, 0),
                         y = c(0, 0, 3)),
          as.table = T,
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.main.text = list(font = 2,
                                                   cex = 1.25,
                                                   just = "center", 
                                                   x = grid::unit(7, "in"),
                                                   y = grid::unit(13, "in")),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.25,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(6.25, "in")),
                              axis.text = list(cex = 1),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.25)),
          jitter.data = T,
          ## factor for jittering
          factor = 1.5,
          index.cond = list(aa_order),
          horizontal = F)
)

## main title, not sure why this doesn't show up otherwise
## probably some par setting re: going outside the grid....
grid.text(label = "Arg/N-end Reporters",
          x = 7.0,
          y = 14.2,
          default.units = "in",
          gp = gpar(cex = 1.25, font = 2))

## y axis labels for the strip
grid.text(label = "log2 TFT ratio",
          x = c(0.15, 0.15),
          y = c(7.75, 2.25),
          rot = 90,
          default.units = "in",
          gp = gpar(col = "black", cex = 1.25)
          )
dev.off()
}


## let's try to convert to Z scores 
i <- 1

out_z <- list()
reporter <- levels(out_agg$reporter)
for (i in 1:length(reporter)) {
    
    z_mean <- mean(out_agg$TFT_ratio[out_agg$reporter == reporter[i]])
    z_sd   <- sd(out_agg$TFT_ratio[out_agg$reporter == reporter[i]])
    z_out  <- function(x) { ((x - z_mean) / (z_sd))  }
    out_subset <- out_agg[out_agg$reporter == reporter[i], ]

    for (j in 1:nrow(out_subset)) {
        out_subset$zTFT[j] <- z_out(out_subset$TFT_ratio[j]) * -1
        }
    reporter_min <- min(out_subset$zTFT)
    out_subset$zTFT <- out_subset$zTFT - reporter_min
        out_z[[i]] <- out_subset
}

out_z <- do.call("rbind", out_z)
range(out_z$zTFT)

new_aa_order <- c(2, 3, 4, 6, 7, 9, 10, 11, 12, 14, 18, 19, 1, 5, 8, 13, 15, 16, 17, 20)
out_z$r_order <- factor(out_z$reporter,
                        levels = levels(out_z$reporter)[rev(new_aa_order)])

out_z$t_order <- factor(out_z$reporter,
                        levels = levels(out_z$reporter)[rev(aa_order)])

## aggregate into a smaller data frame for the actual heatmap
out_m <- aggregate.data.frame(x = out_z,
                               by = list(out_z$strain,
                                         out_z$reporter),
                               FUN = function(x) {
                                   ifelse(is.numeric(x), mean(x), as.factor(x))
                               })

out_m$strain <- factor(out_m$strain,
                        levels = unique(out_m$strain),
                        labels = levels(out_all$strain))

out_m$reporter <- factor(out_m$reporter,
                          levels = unique(out_m$reporter),
                          labels = levels(out_all$reporter))

out_m$r_order <- factor(out_m$reporter,
                        levels = levels(out_m$reporter)[rev(new_aa_order)])

out_m$t_order <- factor(out_m$reporter,
                        levels = levels(out_m$reporter)[rev(aa_order)])


hm_cols <- rev(brewer.pal(n = 11, name = "PiYG"))

{
pdf(file = "~/Desktop/2021.01.20_TFT_heat_final.pdf", height = 14, width = 6)
print(
levelplot(zTFT ~ strain * t_order,
          strip = T,
          xlab = "normalized RFP / GFP",
          ylab = "Reporter",
          data = out_m,
          pretty = T,
          col.regions = hm_cols,
          ylab.right = "Z score",
          scales = list(alternating = F,
                        x = list(labels = c("BY", "RM",
                                            expression(paste("BY rpn4", Delta)), 
                                            expression(paste("BY ubr1", Delta)), 
                                            expression(paste("BY doa10", Delta))),
                                 rot = 45),
                        ## scales only on left/bottom
                        tck = c(1, 0)),
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.25,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(6.25, "in")),
                              layout.heights = list(xlab.key.padding = 1),
                              layout.widths = list(left.padding = 5),
                              axis.text = list(cex = 1.25),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.25)), 
##          col.regions = gray(level = 29:0/29),
          at = seq(from = -2, to = 2, length.out = 10),
          colorkey = list(at = seq(from = -2, to = 2, length.out = 11),
                          cex = 1.25,
                          title = "normalized RFP / GFP",
                          space = "bottom",
                          columns = 1,
                          row = 10),
          border = gray(0.3),
          as.table = T,
          ## index.cond = list(aa_order),
          border.lwd = 2)
)
## Ac/N-end reporter lines
grid.lines(x = c(0.65, 0.65),
           y = c(2.4, 6.42),
           default.units = "in",
           gp = gpar(lwd = 2, col = gray(0.4)))
## Ac/N-end reporter text
grid.text(x = 0.3, y = 4.41,
          label = "Ac/N-end\nReporters",
          default.units = "in",
          rot = 90,
          gp = gpar(cex = 1.25))
## type I Arg/N-end reporter lines
grid.lines(x = c(0.65, 0.65),
           y = c(9.83, 13.25),
           default.units = "in",
           gp = gpar(lwd = 2, col = gray(0.4)))
## type I Arg/N-end reporter text
grid.text(x = 0.3, y = 11.5,
          label = "Type I Arg/N-end\nReporters",
          default.units = "in",
          rot = 90,
          gp = gpar(cex = 1.25))
## type II Arg/N-end reporter lines
grid.lines(x = c(0.65, 0.65),
           y = c(6.95, 9.25),
           default.units = "in",
           gp = gpar(lwd = 2, col = gray(0.4)))
## type II Arg/N-end reporter text
grid.text(x = 0.3, y = 8.1,
          label = "Type II Arg/N-end\nReporters",
          default.units = "in",
          rot = 90,
          gp = gpar(cex = 1.25))
dev.off()
}


## <<Z_score_stripplot_final>>
{
pdf(file = "~/Desktop/2021.01.29_z_0_normalized_strip_full_final.pdf", height = 14.5, width = 14)
print(
stripplot(zTFT ~ strain | reporter,
          data = out_z,
          col = gray(0),
          fill = out_agg_cols,
          pch = 21,
          cex = 1.5,
          par.strip.text = list(cex = 1.5),
          scales = list(alternating = 1,
                        tck = c(2, 0),
                        cex = 1.5,
                        x = list(labels = c("BY", "RM",
                         expression(paste("BY rpn4", Delta)), 
                         expression(paste("BY ubr1", Delta)), 
                         expression(paste("BY doa10", Delta))),
                         rot = 45)),
          layout = c(4, 5),
          grid = T,
          between = list(x = c(0, 0, 0),
                         y = c(0, 0, 3)),
          as.table = T,
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.main.text = list(font = 2,
                                                   cex = 1.5,
                                                   just = "center", 
                                                   x = grid::unit(7, "in"),
                                                   y = grid::unit(13, "in")),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.5,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(6.25, "in")),
                              axis.text = list(cex = 1),
                              layout.widths = list(left.padding = 5),
                              par.ylab.text = list(cex = 1.5,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.5)),
          jitter.data = T,
          ## factor for jittering
          factor = 1.75,
          index.cond = list(aa_order),
          horizontal = F)
)
## main title, not sure why this doesn't show up otherwise
## probably some par setting re: going outside the grid....
grid.text(label = c("Arg/N-end Reporters", "  Ac/N-end Reporters"),
          x = c(7.32, 7.32),
          y = c(14.35, 6.5),
          default.units = "in",
          gp = gpar(cex = 1.5, font = 2))
## y axis labels for the strip
grid.text(label = "Normalized UPS\nPathway Activity",
          x = c(0.35, 0.35),
          y = c(10.175, 3.55),
          rot = 90,
          default.units = "in",
          gp = gpar(col = "black", cex = 1.5)
          )
dev.off()
}

## <<example_stripplots_final>>
## use met and trp for this purpose
## these will go into figure 1, but
## are just for illustration purposes...
out_x <- out_z[out_z$reporter == "Met TFT" | out_z$reporter == "Trp TFT", ]

{
pdf(file = "~/Desktop/2021.01.29_example_strip_2_panel_final.pdf", height = 8, width = 5)
print(
stripplot(zTFT ~ strain | reporter,
          data = out_x,
          col = gray(0),
          fill = out_agg_cols,
          pch = 21,
          cex = 1.5,
          scales = list(alternating = 1,
                        tck = c(1, 0),
                        x = list(labels = c("BY", "RM",
                         expression(paste("BY rpn4", Delta)), 
                         expression(paste("BY ubr1", Delta)), 
                         expression(paste("BY doa10", Delta))),
                         rot = 45)),
          layout = c(1, 2),
          grid = T,
          as.table = F,
          jitter = T,
          factor = 1.7,
          ylab = "Z-score",
          xlab = "Strain",
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.main.text = list(font = 2,
                                                   cex = 1.5,
                                                   just = "center", 
                                                   x = grid::unit(7, "in"),
                                                   y = grid::unit(13, "in")),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.5,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(6.25, "in")),
                              axis.text = list(cex = 1.5),
                              par.ylab.text = list(cex = 1.5,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.5)),
          horizontal = F)
)
grid.text(label = "normalized UPS Pathway Activity",
          x = c(0.2, 0.2),
          y = c(2.75, 5.85),
          rot = 90,
          gp = gpar(cex = 1.5),
          default.units = "in")
dev.off()
}

## <<horizontal_orientation>>
out_x$o_order <- factor(out_x$reporter,
                        levels = levels(out_x$reporter)[aa_order])

out_x$nTFT <- out_x$zTFT * -1

this_test <- list()
to_norm <- unique(out_x$o_order)

for (n in 1:length(to_norm)) {
    this_test[[n]] <- out_x[out_x$o_order == to_norm[n], ]
    val  <- min(this_test[[n]]$nTFT)
    this_test[[n]]$nTFT <- this_test[[n]]$nTFT - val
}

this_test <- do.call("rbind", this_test)



{
pdf(file = "~/Desktop/2021.01.29_horizontal_example_strip_2_panel_normalized.pdf", height = 5, width = 9)
print(
stripplot(nTFT ~ strain | o_order,
          data = this_test,
          col = gray(0),
          fill = out_agg_cols,
          pch = 21,
          cex = 1.75,
          scales = list(alternating = 1,
                        tck = c(1, 0),
                        x = list(labels = c("BY", "RM",
                         expression(paste("BY rpn4", Delta)), 
                         expression(paste("BY ubr1", Delta)), 
                         expression(paste("BY doa10", Delta))),
                         rot = 45)),
          layout = c(2, 1),
          grid = T,
          as.table = F,
          jitter = T,
          par.strip.text = list(cex = 1.5),
          factor = 2,
          ylab = "Normalized UPS\nPathway Activity",
          xlab = "Strain",
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.main.text = list(font = 2,
                                                   cex = 1.5,
                                                   just = "center", 
                                                   x = grid::unit(7, "in"),
                                                   y = grid::unit(13, "in")),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.5,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(6.25, "in")),
                              axis.text = list(cex = 1.5),
                              par.xlab.text = list(cex = 1.5),
                              par.ylab.text = list(cex = 1.5)),
          horizontal = F)
)
## grid.text(label = "normalized TFT score",
##           x = c(0.2, 0.2),
##           y = c(2.75, 5.85),
##           rot = 90,
##           gp = gpar(cex = 1.25),
##           default.units = "in")
dev.off()
}

simple <- data.frame(out = c(log2(0.1), log2(1)),
                     group = factor(c(1, 2),
                                    levels = c(1,2),
                                    labels = c("high deg", "low deg")))
{
pdf(file = "~/Desktop/2021.01.25_simple_TFT_ratiobarchar.pdf", height = 5, width = 5)
print(
barchart(out ~ group,
         data = simple,
         ylab = "log2 RFP / GFP",
         horizontal = F,
         col = gray(0.7),
         box.ratio = 0.9,
         ## scales = list(alternating = 1,
         ##                 x = list(labels = c(
         ##                 expression(paste("High\nDegradation\nRate")), 
         ##                 expression(paste("Low\nDegradation\nRate"))))),
         ##                 ## rot = 45)),
         par.settings = list(axis.text = list(cex = 1.25),
                              par.xlab.text = list(cex = 1.25),
                              par.ylab.text = list(cex = 1.25)),
         panel = function(...) {
             panel.grid(h = -1, v = F)
             panel.barchart(...)
})
)
dev.off()
}

save.session(file = "~/Desktop/2021.01.25_R_session")
library("session")

## <<BY_RM_plot>>
## nrow(out_agg) = 800, so 300 should be BY or RM 
out_by_rm <- grepl(pattern = "[BR][YM]",
                   x = as.character(out_agg$strain))

out_br <- out_agg[out_by_rm, ]

out_br_cols <- vector()

for (i in 1:nrow(out_br)) {
out_br_cols[i] <- all_cols[out_br$strain[i] == names(all_cols)]
}

{
pdf(file = "~/Desktop/2021.01.20_by_rm_final.pdf", height = 14.5, width = 14)
print(
## need to make a TFT ratio amino acid index 
stripplot(TFT_ratio ~ strain | reporter,
          data = out_br,
          type = c("g", "p"),
          col = gray(0),
          fill = out_br_cols,
          pch = 21,
          cex = 1.1,
          scales = list(alternating = 3,
                        x = list(labels = c("BY", "RM"))),
          layout = c(4, 5),
          grid = T,
          main = list(label = "Arg/N-end Reporters"),
          sub = list(label = "Ac/N-end Reporters"),
          between = list(x = c(0, 0, 0),
                         y = c(0, 0, 3)),
          as.table = T,
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.main.text = list(font = 2,
                                                   cex = 1.25,
                                                   just = "center", 
                                                   x = grid::unit(7, "in"),
                                                   y = grid::unit(13, "in")),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.25,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(5.95, "in")),
                              axis.text = list(cex = 1),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.25)),
          jitter.data = T,
          ## factor for jittering
          factor = 1.5,
          index.cond = list(aa_order),
          horizontal = F)
)
## main title, not sure why this doesn't show up otherwise
## probably some par setting re: going outside the grid....
grid.text(label = "Arg/N-end Reporters",
          x = 7.0,
          y = 14.2,
          default.units = "in",
          gp = gpar(cex = 1.25, font = 2))

## y axis labels for the strip
grid.text(label = "log2 TFT ratio",
          x = c(0.15, 0.15),
          y = c(7.45, 1.85),
          rot = 90,
          default.units = "in",
          gp = gpar(col = "black", cex = 1.25))
dev.off() 
}
#+END_SRC

# need to figure out how to plot delta symbols
# https://stats.idre.ucla.edu/r/codefragments/greek_letters/
#+BEGIN_SRC R :results graphics :file /tmp/delta.pdf
barplot(c(4,4,4), ylab = expression(paste("BY rpn4", Delta)))
#+END_SRC

#+RESULTS:
[[file:/tmp/delta.pdf]]

* DONE 2021.01.20 - Density Plot, Strip Chart, BY-RM Strip, and TFT Ratio Heatmap
  :LOGBOOK:
  - State "DONE"       from              [2021-01-20 Wed 17:32]
  :END:
#+BEGIN_SRC R :tangle ~/Desktop/N-end_TFT_heatmap.R
## -----
## load all the required packages
source("~/emacs/R/functions/load_flow_packages.R")

#############
## USER INPUT
#############
reporter_names <- c("Gln_TFT", "Asn_TFT", "Glu_TFT", "Asp_TFT",
                    "Ile_TFT", "His_TFT", "Tyr_TFT", "Trp_TFT",
                    "Leu_TFT", "Phe_TFT", "Lys_TFT", "Arg_TFT",
                    "Thr_TFT", "Met_TFT", "Pro_TFT", "Val_TFT",
                    "Gly_TFT", "Ser_TFT", "Ala_TFT", "Cys_TFT")
base_dir       <- "~/data/flow/N-end_all_reporters/"
work_dir       <- paste0(base_dir, "fcs/")
frame_dir      <- paste0(base_dir, "dataframes/")
gated_dir      <- paste0(frame_dir, "gated/")
ungated_dir    <- paste0(frame_dir, "ungated/")
## reporter_name <- "rpn4_TFT"
## reporter_name <- "0662_TFT"
#################
## END USER INPUT
#################

#############
## USER INPUT
#############
reporter_names <- c("Gln_TFT", "Asn_TFT", "Glu_TFT", "Asp_TFT",
                    "Ile_TFT", "His_TFT", "Tyr_TFT", "Trp_TFT",
                    "Leu_TFT", "Phe_TFT", "Lys_TFT", "Arg_TFT",
                    "Thr_TFT", "Met_TFT", "Pro_TFT", "Val_TFT",
                    "Gly_TFT", "Ser_TFT", "Ala_TFT", "Cys_TFT")
base_dir       <- "~/data/flow/N-end_all_reporters/"
work_dir       <- paste0(base_dir, "fcs/")
frame_dir      <- paste0(base_dir, "dataframes/")
gated_dir      <- paste0(frame_dir, "gated/")
ungated_dir    <- paste0(frame_dir, "ungated/")
## reporter_name <- "rpn4_TFT"
## reporter_name <- "0662_TFT"
#################
## END USER INPUT
#################


## -----
## we'll loop over all the reporter names to
## [1] read in all the fcs files for a given reporter
## [2] gate each file based on fsc
## [3] write each collection of files to a data table
## [4] add variables for downstream processing (strain/reporter names, e.g.)
for (k in 1:length(reporter_names)) {

## -----
## [x]
## name the strains based on reporter, then set
## regex for getting flowsets of the different strains
## generally, should name fcs files as follows:
## strain    - by, rm, rpn4, rpn10
## reporter  - PSV, TFT, untagged
## replicate - 001, 002, etc... per strain
## e.g., "RM_Arg_TFT_001.fcs"

## 2020.05.09
## this is my current approach to reading in files.  the idea is to
## put all the various strains I've used in the past here and filter this
## complete set to those strains present in the actual data I'm analyzing.  I
## pre-filter using 'grepl' because 'read.flowset' throws an error if any term
## you supply it doesn't match.
no_reporter  <- paste0(".*untagged.*", reporter_names[k], ".*fcs") 
by_strain    <- paste0("BY.*", reporter_names[k], ".*fcs") 
rm_strain    <- paste0("RM.*", reporter_names[k], ".*fcs") 
rpn4_strain  <- paste0("rpn4.*", reporter_names[k], ".*fcs") 
ubr1_strain  <- paste0("ubr1.*", reporter_names[k], ".*fcs") 
doa10_strain <- paste0("doa10.*", reporter_names[k], ".*fcs") 
pop_1_strain <- paste0("SFA.*pop_001.*", reporter_names[k], ".*fcs") 
pop_5_strain <- paste0("SFA.*pop_005.*", reporter_names[k], ".*fcs") 
pop_6_strain <- paste0("SFA.*pop_006.*", reporter_names[k], ".*fcs") 

all_strains <- c(no_reporter, by_strain, rm_strain,
                 rpn4_strain, ubr1_strain, doa10_strain,
                 pop_1_strain, pop_5_strain, pop_6_strain)

## 'dir' lists the contents of a directory - test whether each strain regex
## matches any files in the list produced by 'dir'.  if a match occurs, the
## value returned by 'max' will be 1, else 0.  take only the strains that
## returned a match in the 2nd step below w/ 'all.strains <- ...'
true_strains <- sapply(all_strains, function(strain){
                           as.logical(max(grepl(pattern = strain,
                                                x = dir(path = work_dir,
                                                        pattern = ".*.fcs",
                                                        include.dirs = F,
                                                        ignore.case = T,
                                                        recursive = F,
                                                        no.. = T))))
                       })

all_strains <- as.list(all_strains[true_strains])

all_set     <- lapply(all_strains, function(strain){
                          read.flowSet(files = NULL,
                                       path = work_dir,
                                       pattern = strain,
                                       alter.names = T,
                                       min.limit = 1)
                      })
## str(all_set[[1]]@phenoData@data$name)

name_list <- strsplit(x = names(true_strains)[true_strains == T],
                      split = "\\.\\*")

names(all_set) <- unlist(lapply(X = name_list, FUN = function(x) {
                                    x[1] }))

## -----
## <<Color_Setup>>
## linking colors to strain names in R
## I think I should be able to make something
## akin to an lisp association list where
## there is a strain name and associated color
col_untagged <- c(color = gray(0.7),   name = "no reporter")
## 2021.01.27 - new colors for BY/RM
## col_by       <- c(color = "#7A9BCCFF", name = ".*BY.*")
col_by       <- c(color = "#2166ACFF", name = ".*BY.*")
## col_rm       <- c(color = "#CC7AAAFF", name = ".*RM.*")
col_rm       <- c(color = "#BF3232FF", name = ".*RM.*")
## col_rpn4     <- c(color = "#CCAB7AFF", name = ".*rpn4.*")
col_rpn4     <- c(color = "#CCA14AFF", name = ".*rpn4.*")
## col_ubr1     <- c(color = "#88CCBBFF", name = ".*ubr1.*")
col_ubr1     <- c(color = "#78BCABFF", name = ".*ubr1.*")
## col_doa10    <- c(color = "#A3CC7AFF", name = ".*doa10.*")
col_doa10    <- c(color = "#83BC6AFF", name = ".*doa10.*")
col_pop_1    <- c(color = gray(0.7),   name = ".*population.*1.*")
col_pop_5    <- c(color = "#AA1111FF", name = ".*population.*5.*")
col_pop_6    <- c(color = gray(0),     name = ".*population.*6.*")

cols_list    <- list(col_untagged, col_by, col_rm, 
                     col_rpn4, col_ubr1, col_doa10,
                     col_pop_1, col_pop_5, col_pop_6)

col_out <- sapply(X = cols_list, FUN = function(x){
                      grepl(pattern = x["name"],
                            x = name_list)
                  })

col_out <- as.logical(unlist(sapply(1:ncol(col_out),
                                    FUN = function(x){
                                        max(col_out[, x])
                                    })))

all_cols <- unlist(sapply(X = cols_list[col_out],
                          FUN = function(x){identity(x["color"])}))

names(all_cols) <- names(all_set)

## output a dummmy plot to assess strain/color mapping
## setwd(results.dir)
## pdf(file = "color_mapping.pdf", height = 7, width = 7, bg = "transparent")
barplot(rep(4, length(name_list)), col = all_cols, ylim = c(0, 7))
box()
legend(x = "topleft", legend = names(all_set),
       lty = 1, lwd = 7.5, col = all_cols,
       bg = "white")
legend(x = "topright", y = NA,
       legend = unlist(lapply(X = cols_list, FUN = function(x){identity(x)["name"]})),
       col = unlist(lapply(X = cols_list, FUN = function(x){identity(x)["color"]})),
       lty = 1, lwd = 7.5,  bg = "white")
## dev.off()


## a function to gate the cells to include only haploids.
## we identify these as a sharp peak in the lower end of
## the fsc density plot.  I take 10% above and below the
## max density value
fsc_gate_generator <- function(fl_frame){
    fsc_dens  <- density(exprs(fl_frame[, 1]))
    ## return the index of the maximum y value of the density estimate
    fsc_max   <- fsc_dens[[1]][which.max(fsc_dens[[2]])]
    fsc_upper <- (fsc_max * 0.10) + fsc_max
    fsc_lower <- fsc_max - (fsc_max * 0.10)
    fsc_gate  <- c(fsc_lower, fsc_upper)
}

fsc_split <- function(x){
    split(x, f = rectangleGate("FSC.A" = fsc_gate_generator(x)),
          population = "defaultRectangleGate+",
          flowSet = T, codeflowSet = T)}

## gate all samples on FSC
fsc_set <- lapply(all_set, fsApply, fsc_split)

## convert gated samples from flowsets to flowframes 
fsc_frame <- lapply(fsc_set, function(set) {
                        lapply(set, set2Frame)
                    })

## pull dataframes from flowframes for gated and
## ungated sets of samples, then rename 
fsc_gate_exprs <- vector(mode = "list", length = length(all_set))
no_gate_exprs  <- fsc_gate_exprs

for(j in 1:length(fsc_frame)) {
    for (i in 1:length(fsc_frame[[j]])) {
        fsc_gate_exprs[[j]][[i]] <- as.data.frame(exprs(fsc_frame[[j]][[i]]))
        fsc_gate_exprs[[j]][[i]]$strain <- as.factor(names(fsc_frame[j]))
        fsc_gate_exprs[[j]][[i]]$replicate <- as.factor(i)
    }
    fsc_gate_exprs[[j]] <- do.call("rbind", fsc_gate_exprs[[j]])
} 

## bind into a single dataframe
fsc_gate_exprs <- do.call("rbind", fsc_gate_exprs)

## add transformation parameters
fsc_gate_exprs$log_GFP   <- log10(fsc_gate_exprs$eGFP.A)
fsc_gate_exprs$log_RFP   <- log10(fsc_gate_exprs$mCherry.A)
fsc_gate_exprs$TFT_ratio <- log2(fsc_gate_exprs$mCherry.A / fsc_gate_exprs$eGFP.A)
fsc_gate_exprs$reporter  <- as.factor(rep(x = gsub(pattern = "_",
                                                  replacement = " ",
                                                  x = reporter_names[k]),
                                         times = nrow(fsc_gate_exprs)))

## nested loops for the ungated data
for (j in 1:length(all_set)){
    for (i in 1:length(all_set[[j]])) {
        no_gate_exprs[[j]][[i]] <- as.data.frame(exprs(all_set[[j]][[i]]))
        no_gate_exprs[[j]][[i]]$strain <- as.factor(names(all_set[j]))
        no_gate_exprs[[j]][[i]]$replicate <- as.factor(i)
    }
    no_gate_exprs[[j]] <- do.call("rbind", no_gate_exprs[[j]])
}

## bind into a single dataframe
no_gate_exprs <- do.call("rbind", no_gate_exprs)

## add transformation parameters and reporter var
no_gate_exprs$log_GFP   <- log10(no_gate_exprs$eGFP.A)
no_gate_exprs$log_RFP   <- log10(no_gate_exprs$mCherry.A)
no_gate_exprs$TFT_ratio <- log2(no_gate_exprs$mCherry.A / no_gate_exprs$eGFP.A)
no_gate_exprs$reporter  <- as.factor(rep(x = gsub(pattern = "_",
                                                  replacement = " ",
                                                  x = reporter_names[k]),
                                         times = nrow(no_gate_exprs)))

## write the ungated data to the appropriate dir
write.table(x = no_gate_exprs,
            file = paste0(ungated_dir,
                          reporter_names[k],
                          "_all_ungated.csv"),
            append = F, sep = ",",
            quote = F, row.names = F)

## write the gated data to the appropriate dir
write.table(x = fsc_gate_exprs,
            file = paste0(gated_dir,
                          reporter_names[k],
                          "_all_gated.csv"),
            append = F, sep = ",",
            quote = F, row.names = F)

    }

## now, read each reporter's dataframe in and
## combine into a single dataframe
## generate a list of files in a directory using
## the 'dir' command, e.g.:
## dir(gated_dir)
## dir(ungated_dir)

## '_u' = ungated
out_u <- vector(mode = "list", length = length(dir(ungated_dir)))
for (o in 1:length(dir(gated_dir))) {
    out_u[[o]] <- read.table(file = paste0(ungated_dir, dir(ungated_dir)[o]),
                             header = T, sep = ",")
       }

## '_g' = gated
out_g <- vector(mode = "list", length = length(dir(gated_dir)))
for (o in 1:length(dir(gated_dir))) {
    out_g[[o]] <- read.table(file = paste0(gated_dir, dir(gated_dir)[o]),
                             header = T, sep = ",")
       }

## for the ungated set, it'll be
## 1e5 cells * 5 strains/reporter * 20 reporters = 1e7 rows
## fsc gating reduces 1e5 to ~2e4, so ~2e6 rows
## nrow(out_all) = 2284942
out_all <- do.call("rbind", out_g)
str(out_all)
levels(out_all$reporter)

## 2021.01.20 - split by type I/II Arg/N-end 
aa_order <- c(2, 3, 4, 6, 7, 9, 12, 10, 11, 14, 18, 19, 1, 5, 8, 13, 15, 16, 17, 20)

## get the strain factor in the desired order 
out_all$strain <- factor(out_all$strain,
                         levels = levels(out_all$strain)[c(1, 3, 4, 5, 2)])

strain_paste <- expand.grid(unique(out_all$replicate),
                          levels(out_all$strain))

strain_paste <- paste0(strain_paste$Var2, "_", strain_paste$Var1)

out_all$strain_rep <- factor(paste0(out_all$strain, "_", out_all$replicate),
                             levels = strain_paste)

rep_cols <- unlist(lapply(X = 1:length(all_cols), FUN = function(x) {
                       rep(all_cols[x],
                           times = sum(grepl(pattern = names(all_cols[x]), 
                                             x = levels(out_all$strain_rep))))
                   }))

## need to order levels of 'strain_rep' like 'strain'
## 2021.01.20 - split by type I/II Arg/N-end 
aa_order <- c(2, 3, 4, 6, 7, 9, 12, 10, 11, 14, 18, 19, 1, 5, 8, 13, 15, 16, 17, 20)
out_all$o_reporter <- factor(out_all$reporter,
                             levels = levels(out_all$reporter)[aa_order])
levels(out_all$o_reporter)
params <- colnames(out_all)[unlist(lapply(X = out_all, FUN = is.numeric))]
params[10] <- "log2 TFT Ratio"

## <<session_restore_point>>
## from this point, I've:
## 1. loaded all N-end TFT flowsets into R
## 2. assigned colors
## 3. gated the cells on the basis of FSC
## 4. build dataframes from the flowsets
## 5. *ordered the reporters by type and alphabetical*
## save.session(file = "~/Desktop/2021.01.29_all_flow_sets_loaded")
source("~/emacs/R/functions/load_flow_packages.R")
restore.session(file = "~/Desktop/2021.01.29_all_flow_sets_loaded")
## ls()

## <<density_plot_final>>
## have to set up parameters for a custom legend first...
## drop everything for building a custom legend
## into a list.  loop over the list by position
## ('top' or 'bottom') and strain to make 2
## legends in the panels 
top_legend_params <- list()
top_legend_params$names <- c("BY", "RM",
                         expression(paste("BY rpn4", Delta)), 
                         expression(paste("BY ubr1", Delta)), 
                         expression(paste("BY doa10", Delta)))
top_legend_params$line_x1     <- rep(0.8, 5)
top_legend_params$line_x2     <- rep(1.15, 5)    
top_legend_params$x_positions <- rep(x = 1.2, times = 5)
top_legend_params$y_positions <- rev(seq(from = 12.7, to = 13.45, length.out = 5))
top_legend_params$color       <- all_cols
bot_legend_params <- top_legend_params
top_legend_params$y_positions <- rev(seq(from = 4.75, to = 5.5, length.out = 5))
legend_params <- list(top_legend_params, bot_legend_params)

{
pdf(file = "~/Desktop/2021.01.29_density_full_final_new.pdf", height = 14.5, width = 14)
print(

densityplot(~ TFT_ratio | reporter,
            groups = strain_rep,
            data = out_all,
            xlim = c(-7, 1.5),
            ## set alternating = F for one side, same side labeling
            scales = list(alternating = 3),
            grid = T,
            plot.points = F,
            lwd = 2,
            main = list(label = "Arg/N-end Reporters"),
            sub = list(label = "Ac/N-end Reporters"),
            between = list(x = c(0, 0, 0),
                           y = c(0, 0, 3)),
            as.table = T,
            ylab = ",,",
            xlab = gsub(pattern = "_",
                        replacement = " ",
                        params[10]),
            index.cond = list(aa_order),
            par.settings = list(strip.background = list(col = gray(0.9)),
                                clip = list(panel = FALSE),
                                par.main.text = list(font = 2,
                                                     cex = 1.25,
                                                     just = "center", 
                                                     x = grid::unit(7, "in")),
                                par.sub.text = list(font = 2,
                                                    just = "center",
                                                    cex = 1.25,
                                                    x = grid::unit(7.05, "in"),
                                                    y = grid::unit(5.95, "in")),
                                axis.text = list(cex = 1),
                                par.ylab.text = list(cex = 1.25,
                                                     col = "white"),
                                par.xlab.text = list(cex = 1.25)),
            ## legend = list(inside = list(fun = grid.legend,
            ##                             args = list(labels = c("BY", "RM",
            ##                                   expression(paste("BY rpn4", Delta)), 
            ##                                   expression(paste("BY ubr1", Delta)), 
            ##                                   expression(paste("BY doa10", Delta))),
            ##                                   do.lines = T,
            ##                                   nrow = 5,
            ##                                   draw = T,
            ##                                   hgap = 1,
            ##                                   vgap = 0.25,
            ##                                   gp = gpar(col = all_cols,
            ##                                             lwd = 5,
            ##                                             cex = 1,
            ##                                             lineend = "butt",
            ##                                             npc = 50
            ##                                                   )))),
            ## key = list(text = list(c("BY", "RM",
            ##                           expression(paste("BY rpn4", Delta)),
            ##                           expression(paste("BY ubr1", Delta)),
            ##                           expression(paste("BY doa10", Delta)))),
            ##             lines = list(col = all_cols,
            ##                          lwd = 5),
            ##            corner = c(0, 1),
            ##            y = 0.98),
            panel = function(x, y, q, subscripts, ...) {
                panel.grid(h = -1, v = -1)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = out_all$strain_rep,
                                  subscripts = subscripts,
                                  as.table = T,
                                  lty = 1,
                                  col = rep_cols,
                                  lwd = 0.75)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = out_all$strain,
                                  subscripts = subscripts,
                                  as.table = t,
                                  lty = 1,
                                  lwd = 1.5,
                                  col = all_cols,
                                  ylim = c(0, 2))
            })
)


## <<plot_legend>>
## this gets placed outside the 'print' call
## write out a legend using 'grid.text' and 'grid.lines'
## because I separate the 2 N-end pathways, doubling
## the legend makes for a better visual layout.
## turns out there's not a straightforward way to
## double or position legends built using the lattice
## 'key' argument or grid.legend.  the code below works,
## but it's a bit hacky...
for (k in 1:length(legend_params)) {
    for (l in 1:length(legend_params[[1]])) {
        grid.text(label = legend_params[[k]]$names[l],
                  x = legend_params[[k]]$x_positions[l],
                  y = legend_params[[k]]$y_positions[l],
                  default.units = "in",
                  just = "left",
                  gp = gpar(col = "black", cex = 1))
        grid.lines(x = c(legend_params[[k]]$line_x1[l],
                         legend_params[[k]]$line_x2[l]),
                   y = c(legend_params[[k]]$y_positions[l],
                         legend_params[[k]]$y_positions[l]),
                   default.units = "in",
                   gp = gpar(lwd = 4, lineend = "butt",
                             col = legend_params[[k]]$color[l]))
    }
}

## replace improper y label positioning w/ custom text
## and double it since we've split the plot into 2 panels
grid.text(label = "Density",
          x = c(0.15, 0.15),
          y = c(7.5, 2),
          rot = 90,
          default.units = "in",
          gp = gpar(col = "black", cex = 1.25)
          )

dev.off()
}

## <<example_density_plot_trp_met_final>>
## grab a set of reporters that illustrate
## the deletion phenotypes.  for now, we'll
## use Met and Trp TFTs for this purpose.
out_tw <- out_all[out_all$reporter == "Met TFT" | out_all$reporter == "Trp TFT", ]

{
pdf(file = "~/Desktop/2021.01.29_example_density_2_panel_new_colors.pdf", height = 8, width = 5)
print(
densityplot(~ TFT_ratio | reporter,
            groups = strain_rep,
            data = out_tw,
            xlim = c(-8, 1.5),
            ## set alternating = F for one side, same side labeling
            scales = list(alternating = 1,
                          tck = c(1, 0)),
            grid = T,
            plot.points = F,
            lwd = 2,
            as.table = F,
            ylab = ",",
            xlab = "log2 TFT ratio",
            par.settings = list(strip.background = list(col = gray(0.9)),
                                clip = list(panel = FALSE),
                                par.main.text = list(font = 2,
                                                     cex = 1.25,
                                                     just = "center", 
                                                     x = grid::unit(7, "in")),
                                par.sub.text = list(font = 2,
                                                    just = "center",
                                                    cex = 1.25,
                                                    x = grid::unit(7.05, "in"),
                                                    y = grid::unit(5.95, "in")),
                                axis.text = list(cex = 1),
                                par.ylab.text = list(cex = 1.25,
                                                     col = "white"),
                                par.xlab.text = list(cex = 1.25)),
            panel = function(x, y, q, subscripts, ...) {
                panel.grid(h = -1, v = -1)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = out_tw$strain_rep,
                                  subscripts = subscripts,
                                  as.table = T,
                                  lty = 1,
                                  col = rep_cols,
                                  lwd = 0.75)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = out_tw$strain,
                                  subscripts = subscripts,
                                  as.table = t,
                                  lty = 1,
                                  lwd = 2,
                                  col = all_cols,
                                  ylim = c(0, 2))
            })
)
## this gets placed outside the 'print' call
## write out a legend using 'grid.text' and 'grid.lines'
## because I separate the 2 N-end pathways, doubling
## the legend makes for a better visual layout.
## turns out there's not a straightforward way to
## double or position legends built using the lattice
## 'key' argument or grid.legend.  the code below works,
## but it's a bit hacky...
## legend parameters
## drop everything for building a custom legend
## into a list.  loop over the list by position
## ('top' or 'bottom') and strain to make 2
## legends in the panels 
ex_top_legend_params <- list()
ex_top_legend_params$names <- c("BY", "RM",
                                expression(paste("BY rpn4", Delta)), 
                                expression(paste("BY ubr1", Delta)), 
                                expression(paste("BY doa10", Delta)))
## starting point of the lines in 'x'
ex_top_legend_params$line_x1     <- rep(0.9, 5)
## endind position of the lines in 'x'
ex_top_legend_params$line_x2     <- rep(1.25, 5)    
## position of the text in x - rep this 5 times for 5 strains
ex_top_legend_params$x_positions <- rep(x = 1.35, times = 5)
## position of the text in x - rep this 5 times for 5 strains
ex_top_legend_params$y_positions <- rev(seq(from = 6.55, to = 7.25, length.out = 5))
ex_top_legend_params$color       <- all_cols
ex_bot_legend_params <- ex_top_legend_params
ex_top_legend_params$y_positions <- rev(seq(from = 3.1, to = 3.85, length.out = 5))
ex_legend_params <- list(ex_top_legend_params, ex_bot_legend_params)
for (k in 1:length(ex_legend_params)) {
    for (l in 1:length(ex_legend_params[[1]])) {
        grid.text(label = ex_legend_params[[k]]$names[l],
                  x = ex_legend_params[[k]]$x_positions[l],
                  y = ex_legend_params[[k]]$y_positions[l],
                  default.units = "in",
                  just = "left",
                  gp = gpar(col = "black", cex = 1))
        grid.lines(x = c(ex_legend_params[[k]]$line_x1[l],
                         ex_legend_params[[k]]$line_x2[l]),
                   y = c(ex_legend_params[[k]]$y_positions[l],
                         ex_legend_params[[k]]$y_positions[l]),
                   default.units = "in",
                   gp = gpar(lwd = 4, lineend = "butt",
                             col = ex_legend_params[[k]]$color[l]))
    }
}
## replace improper y label positioning w/ custom text
## and double it since we've split the plot into 2 panels
grid.text(label = "Density",
          x = c(0.2, 0.2),
          y = c(2.3, 5.7),
          rot = 90,
          gp = gpar(cex = 1.25),
          default.units = "in")
dev.off()
}


## <<strip_plots>>
## these plots are built by extracting the mean/median
## of each biological replicate of each strain.  Thus,
## we reduce 10,000 observations of a replicate to a
## single value.  w/ 8 biological replicates per strain,
## we can make a nice stripplot of strain * reporter
## for the different parameters.  We'll also use this
## to make a levelplot/heatmap

## 'aggregate' creates a new dataframe from x by applying FUN to
## all unique combinations of the factors supplied to the 'by'
## argument - in this case, grab the mean of numeric data and
## keep everything else a factor 
out_agg <- aggregate.data.frame(x = out_all,
                                by = list(out_all$strain,
                                          out_all$reporter,
                                          out_all$replicate),
                            FUN = function(x) {
                                ifelse(is.numeric(x), mean(x), as.factor(x))
                            })

## 'aggregate' seems to strip the levels from factors, so add
## these back using the values present in the original dataframe
out_agg$strain <- factor(out_agg$strain,
                     levels = unique(out_agg$strain),
                     labels = levels(out_all$strain))

out_agg$reporter <- factor(out_agg$reporter,
                     levels = unique(out_agg$reporter),
                     labels = levels(out_all$reporter))

out_agg$strain_rep <- factor(out_agg$strain_rep,
                             levels = unique(out_agg$strain_rep),
                             labels = levels(out_all$strain_rep))

## need a color vector that maps to strains that's the
## length of levels(strain) * levels(replicate) (usually 40)
out_agg_cols <- vector()
for (i in 1:nrow(out_agg)) {
    out_agg_cols[i] <- all_cols[out_agg$strain[i] == names(all_cols)]
}


{
pdf(file = "~/Desktop/2021.01.20_strip_full_final_no_Z.pdf", height = 14.5, width = 14)
print(
stripplot(TFT_ratio ~ strain | reporter,
          data = out_agg,
          col = gray(0),
          fill = out_agg_cols,
          pch = 21,
          cex = 1.1,
          scales = list(alternating = 3,
                        x = list(labels = c("BY", "RM",
                         expression(paste("BY rpn4", Delta)), 
                         expression(paste("BY ubr1", Delta)), 
                         expression(paste("BY doa10", Delta))),
                         rot = 45)),
          layout = c(4, 5),
          grid = T,
          main = list(label = "Arg/N-end Reporters"),
          sub = list(label = "Ac/N-end Reporters"),
          between = list(x = c(0, 0, 0),
                         y = c(0, 0, 3)),
          as.table = T,
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.main.text = list(font = 2,
                                                   cex = 1.25,
                                                   just = "center", 
                                                   x = grid::unit(7, "in"),
                                                   y = grid::unit(13, "in")),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.25,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(6.25, "in")),
                              axis.text = list(cex = 1),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.25)),
          jitter.data = T,
          ## factor for jittering
          factor = 1.5,
          index.cond = list(aa_order),
          horizontal = F)
)

## main title, not sure why this doesn't show up otherwise
## probably some par setting re: going outside the grid....
grid.text(label = "Arg/N-end Reporters",
          x = 7.0,
          y = 14.2,
          default.units = "in",
          gp = gpar(cex = 1.25, font = 2))

## y axis labels for the strip
grid.text(label = "log2 TFT ratio",
          x = c(0.15, 0.15),
          y = c(7.75, 2.25),
          rot = 90,
          default.units = "in",
          gp = gpar(col = "black", cex = 1.25)
          )
dev.off()
}


## let's try to convert to Z scores 
i <- 1

out_z <- list()
reporter <- levels(out_agg$reporter)
for (i in 1:length(reporter)) {
    
    z_mean <- mean(out_agg$TFT_ratio[out_agg$reporter == reporter[i]])
    z_sd   <- sd(out_agg$TFT_ratio[out_agg$reporter == reporter[i]])
    z_out  <- function(x) { ((x - z_mean) / (z_sd))  }
    out_subset <- out_agg[out_agg$reporter == reporter[i], ]
    
    for (j in 1:nrow(out_subset)) {
        out_subset$zTFT[j] <- z_out(out_subset$TFT_ratio[j])
        out_z[[i]] <- out_subset
}}

out_z <- do.call("rbind", out_z)
range(out_z$zTFT)

new_aa_order <- c(2, 3, 4, 6, 7, 9, 10, 11, 12, 14, 18, 19, 1, 5, 8, 13, 15, 16, 17, 20)
out_z$r_order <- factor(out_z$reporter,
                        levels = levels(out_z$reporter)[rev(new_aa_order)])

out_z$t_order <- factor(out_z$reporter,
                        levels = levels(out_z$reporter)[rev(aa_order)])

## aggregate into a smaller data frame for the actual heatmap
out_m <- aggregate.data.frame(x = out_z,
                               by = list(out_z$strain,
                                         out_z$reporter),
                               FUN = function(x) {
                                   ifelse(is.numeric(x), mean(x), as.factor(x))
                               })

out_m$strain <- factor(out_m$strain,
                        levels = unique(out_m$strain),
                        labels = levels(out_all$strain))

out_m$reporter <- factor(out_m$reporter,
                          levels = unique(out_m$reporter),
                          labels = levels(out_all$reporter))

out_m$r_order <- factor(out_m$reporter,
                        levels = levels(out_m$reporter)[rev(new_aa_order)])

out_m$t_order <- factor(out_m$reporter,
                        levels = levels(out_m$reporter)[rev(aa_order)])


hm_cols <- rev(brewer.pal(n = 11, name = "PiYG"))

{
pdf(file = "~/Desktop/2021.01.20_TFT_heat_final.pdf", height = 14, width = 6)
print(
levelplot(zTFT ~ strain * t_order,
          strip = T,
          xlab = "normalized TFT score",
          ylab = "Reporter",
          data = out_m,
          pretty = T,
          col.regions = hm_cols,
          ylab.right = "Z score",
          scales = list(alternating = F,
                        x = list(labels = c("BY", "RM",
                                            expression(paste("BY rpn4", Delta)), 
                                            expression(paste("BY ubr1", Delta)), 
                                            expression(paste("BY doa10", Delta))),
                                 rot = 45),
                        ## scales only on left/bottom
                        tck = c(1, 0)),
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.25,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(6.25, "in")),
                              layout.heights = list(xlab.key.padding = 1),
                              layout.widths = list(left.padding = 5),
                              axis.text = list(cex = 1.25),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.25)), 
##          col.regions = gray(level = 29:0/29),
          at = seq(from = -2, to = 2, length.out = 10),
          colorkey = list(at = seq(from = -2, to = 2, length.out = 11),
                          cex = 1.25,
                          title = "normalized TFT score",
                          space = "bottom",
                          columns = 1,
                          row = 10),
          border = gray(0.3),
          as.table = T,
          ## index.cond = list(aa_order),
          border.lwd = 2)
)
## Ac/N-end reporter lines
grid.lines(x = c(0.65, 0.65),
           y = c(2.4, 6.42),
           default.units = "in",
           gp = gpar(lwd = 2, col = gray(0.4)))
## Ac/N-end reporter text
grid.text(x = 0.3, y = 4.41,
          label = "Ac/N-end\nReporters",
          default.units = "in",
          rot = 90,
          gp = gpar(cex = 1.25))
## type I Arg/N-end reporter lines
grid.lines(x = c(0.65, 0.65),
           y = c(9.83, 13.25),
           default.units = "in",
           gp = gpar(lwd = 2, col = gray(0.4)))
## type I Arg/N-end reporter text
grid.text(x = 0.3, y = 11.5,
          label = "Type I Arg/N-end\nReporters",
          default.units = "in",
          rot = 90,
          gp = gpar(cex = 1.25))
## type II Arg/N-end reporter lines
grid.lines(x = c(0.65, 0.65),
           y = c(6.95, 9.25),
           default.units = "in",
           gp = gpar(lwd = 2, col = gray(0.4)))
## type II Arg/N-end reporter text
grid.text(x = 0.3, y = 8.1,
          label = "Type II Arg/N-end\nReporters",
          default.units = "in",
          rot = 90,
          gp = gpar(cex = 1.25))
dev.off()
}


## <<Z_score_stripplot_final>>
{
pdf(file = "~/Desktop/2021.01.20_z_strip_full_final.pdf", height = 14.5, width = 14)
print(
stripplot(zTFT ~ strain | reporter,
          data = out_z,
          col = gray(0),
          fill = out_agg_cols,
          pch = 21,
          cex = 1.1,
          scales = list(alternating = 3,
                        x = list(labels = c("BY", "RM",
                         expression(paste("BY rpn4", Delta)), 
                         expression(paste("BY ubr1", Delta)), 
                         expression(paste("BY doa10", Delta))),
                         rot = 45)),
          layout = c(4, 5),
          grid = T,
          main = list(label = "Arg/N-end Reporters"),
          sub = list(label = "Ac/N-end Reporters"),
          between = list(x = c(0, 0, 0),
                         y = c(0, 0, 3)),
          as.table = T,
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.main.text = list(font = 2,
                                                   cex = 1.25,
                                                   just = "center", 
                                                   x = grid::unit(7, "in"),
                                                   y = grid::unit(13, "in")),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.25,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(6.25, "in")),
                              axis.text = list(cex = 1),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.25)),
          jitter.data = T,
          ## factor for jittering
          factor = 1.5,
          index.cond = list(aa_order),
          horizontal = F)
)
## main title, not sure why this doesn't show up otherwise
## probably some par setting re: going outside the grid....
grid.text(label = "Arg/N-end Reporters",
          x = 7.0,
          y = 14.2,
          default.units = "in",
          gp = gpar(cex = 1.25, font = 2))
## y axis labels for the strip
grid.text(label = "normalized TFT score",
          x = c(0.15, 0.15),
          y = c(10.17, 3.9),
          rot = 90,
          default.units = "in",
          gp = gpar(col = "black", cex = 1.25)
          )
dev.off()
}


## <<horizontal_N-end_heatmap>>
## 1. reverse levels on strain
out_m$strain_rev <- factor(out_m$strain,
                           levels = levels(out_m$strain)[5:1])
## 2. reverse levels on reporter
out_m$t_order_rev <- factor(out_m$t_order,
                           levels = levels(out_m$t_order)[20:1])

{
pdf(file = "~/Desktop/2021.01.20_N-end_horizontal_heatmap.pdf", height = 5, width = 14)
print(
levelplot(zTFT ~ t_order_rev * strain_rev,
          data = out_m,
          strip = T,
          ylab = "Strain",
          pretty = T,
          scales = list(alternating = F,
                        y = list(labels = c(expression(paste("BY doa10", Delta)),
                                            expression(paste("BY ubr1", Delta)),
                                            expression(paste("BY rpn4", Delta)),
                                            "RM", "BY")),
                        x = list(labels = gsub(pattern = " TFT", replacement = "",
                                               x = levels(out_m$t_order_rev)),
                                 rot = 45),
                        ## scales only on left/bottom
                        tck = c(1, 0)),
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.5,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(6.25, "in")),
                              layout.heights = list(xlab.key.padding = 1,
                                                    bottom.padding = 3),
                              layout.widths = list(left.padding = 0,
                                                   right.padding = 10),
                              axis.text = list(cex = 1.5),
                              par.ylab.text = list(cex = 1.5,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.5,
                                                   col = "white")), 
          ## at = 1 less than number of ats in colorkey
          col.regions = brewer.pal(n = 11, name = "PiYG"),
          at = seq(from = 0, to = 3.6, length.out = 10),
          colorkey = list(at = 0:9,
                          labels = as.character(format(seq(from = 0, to = 3.6, length.out = 10),
                                                       nsmall = 1)),
                          cex = 1.5,
                          title = "Normalized UPS\nPathway Activity",
                          space = "right",
                          columns = 1,
                          row = 9),
          border = gray(0.3),
          as.table = T,
          border.lwd = 2)
)
## 3. add rotated text to colorkey
grid.text(label = "Normalized UPS\nPathway Activity",
          x = 13.6,
          y = 2.98,
          default.units = "in",
          rot = 90,
          gp = gpar(cex = 1.5, font = 1))
## 4. add pathway lines 
## Type I Arg/N-end text
grid.text(label = "Type I Arg/N-end\nReporters",
          x = 3.6125,
          y = 0.35,
          default.units = "in",
          gp = gpar(cex = 1.5, font = 1))
## Type II Arg/N-end text
grid.text(label = "Type II Arg/N-end\nReporters",
          x = 6.725,
          y = 0.35,
          default.units = "in",
          gp = gpar(cex = 1.5, font = 1))
## Ac/N-end text
grid.text(label = "Ac/N-end\nReporters",
          x = 10.1,
          y = 0.35,
          default.units = "in",
          gp = gpar(cex = 1.5, font = 1))
## Type I Arg/N-end lines
grid.lines(x = c(2.05, 5.175),
          y = 0.75,
          default.units = "in",
          gp = gpar(col = gray(0), lwd = 2))
## Type II Arg/N-end lines
grid.lines(x = c(5.7, 7.75),
          y = 0.75,
          default.units = "in",
          gp = gpar(col = gray(0), lwd = 2))
## Ac/N-end lines
grid.lines(x = c(8.28, 11.92),
          y = 0.75,
          default.units = "in",
          gp = gpar(col = gray(0), lwd = 2))
dev.off()
}

## <<example_stripplots_final>>
## use met and trp for this purpose
## these will go into figure 1, but
## are just for illustration purposes...
out_x <- out_z[out_z$reporter == "Met TFT" | out_z$reporter == "Trp TFT", ]

{
pdf(file = "~/Desktop/2021.01.20_example_strip_2_panel_final.pdf", height = 8, width = 5)
print(
stripplot(zTFT ~ strain | reporter,
          data = out_x,
          col = gray(0),
          fill = out_agg_cols,
          pch = 21,
          cex = 1.25,
          scales = list(alternating = 1,
                        tck = c(1, 0),
                        x = list(labels = c("BY", "RM",
                         expression(paste("BY rpn4", Delta)), 
                         expression(paste("BY ubr1", Delta)), 
                         expression(paste("BY doa10", Delta))),
                         rot = 45)),
          layout = c(1, 2),
          grid = T,
          as.table = F,
          jitter = T,
          factor = 1.7,
          ylab = "Z-score",
          xlab = "Strain",
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.main.text = list(font = 2,
                                                   cex = 1.25,
                                                   just = "center", 
                                                   x = grid::unit(7, "in"),
                                                   y = grid::unit(13, "in")),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.25,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(6.25, "in")),
                              axis.text = list(cex = 1.25),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.25)),
          horizontal = F)
)
grid.text(label = "normalized TFT score",
          x = c(0.2, 0.2),
          y = c(2.75, 5.85),
          rot = 90,
          gp = gpar(cex = 1.25),
          default.units = "in")
dev.off()
}


## <<BY_RM_plot>>
## nrow(out_agg) = 800, so 300 should be BY or RM 
out_by_rm <- grepl(pattern = "[BR][YM]",
                   x = as.character(out_agg$strain))

out_br <- out_agg[out_by_rm, ]

out_br_cols <- vector()

for (i in 1:nrow(out_br)) {
out_br_cols[i] <- all_cols[out_br$strain[i] == names(all_cols)]
}

{
pdf(file = "~/Desktop/2021.01.20_by_rm_final.pdf", height = 14.5, width = 14)
print(
## need to make a TFT ratio amino acid index 
stripplot(TFT_ratio ~ strain | reporter,
          data = out_br,
          type = c("g", "p"),
          col = gray(0),
          fill = out_br_cols,
          pch = 21,
          cex = 1.1,
          scales = list(alternating = 3,
                        x = list(labels = c("BY", "RM"))),
          layout = c(4, 5),
          grid = T,
          main = list(label = "Arg/N-end Reporters"),
          sub = list(label = "Ac/N-end Reporters"),
          between = list(x = c(0, 0, 0),
                         y = c(0, 0, 3)),
          as.table = T,
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.main.text = list(font = 2,
                                                   cex = 1.25,
                                                   just = "center", 
                                                   x = grid::unit(7, "in"),
                                                   y = grid::unit(13, "in")),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.25,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(5.95, "in")),
                              axis.text = list(cex = 1),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.25)),
          jitter.data = T,
          ## factor for jittering
          factor = 1.5,
          index.cond = list(aa_order),
          horizontal = F)
)
## main title, not sure why this doesn't show up otherwise
## probably some par setting re: going outside the grid....
grid.text(label = "Arg/N-end Reporters",
          x = 7.0,
          y = 14.2,
          default.units = "in",
          gp = gpar(cex = 1.25, font = 2))

## y axis labels for the strip
grid.text(label = "log2 TFT ratio",
          x = c(0.15, 0.15),
          y = c(7.45, 1.85),
          rot = 90,
          default.units = "in",
          gp = gpar(col = "black", cex = 1.25))
dev.off() 
}
#+END_SRC

* DONE 2021.01.20 -All QTL Peaks Heatmap
  :LOGBOOK:
  - State "DONE"       from              [2021-01-20 Wed 14:46]
  :END:
#+BEGIN_SRC R :tangle ~/Desktop/N-end_QTL_heatmap.R
## -----
## <<2021.01.09>>
## code to make a heatmap of QTL peaks across multiple reporters 

## -----
## <<heatmap_setup>>
## ifelse to determine which system we're on
## if not on home machine, assume msi
system   <- Sys.info()["nodename"]
base_dir <- "~/data/illumina/"
## determine if we're on msi; set wd appropriately 
base_dir <- ifelse(system != "mahlon-linux",
                   "/home/albertf/mahlon/data/illumina/",
                   base_dir)

#############
## USER INPUT
#############
## set the specific directory you'll work 
## in and name the comparison table
## TRAILING SLASH AT END OF DIR
## below, your project, e.g.,
## "2020.08.17_FPFA002_TDH3pr_Arg_N-end_TFT_sorts/"
proj           <- "2020.10.30_all_UPS_rdata/peaks/merged_delta_AF_peak_tables/"
proj_dir       <- paste0(base_dir, proj)
peaks_table    <- read.table(file = paste0(proj_dir, "all_merged_peaks.csv"),
                             sep = ",", header = T)
#################
## END USER INPUT
#################


## -----
## <<avg_peak_table>>
## now make a table of the average LOD, delta_AF, and peak 
## positions that we'll use to construct the heatamp 
avg_table <- data.frame(reporter = peaks_table$reporter,
                        chr = peaks_table$chr,
                        LOD = (peaks_table$rep_1_LOD + peaks_table$rep_2_LOD) / 2,
                        delta_AF = (peaks_table$rep_1_delta_AF + peaks_table$rep_2_delta_AF) / 2,
                        left_Index = (peaks_table$rep_1_left_Index + peaks_table$rep_2_left_Index) / 2,
                        max_Index = (peaks_table$rep_1_max_Index + peaks_table$rep_2_max_Index) / 2 ,
                        right_Index = (peaks_table$rep_1_right_Index + peaks_table$rep_2_right_Index) / 2)

## write out the averaged table
write.table(x = avg_table,
            file = paste0(proj_dir, "averaged_merged_all_peaks_table.csv"),
            append = F, quote = F, sep = ",",
            row.names = F, col.names = T)

## -----
## <<common_functions_code_
## needed tables, files, etc....
## SNPs is a giant table w/ SNP positions 
SNPs           <- read.table("~/QTL_scripts/SNPs_Maggie_170809_BY_positions.txt",
                             stringsAsFactors=FALSE,
                             head=FALSE)

## as of 8/31/17, the SNPs seem not to be fully
## filtered and are out of sorting order
## I think the next section duplicates this code
## w/o the loop.  Frank's comment suggests he
## thinks the 'for' loop isn't working, but I
## think it is.  Does Maggie's code fix it?
## I guess not, given the dates.  
for (thisChr in unique(SNPs[,1])){
    SNPs[SNPs[,1] == thisChr, 2] <- sort(SNPs[SNPs[,1] == thisChr, 2])
}
SNPs <- rbind(SNPs[SNPs[, 1] == "chrI", ],
              SNPs[SNPs[, 1] == "chrII", ],
              SNPs[SNPs[, 1] == "chrIII", ],
              SNPs[SNPs[, 1] == "chrIV", ],
              SNPs[SNPs[, 1] == "chrV", ],
              SNPs[SNPs[, 1] == "chrVI", ],
              SNPs[SNPs[, 1] == "chrVII", ],
              SNPs[SNPs[, 1] == "chrVIII", ],
              SNPs[SNPs[, 1] == "chrIX", ],
              SNPs[SNPs[, 1] == "chrX", ],
              SNPs[SNPs[, 1] == "chrXI", ],
              SNPs[SNPs[, 1] == "chrXII", ],
              SNPs[SNPs[, 1] == "chrXIII", ],
              SNPs[SNPs[, 1] == "chrXIV", ],
              SNPs[SNPs[, 1] == "chrXV", ],
              SNPs[SNPs[, 1] == "chrXVI", ])

library("lattice")
library("latticeExtra")
library("RColorBrewer")
library("grid")

## check for Bioconductor and install if not available
ifelse(!requireNamespace("BiocManager", quietly = TRUE),
       install.packages("BiocManager",
                        dependencies = TRUE,
                        repos = "http://cran.wustl.edu/",
                        quiet = TRUE),
       paste0("Bioconductor available"))
require("BiocManager")

bioc_package_installer <- function(x){if(!requireNamespace(x))
                                          BiocManager::install(x,
                                                               INSTALL_opts = '--no-lock')}
bioc_package_installer("VariantAnnotation")

library("VariantAnnotation")
source("~/QTL_scripts/gTest.R")
source("~/QTL_scripts/x_qtl_seq_functions_170831.R")
source("~/QTL_scripts/mp_JB_170901.R")
source("~/QTL_scripts/peaksFromVector.R")
("~/QTL_scripts/chr_cutoffs.Rdata")
load("~/QTL_scripts/chr_labels.Rdata")

## data frame with all yeast genes, plus
## chr, pos., strand, and names 
geneInfo <- read.table("~/QTL_scripts/ensemblGenes_ensembl83_160307_MOD.txt",
                       stringsAsFactors=FALSE,
                       sep="\t",
                       header=TRUE)
## rownames become systemtatic names 
rownames(geneInfo) <- geneInfo[,"geneID"]
## "geneName" is the common name, e.g., 'HOG1'
## for some (many?) rows of 'geneInfo', there
## is no 'geneName', so it's just an empty string
## e.g., head(allNames)
allNames <- geneInfo[, "geneName"]

names(allNames) <- geneInfo[,1]
allNames[which(allNames == "")] <- names(allNames)[which(allNames == "")]
allNamesInv <- names(allNames)
names(allNamesInv) <- allNames

sepBetweenChr <- 0
trimFromEnd   <- 15e3
obsMin        <- 10
LoessSpan     <- 0.1
## same as in Albert 2014
AF_thres       <- 0.09653124
## multipool LOD threshold, our usual value 
multi_thres    <- 4.5


## -----
## <<heatmap_setup>>
## build a dummy dataframe to drop QTLs into
## ~120 bins if you use 100 kb windows for the map

## read in chr lengths
## need this for building the heatmap
chr_lengths <- read.table("~/QTL_scripts/sacCer3ChromLengths.txt", header = F)

## don't need mitochondrial chromosome 
chr_lengths <- chr_lengths[1:16, ]

## add the gcoords and numeric (not roman) chromosomes:
chr_lengths$chr <- 1:16
chr_lengths$gcoords <- getGcoords(chr = 1:16,
                                  pos = chr_lengths$chr,
                                  spacing = sepBetweenChr)
chr_lengths <- chr_lengths[, c(3, 1, 2, 4)]
names(chr_lengths) <- c("chr", "chr_r", "length", "gcoords")

## <<build_heatmap_dataframe>>
k <- 1
reporters <- levels(avg_table$reporter)

final <- list()
for (k in 1:length(reporters)) {    

## make a list of 16 containing the chr and bin as a dataframe
## have to round up the chr lengths so the bins are all the same
## size (1e5 bp)

## we need to make an extra bin for ea. chromosome, since the
## lengths don't end in 1e5 multiples.  'round_up' allows you
## to do this using a multiple of your choice.
## So, chrI = 230218 bp and round_up(230218, 1e5) = 3e5
round_up <- function(from, to) {
    ceiling(from / to) * to
    }

round_down <- function(from, to) {
    floor(from / to) * to
    }    

## assign each bin to the correct chromosome
chr_indices <- unlist(sapply(X = 1:16, FUN = function(x) {
                                 rep(x,
                                     times = length(seq(from = 1e5,
                                                        to = round_up(chr_lengths$length[x],
                                                                      to = 1e5),
                                                        by = 1e5)))
                      }))

## create chromosome bins - this will serve as a conditioning factor
bins <- seq(from = 1e5,
            to = length(chr_indices) * 1e5,
            by = 1e5)

## when we assign peaks to bins, we need to add the length of
## all preceding chromosomes plus the peak position.  we'll use
## the bin lengths, not the chromosome lengths for this purpose.
## so, a QTL on chrII at base 150 = 3e5 (length of chr I bins) + 150
bin_sums <- c(0, unlist(sapply(X = 2:16, FUN = function(x) {
                              max(bins[chr_indices == x - 1])
                              })))

## assign the peaks for ea. reporter to a dataframe 
out <- avg_table[avg_table$reporter == reporters[k], ]

## assign each peak a bin for the heatmap 
for (b in 1:nrow(out)) {
    out$bin[b] <- round_down(from = out$max_Index[b] + bin_sums[out$chr[b]],
                             to = 1e5)
}

## dummy dataframe that contains all bins    
chr_bins <- data.frame(reporter = rep(reporters[k], length(bins)),
                       chr = chr_indices,
                       LOD = rep(0, length(bins)),
                       delta_AF = rep(0, length(bins)),
                       left_Index = rep(0, length(bins)),
                       max_Index = rep(0, length(bins)),
                       right_Index = rep(0, length(bins)),
                       bin = bins)

## the bins above aren't exact, so assign them to one
## of the bins we defined using 'which.min'
## assign peaks to bins via 'which.min'
for (r in 1:nrow(out)) {
    ind <- out$chr[r]
    chrs <- chr_bins$bin[chr_bins$chr == ind & chr_bins$bin > out$bin[r]]
    out$bin[r] <- chrs[which.min(abs(out$bin[r] - chrs))]
}

## if there's a peak, replace the current row with the peak row
## if not, just leave everything at 0
for (n in 1:nrow(chr_bins)) {
    test <- min(abs(chr_bins[n, "bin"] - out$bin))
    ind  <- which.min(abs(chr_bins[n, "bin"] - out$bin))
    chr_bins[n, ] <- if(test == 0) out[ind, ] else chr_bins[n, ]
}

## assign the dataframe w/ each peak and peak bin position to a list
## that we'll collapse after we've run through all the reporters 
final[[k]] <- chr_bins
}

## collapse output to a single frame
test <- do.call("rbind", final)

## remove the "_" from the factor level
levels(test$reporter) <- gsub(pattern = "_", replacement = " ",
                              x = levels(test$reporter))

## square root transform LOD scores for better visualization
test$LOD_mult <- test$delta_AF / abs(test$delta_AF)

## make the LOD negative if the high - low BY allele frequency < 1
## 2021.01.20 - this doesn't really work and won't be in the final
## heatmap 
for (i in 1:length(test$LOD_mult)) {
    test$LOD_mult[i] <- if(is.nan(test$LOD_mult[i]) == T) 0 else test$LOD_mult[i]
    }

test$sq_LOD <- sqrt(test$LOD) * test$LOD_mult

## <<alphabetical_order>>
## put the amino acids in alphabetical order,
## but also split by pathway (Arg/N-end vs. Ac/N-end)
## have to reverse it due to the way lattice plots
## Arg/N-end: arg, asn, asp, gln, glu, his, ile, leu, lys, phe, trp, tyr
## Ac/N-end: ala, cys, gly, met, pro, ser, thr, val
aa_order  <- c(2, 3, 4, 6, 7, 9, 10, 11, 12, 14, 18, 19, 1, 5, 8, 13, 15, 16, 17, 20)
## aa_order[order(aa_order)] == 1:20
test$aa_factor <- factor(test$reporter,
                    levels = levels(test$reporter)[rev(aa_order)])
## levels(test$aa_factor)

## <<type_I_II_order>>
## still alphabetical, but w/ Arg/N-end
## split by type I vs II ubr1 rec site
## type I  = arg asn asp gln glu his lys 
## type II = ile leu phe trp tyr 
## Ac/N-end: ala, cys, gly, met, pro, ser, thr, val
type_order <- c(2, 3, 4, 6, 7, 9, 12, 10, 11, 14, 18, 19, 1, 5, 8, 13, 15, 16, 17, 20)
## type_order[order(type_order)] == 1:20
## levels(test$reporter)[type_order]
test$type_factor <- factor(test$reporter,
                           levels = levels(test$reporter)[rev(type_order)])
## levels(test$type_factor)

## <<dynamic_range_order>>
## timer dynamic range order (high to low):
## Arg/N-end: asn, trp, asp, phe, tyr, lys, arg, his, gln, ile, leu, glu
## Ac/N-end: cys, met, pro, val, ser, thr, ala, gly
deg_order <- c(3, 18, 4, 14, 19, 12, 2, 9, 6, 10, 11, 7, 5, 13, 15, 20, 16, 17, 1, 8)
test$deg_factor <- factor(test$reporter,
                          levels = levels(test$reporter)[rev(deg_order)])
## deg_order[order(deg_order)] == 1:20
## levels(test$reporter)[deg_order]

## position where the labels for the x axis (chr) go
chr_labels <- sapply(X = 1:16, FUN = function(x) {
                         mean(test$bin[test$chr == x])
                     })

## position where the dividing lines on the x axis go
chr_cutoffs <- sapply(X = 1:15, FUN = function(x) {
                          max(test$bin[test$chr == x]) + 5e4
})


sq_LOD_ats  <- c(seq(from = -16, to = -2, length.out = 4),
                 seq(from = 2, to = 16, length.out = 4))
sq_LOD_cols <- c(brewer.pal(10, "RdBu")[1:4],
                 "white", 
                 brewer.pal(10, "RdBu")[7:10])

## pdf(file = "~/Desktop/LOD_type_ordered.pdf", height = 7, width = 14)
##  print(

##      levelplot(sq_LOD ~ bin * type_factor,
##                data = test,
##                ylab = "reporter",
##                xlab = "chromosome",
##                col.regions = sq_LOD_cols,
##                at = sq_LOD_ats,
##                ## col.regions = gray(level = 29:0/29),
##                colorkey = list(col = sq_LOD_cols,
##                                at = 0:7,
##                                labels = as.character(c(15, 10, 5, 2, 2, 5, 10, 15))),
##                scales = list(x = list(at = chr_labels,
##                                       alternating = F,
##                                       labels = as.roman(1:16),
##                                       tck = c(1, 0))),
##                panel = function(...){
##                    panel.levelplot(...)
##                    panel.abline(v = chr_cutoffs,
##                                 lty = 1, col = gray(0.4))
##                    panel.abline(h = c(8.5, 13.5),
##                                 lty = 1, col = gray(0.4))
##                })



## )

##     grid.text(label = "Reporter",
##               x = 8,
##               y = 8.5,
##               rot = 90,
##               default.units = "in",
##               gp = gpar(col = "black", cex = 1.25)
##               )

## dev.off()

## this object demarcates the bins on the colorkey
## 0.075 is the smallest delta_AF value for the QTLs
delta_AF_ats  <- c(seq(from = -0.7, to = -0.075, length.out = 4),
                   seq(from = 0.075, to = 0.7, length.out = 4))
## "RdBu" is colorlbind friendly:
## display.brewer.all(colorblindFriendly = TRUE)
## "PiYG" should work for the TFT plots
## look at a palette
## display.brewer.pal(10, "RdBu")
delta_AF_cols <- c(brewer.pal(10, "RdBu")[1:4],
                   "white", 
                   brewer.pal(10, "RdBu")[7:10])
{
pdf(file = "~/Desktop/2021.01.20_delta_AF_heatmap_final.pdf",
    height = 5.5, width = 11)
print( 
levelplot(delta_AF ~ bin * type_factor,
          data = test,
          xlab = "chromosome",
          col.regions = delta_AF_cols,
          at = delta_AF_ats,
          colorkey = list(col = delta_AF_cols,
                          at = 0:7,
                          labels = as.character(c(-0.70, -0.50, -0.25, -0.075,
                                                  0.075, 0.25, 0.50, 0.70)),
                          ## reduce the height of the colorkey a bit:
                          height = 0.5,
                          title = "delta AF"),
          scales = list(x = list(at = chr_labels,
                                 tck = c(1, 0),
                                 alternating = 1,
                                 labels = as.roman(1:16)),
                        y = list(alternating = 1,
                                 tck = c(1, 0))),
          par.settings = list(layout.widths = list(left.padding = 3,
                                                   right.padding = 3.5),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white")),
          panel = function(...){
              panel.levelplot(...)
              panel.abline(v = chr_cutoffs,
                           lty = 1, col = gray(0.4))
              panel.abline(h = c(8.5, 13.5),
                           lty = 1, col = gray(0.4))
          })
)
## reporter text 
grid.text(x = rep(0.25, 3),
          y = c(4.35, 2.97, 1.6),
          label = c("Type I Arg/N-end\nReporters",
                    "Type II Arg/N-end\nReporters",
                    "Ac/N-end\nReporters"),
          default.units = "in",
          rot = 90,
          gp = gpar(cex = 0.85),
          vp = "plot_01.toplevel.vp")
## heatmap key text
grid.text(x = 10.85,
          y = 2.92,
          label = expression(paste(Delta, "Allele Frequency (High vs. Low Pool)")),
          default.units = "in",
          rot = 90,
          gp = gpar(cex = 0.85),
          vp = "plot_01.toplevel.vp")
## type I Arg/N-end reporter vertical line
grid.lines(x = c(0.5, 0.5),
           y = c(3.65, 4.95),
           default.units = "in",
           gp = gpar(col = gray(0.4), lwd = 1.5))
## type II Arg/N-end reporter vertical line
grid.lines(x = c(0.5, 0.5),
           y = c(2.55, 3.45),
           default.units = "in",
           gp = gpar(col = gray(0.4), lwd = 1.5))
## Ac/N-end reporter vertical line
grid.lines(x = c(0.5, 0.5),
           y = c(0.81, 2.35),
           default.units = "in",
           gp = gpar(col = gray(0.4), lwd = 1.5))
dev.off()
}

## find the viewport for the plot you're working on
grid.ls(viewport = T, grobs = F)

#+END_SRC

* TODO 2021.01.20 - Sort Scheme Figure
  :LOGBOOK:
  - State "TODO"       from              [2021-01-20 Wed 17:44]
  :END:

#+BEGIN_SRC R
## -----
##############
## USER INPUT:
##############

## the only things that should need to be changed for this script to work 
## no trailing '/' at the end!
base_dir <- "~/data/flow/2021.01.20_sort_figure"
setwd(base_dir)
needed_dirs <- c("/fcs", "/results", "/tables", "/scripts")
dir_maker <- function(x){
    ifelse(!dir.exists(paths = paste0("./", x)),
           dir.create(path = paste0("./", x)),
           paste0("dir ", paste0(getwd(), x), " exists_"))
}
sapply(X = needed_dirs, FUN = dir_maker)
work_dir       <- paste0(base_dir, "/fcs")
results_dir    <- paste0(base_dir, "/results")
tables_dir     <- paste0(base_dir, "/tables")

## -----
## <<Required_Packages>>
## check for Bioconductor and install if not available
ifelse(!requireNamespace("BiocManager", quietly = TRUE),
       install.packages("BiocManager",
                        dependencies = TRUE,
                        repos = "http://cran.wustl.edu/",
                        quiet = TRUE),
       paste0("Bioconductor available"))
require("BiocManager")


## -----
## load packages or install if not available
## have to split these out by bioconductor vs. non-bioconductor
## non-bioconductor
package_installer <- function(x){
    if(!requireNamespace(x, quietly = TRUE))
        install.packages(x, dependencies = TRUE,
                         repos = "http://cran.wustl.edu/",
                         quiet = TRUE, INSTALL_opts = '--no-lock')}
packages <- c("colorspace", "lattice", "ggvis", "dygraphs", "DescTools", "viridis")
sapply(X = packages, FUN = package_installer)
sapply(X = packages, FUN = require, character.only = TRUE)


## -----
## bioconductor
bioc_package_installer <- function(x){if(!requireNamespace(x))
                                          BiocManager::install(x, INSTALL_opts = '--no-lock')}
bioc_packages <-  c("flowCore", "flowViz", "flowUtils", "flowStats", "flowFP", "geneplotter", "ggcyto")
sapply(X = bioc_packages, FUN = bioc_package_installer)
sapply(X = bioc_packages, FUN = require, character.only = TRUE)


## -----
## required for merging flowsets into a single flowframe
source(file = "https://raw.githubusercontent.com/mac230/flow_scripts/master/set2frame.R")


## -----
## read in the data
dat <- read.flowSet(path = work_dir,
                    min.limit = 1,
                    alter.names = T)

##-----
## <<TFT_Transformation>>
## use the transform function to get the TFT/PSV parameters we want
## start by converting 0's in fluors to 1's via truncate transform
trunc.trans   <- truncateTransform("Convert 0's to 1's.", a = 1)
trunc.fluors  <- function(x){
    transform(x,
              `GFP.A` = trunc.trans(`GFP.A`),
              `mCherry.A` = trunc.trans(`mCherry.A`))}
dat <- fsApply(x = dat, FUN = trunc.fluors)

PSV.TFT.transform <- function(x){
    transform(x,
              `log_GFP` = log10(`GFP.A`),
              `log_RFP` = log10(`mCherry.A`),
              `TFT_ratio` = log(`mCherry.A`/`GFP.A`, base = 2),
              `PSV_ratio` = log(`GFP.A`/`mCherry.A`, base = 2),
              ## 'no log' TFT ratio
              `nl_TFT_ratio` = (`mCherry.A`/`GFP.A`)
              )}

trunc.gfp <- truncateTransform("make set GFP positive", a = 2.5)
trunc.gfp.f <-  function(x){
    transform(x,
              `log_GFP` = trunc.gfp(`log_GFP`))}

dat <- fsApply(x = dat, FUN = trunc.gfp.f)

## -----
## <<FSC_Gate>>
## a function to gate the cells to include only haploids.
## we identify these as a sharp peak in the lower end of
## the fsc density plot.  I take 10% above and below the
## max density value
fsc.gate.generator <- function(x){
    fsc.dens  <- density(exprs(x[, 1]))
    ## return the index of the maximum y value of the density estimate
    fsc.max   <- fsc.dens[[1]][which.max(fsc.dens[[2]])]
    fsc.upper <- (fsc.max * 0.25) + fsc.max
    fsc.lower <- fsc.max - (fsc.max * 0.25)
    fsc.gate  <- c(fsc.lower, fsc.upper)
}

curv.split <- function(x){
    split(x, f = rectangleGate("FSC.A" = fsc.gate.generator(x)),
          population = "defaultRectangleGate+",
          flowSet = T, codeflowSet = T)}
curv.set <- fsApply(x = dat, FUN = curv.split)


tft.gate.generator <- function(x){
    tft.dens  <- density(exprs(x[, 15]))
    ## return the index of the maximum y value of the density estimate
    tft.max   <- tft.dens[[1]][which.max(tft.dens[[2]])]
    tft.upper <- (tft.max * 0.025) + tft.max
    tft.lower <- tft.max - (tft.max * 0.025)
    tft.gate  <- c(tft.lower, tft.upper)
}

tft.gate.generator(curv.set[[1]][[1]])

pdf(file = "~/Desktop/2021.01.25_GFP_RFP_xy_example.pdf", height = 5, width = 6)
print(
xyplot(`log_RFP` ~ `log_GFP`,
       xlim = c(1.5, 4.5),
       ylim = c(1.5, 4.5),
       data = curv.set[[1]][[1]],
       strip.text = NULL,
       smooth = F)
)
dev.off()



summary(filter(curv.set[[1]][[1]],
               tft.gate.generator(curv.set[[1]][[1]])))

dat_f <- as.data.frame(exprs(dat[[1]]))

densityplot(dat_f$TFT_ratio,
            plot.points = F,
            type = c("g", "l"),
            xlim = c(-5, 1))

xx <- density(dat_f$TFT_ratio)

{
pdf(file = "~/Desktop/2021.01.25_example_TFT_ratio_density.pdf", height = 5, width = 6)
print(
xyplot(xx$y ~ xx$x, type = c("l", "g"),
       xlab = "log2 RFP / GFP",
       ylab = "Density",
       lwd = 2.25,
       xlim = c(-5, 1),
       col = gray(0.3),
       scales = list(x = list(cex = 1.75),
                     y = list(cex = 1.75)),
       key = list(corner = c(0.01, 0.98),
                  lines = list(col = "#AA1111",
                               lty = 2, lwd = 2),
                  text = list("1% RFP / GFP\n ratio gates")),
       par.settings = list(par.ylab.text = list(cex = 1.75),
                           par.xlab.text = list(cex = 1.75)),
       panel = function(...) {
           panel.grid(h = -1, v = -1)
           panel.abline(v = c(-5:1), col = gray(0.9))
           panel.xyplot(...)
           panel.abline(v = c(-3.5, 0.5),
                        lwd = 2, lty = 2,
                        col = "#AA1111")
}))
dev.off()
}
e_dat <- as.data.frame(exprs(dat))
e_dat$TFT_ratio <- log2(e_dat$mCherry.A / e_dat$GFP.A )
densityplot(e_dat$TFT_ratio, plot.points = F, xlim = c(-2.5, 2.5),
            type = c("g", "l"))


uprint(xyplot(`SSC.A` ~ `FSC.A`, data = dat,
             filter = curv2Filter(x = "FSC.A", y = "SSC.A", bwFac = 10, gridsize = c(250,250)),
             smooth = F))


## <<figure_1_example_strip>>
ex_ubr1  <- out_z[out_z$reporter == "Cys TFT" & out_z$strain == "ubr1", ]
ex_doa10 <- out_z[out_z$reporter == "Cys TFT" & out_z$strain == "doa10", ]
ex_dat <- rbind(ex_ubr1, ex_doa10)

pdf(file = "~/Desktop/2021.01.27_example_RFP_GFP_strip.pdf", height = 5, width = 5)
print(
stripplot(TFT_ratio ~ strain,
          data = ex_dat,
          pch = 21,
          col = gray(0),
          fill = gray(0.8),
          grid = T,
          jitter = T,
          factor = 1.95,
          ylim = c(-8.2, 0.5),
          cex = 2,
          ylab = "log2 RFP / GFP",
          scales = list(x = list(labels = c("High UPS\nActivity",
                                            "Low UPS\nActivity"),
                                 cex = 1.5),
                        y = list(cex = 1.5)),
          par.settings = list(par.ylab.text = list(cex = 1.5)
                              ))
)
dev.off()


          data = out_agg,
          col = gray(0),
          fill = out_agg_cols,
          pch = 21,
          cex = 1.1,
          scales = list(alternating = 3,
                        x = list(labels = c("BY", "RM",
                         expression(paste("BY rpn4", Delta)), 
                         expression(paste("BY ubr1", Delta)), 
                         expression(paste("BY doa10", Delta))),
                         rot = 45)),
          layout = c(4, 5),
          grid = T,
          main = list(label = "Arg/N-end Reporters"),
          sub = list(label = "Ac/N-end Reporters"),
          between = list(x = c(0, 0, 0),
                         y = c(0, 0, 3)),
          as.table = T,
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.main.text = list(font = 2,
                                                   cex = 1.25,
                                                   just = "center", 
                                                   x = grid::unit(7, "in"),
                                                   y = grid::unit(13, "in")),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.25,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(6.25, "in")),
                              axis.text = list(cex = 1),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.25)),
          jitter.data = T,
          ## factor for jittering
          factor = 1.5,
          index.cond = list(aa_order),
          horizontal = F)
)
#+END_SRC

* TODO 2021.01.20 - Post-FACS Flow Analysis
  :LOGBOOK:
  - State "TODO"       from              [2021-01-20 Wed 17:45]
  :END:

* TODO CRISPR-Swap Flow Analysis
  :LOGBOOK:
  - State "TODO"       from              [2021-02-06 Sat 19:40]
  :END:

#+BEGIN_SRC R
## -----
## load all the required packages
source("~/emacs/R/functions/load_flow_packages.R")

#############
## USER INPUT
#############
reporter_names <- c("Gln_TFT", "Asn_TFT", "Glu_TFT", "Asp_TFT",
                    "Ile_TFT", "His_TFT", "Tyr_TFT", "Trp_TFT",
                    "Leu_TFT", "Phe_TFT", "Lys_TFT", "Arg_TFT",
                    "Thr_TFT", "Met_TFT", "Pro_TFT", "Val_TFT",
                    "Gly_TFT", "Ser_TFT", "Ala_TFT", "Cys_TFT")

base_dir       <- "~/data/flow/2021.02.06_UBR1_CRISPR_swap_0663_TFT_flow_plate_002"
needed_dirs <- c("/fcs", "/results", "/tables", "/scripts",
                 "/dataframes", "/dataframes/gated", "/dataframes/ungated")
dir_maker <- function(x){
    ifelse(!dir.exists(paths = paste0(base_dir, "/", x)),
           dir.create(path = paste0(base_dir, "/", x)),
           paste0("dir ", paste0(base_dir, x), " exists."))
}
sapply(X = needed_dirs, FUN = dir_maker)
work_dir       <- paste0(base_dir, "/fcs")
results_dir    <- paste0(base_dir, "/results")
tables_dir     <- paste0(base_dir, "/tables")
frame_dir      <- paste0(base_dir, "/dataframes/")
gated_dir      <- paste0(frame_dir, "/gated/")
ungated_dir    <- paste0(frame_dir, "/ungated/")

#################
## END USER INPUT
#################


## -----
## we'll loop over all the reporter names to
## [1] read in all the fcs files for a given reporter
## [2] gate each file based on fsc
## [3] write each collection of files to a data table
## [4] add variables for downstream processing (strain/reporter names, e.g.)
k <- 8
## reporter_names[k]
for (k in 1:length(reporter_names)) {

## -----
## [x]
## name the strains based on reporter, then set
## regex for getting flowsets of the different strains
## generally, should name fcs files as follows:
## strain    - by, rm, rpn4, rpn10
## reporter  - PSV, TFT, untagged
## replicate - 001, 002, etc... per strain
## e.g., "RM_Arg_TFT_001.fcs"

## 2020.05.09
## this is my current approach to reading in files.  the idea is to
## put all the various strains I've used in the past here and filter this
## complete set to those strains present in the actual data I'm analyzing.  I
## pre-filter using 'grepl' because 'read.flowset' throws an error if any term
## you supply it doesn't match.
no_reporter  <- paste0(".*untagged.*", reporter_names[k], ".*fcs") 
by_strain    <- paste0("BY_strain.*", reporter_names[k], ".*fcs") 
rm_strain    <- paste0("RM_strain.*", reporter_names[k], ".*fcs")
ubr1_strain  <- paste0("ubr1_strain.*", reporter_names[k], ".*fcs") 
by_full      <- paste0("BY_full.*", reporter_names[k], ".*fcs") 
rm_full      <- paste0("RM_full.*", reporter_names[k], ".*fcs")
rm_pr        <- paste0("RM_pr.*", reporter_names[k], ".*fcs")
rm_ORF       <- paste0("RM_ORF.*", reporter_names[k], ".*fcs")
rm_term      <- paste0("RM_term.*", reporter_names[k], ".*fcs")

all_strains <- c(no_reporter, by_strain, rm_strain, ubr1_strain,
                 by_full, rm_full,
                 rm_pr, rm_ORF, rm_term)
                     

## 'dir' lists the contents of a directory - test whether each strain regex
## matches any files in the list produced by 'dir'.  if a match occurs, the
## value returned by 'max' will be 1, else 0.  take only the strains that
## returned a match in the 2nd step below w/ 'all.strains <- ...'
true_strains <- sapply(all_strains, function(strain){
                           as.logical(max(grepl(pattern = strain,
                                                x = dir(path = work_dir,
                                                        pattern = ".*.fcs",
                                                        include.dirs = F,
                                                        ignore.case = T,
                                                        recursive = F,
                                                        no.. = T))))
                       })

all_strains <- as.list(all_strains[true_strains])

all_set     <- lapply(all_strains, function(strain){
                          read.flowSet(files = NULL,
                                       path = work_dir,
                                       pattern = strain,
                                       alter.names = T,
                                       min.limit = 1)
                      })
## str(all_set[[1]]@phenoData@data$name)

name_list <- strsplit(x = names(true_strains)[true_strains == T],
                      split = "\\.\\*")

names(all_set) <- unlist(lapply(X = name_list, FUN = function(x) {
                                    x[1] }))

## -----
## <<Color_Setup>>
## linking colors to strain names in R
## I think I should be able to make something
## akin to an lisp association list where
## there is a strain name and associated color
col_untagged    <- c(color = gray(0.7), name = "no reporter")
col_by_strain   <- c(color = "blue", name = ".*BY_strain.*")
col_rm_strain   <- c(color = "red", name = ".*RM_strain.*")
col_ubr1_strain <- c(color = "darkcyan", name = ".*ubr1_strain.*")
col_by_full     <- c(color = "blueviolet", name = ".*BY_full.*")
col_rm_full     <- c(color = "brown4", name = ".*RM_full.*")
col_rm_pr       <- c(color = "deeppink3", name = ".*RM_pr.*")
col_rm_ORF      <- c(color = "forestgreen", name = ".*RM_ORF.*")
col_rm_term     <- c(color = "yellow4", name = ".*RM_term.*")

cols_list    <- list(col_untagged, col_by_strain, col_rm_strain, col_ubr1_strain,
                     col_by_full, col_rm_full,
                     col_rm_pr, col_rm_ORF, col_rm_term)

col_out <- sapply(X = cols_list, FUN = function(x){
                      grepl(pattern = x["name"],
                            x = name_list)
                  })

col_out <- as.logical(unlist(sapply(1:ncol(col_out),
                                    FUN = function(x){
                                        max(col_out[, x])
                                    })))

all_cols <- unlist(sapply(X = cols_list[col_out],
                          FUN = function(x){identity(x["color"])}))

names(all_cols) <- names(all_set)

## output a dummmy plot to assess strain/color mapping
## setwd(results.dir)
## pdf(file = "color_mapping.pdf", height = 7, width = 7, bg = "transparent")
barplot(rep(4, length(name_list)), col = all_cols, ylim = c(0, 7))
box()
legend(x = "topleft", legend = names(all_set),
       lty = 1, lwd = 7.5, col = all_cols,
       bg = "white")
legend(x = "topright", y = NA,
       legend = unlist(lapply(X = cols_list, FUN = function(x){identity(x)["name"]})),
       col = unlist(lapply(X = cols_list, FUN = function(x){identity(x)["color"]})),
       lty = 1, lwd = 7.5,  bg = "white")
## dev.off()


## a function to gate the cells to include only haploids.
## we identify these as a sharp peak in the lower end of
## the fsc density plot.  I take 10% above and below the
## max density value
fsc_gate_generator <- function(fl_frame){
    fsc_dens  <- density(exprs(fl_frame[, 1]))
    ## return the index of the maximum y value of the density estimate
    fsc_max   <- fsc_dens[[1]][which.max(fsc_dens[[2]])]
    fsc_upper <- (fsc_max * 0.10) + fsc_max
    fsc_lower <- fsc_max - (fsc_max * 0.10)
    fsc_gate  <- c(fsc_lower, fsc_upper)
}

fsc_split <- function(x){
    split(x, f = rectangleGate("FSC.A" = fsc_gate_generator(x)),
          population = "defaultRectangleGate+",
          flowSet = T, codeflowSet = T)}

## gate all samples on FSC
fsc_set <- lapply(all_set, fsApply, fsc_split)

## convert gated samples from flowsets to flowframes 
fsc_frame <- lapply(fsc_set, function(set) {
                        lapply(set, set2Frame)
                    })

## pull dataframes from flowframes for gated and
## ungated sets of samples, then rename 
fsc_gate_exprs <- vector(mode = "list", length = length(all_set))
no_gate_exprs  <- fsc_gate_exprs

for(j in 1:length(fsc_frame)) {
    for (i in 1:length(fsc_frame[[j]])) {
        fsc_gate_exprs[[j]][[i]] <- as.data.frame(exprs(fsc_frame[[j]][[i]]))
        fsc_gate_exprs[[j]][[i]]$strain <- as.factor(names(fsc_frame[j]))
        fsc_gate_exprs[[j]][[i]]$replicate <- as.factor(i)
    }
    fsc_gate_exprs[[j]] <- do.call("rbind", fsc_gate_exprs[[j]])
} 

## bind into a single dataframe
fsc_gate_exprs <- do.call("rbind", fsc_gate_exprs)

## add transformation parameters
fsc_gate_exprs$log_GFP   <- log10(fsc_gate_exprs$eGFP.A)
fsc_gate_exprs$log_RFP   <- log10(fsc_gate_exprs$mCherry.A)
fsc_gate_exprs$TFT_ratio <- log2(fsc_gate_exprs$mCherry.A / fsc_gate_exprs$eGFP.A)
fsc_gate_exprs$reporter  <- as.factor(rep(x = gsub(pattern = "_",
                                                  replacement = " ",
                                                  x = reporter_names[k]),
                                         times = nrow(fsc_gate_exprs)))

## nested loops for the ungated data
for (j in 1:length(all_set)){
    for (i in 1:length(all_set[[j]])) {
        no_gate_exprs[[j]][[i]] <- as.data.frame(exprs(all_set[[j]][[i]]))
        no_gate_exprs[[j]][[i]]$strain <- as.factor(names(all_set[j]))
        no_gate_exprs[[j]][[i]]$replicate <- as.factor(i)
    }
    no_gate_exprs[[j]] <- do.call("rbind", no_gate_exprs[[j]])
}

## bind into a single dataframe
no_gate_exprs <- do.call("rbind", no_gate_exprs)

## add transformation parameters and reporter var
no_gate_exprs$log_GFP   <- log10(no_gate_exprs$eGFP.A)
no_gate_exprs$log_RFP   <- log10(no_gate_exprs$mCherry.A)
no_gate_exprs$TFT_ratio <- log2(no_gate_exprs$mCherry.A / no_gate_exprs$eGFP.A)
no_gate_exprs$reporter  <- as.factor(rep(x = gsub(pattern = "_",
                                                  replacement = " ",
                                                  x = reporter_names[k]),
                                         times = nrow(no_gate_exprs)))

## write the ungated data to the appropriate dir
write.table(x = no_gate_exprs,
            file = paste0(ungated_dir,
                          reporter_names[k],
                          "_all_ungated.csv"),
            append = F, sep = ",",
            quote = F, row.names = F)

## write the gated data to the appropriate dir
write.table(x = fsc_gate_exprs,
            file = paste0(gated_dir,
                          reporter_names[k],
                          "_all_gated.csv"),
            append = F, sep = ",",
            quote = F, row.names = F)

    }

## now, read each reporter's dataframe in and
## combine into a single dataframe
## generate a list of files in a directory using
## the 'dir' command, e.g.:
## dir(gated_dir)
## dir(ungated_dir)

## '_u' = ungated
out_u <- vector(mode = "list", length = length(dir(ungated_dir)))
for (o in 1:length(dir(gated_dir))) {
    out_u[[o]] <- read.table(file = paste0(ungated_dir, dir(ungated_dir)[o]),
                             header = T, sep = ",")
       }

## '_g' = gated
out_g <- vector(mode = "list", length = length(dir(gated_dir)))
for (o in 1:length(dir(gated_dir))) {
    out_g[[o]] <- read.table(file = paste0(gated_dir, dir(gated_dir)[o]),
                             header = T, sep = ",")
       }

## for the ungated set, it'll be
## 1e5 cells * 5 strains/reporter * 20 reporters = 1e7 rows
## fsc gating reduces 1e5 to ~2e4, so ~2e6 rows
## nrow(out_all) = 2284942
out_all <- do.call("rbind", out_g)
str(out_all)
levels(out_all$reporter)

## Ac/N-end alphabetized
## ala, cys, gly, met, pro, ser, thr, val
## TODO - which of these is the right order? 
aa_order <- c(2, 3, 4, 6, 7, 9, 10, 11, 12, 14, 18, 19, 1, 5, 8, 13, 15, 16, 17, 20)
## seems the above is the correct order, but keep below just in case...
## aa_order <- c(20, 17, 16, 15, 13, 8, 5, 1, 19, 18, 14, 12, 11, 10, 9, 7, 6, 4, 3, 2)

## get the strain factor in the desired order 
out_all$strain_order <- factor(out_all$strain,
                               levels = levels(out_all$strain)[c(2, 6, 8, 1, 3, 5, 4, 7)])

strain_paste <- expand.grid(unique(out_all$replicate),
                          levels(out_all$strain_order))

strain_paste <- paste0(strain_paste$Var2, "_", strain_paste$Var1)

out_all$strain_rep <- factor(paste0(out_all$strain_order, "_", out_all$replicate),
                             levels = strain_paste)

rep_cols <- unlist(lapply(X = 1:length(all_cols), FUN = function(x) {
                       rep(all_cols[x],
                           times = sum(grepl(pattern = names(all_cols[x]), 
                                             x = levels(out_all$strain_rep))))
                   }))


## [x] pathway text 
## [x] x label 
## [x] strain names in legend densityplot
## [x] strain names in stripplots 
## [x] strain names in heatmap
## [ ] parameter loop

params <- colnames(out_all)[unlist(lapply(X = out_all, FUN = is.numeric))]
params[10] <- "log2 TFT Ratio"

## <<density_plot_final>>
## have to set up parameters for a custom legend first...
## drop everything for building a custom legend
## into a list.  loop over the list by position
## ('top' or 'bottom') and strain to make 2
## legends in the panels 
top_legend_params <- list()
top_legend_params$names <- c("BY", "RM",
                         expression(paste("BY rpn4", Delta)), 
                         expression(paste("BY ubr1", Delta)), 
                         expression(paste("BY doa10", Delta)))
top_legend_params$line_x1     <- rep(0.8, 5)
top_legend_params$line_x2     <- rep(1.15, 5)    
top_legend_params$x_positions <- rep(x = 1.2, times = 5)
top_legend_params$y_positions <- rev(seq(from = 12.7, to = 13.45, length.out = 5))
top_legend_params$color       <- all_cols
bot_legend_params <- top_legend_params
top_legend_params$y_positions <- rev(seq(from = 4.75, to = 5.5, length.out = 5))
legend_params <- list(top_legend_params, bot_legend_params)

{
pdf(file = "~/Desktop/den_full_test.pdf", height = 14.5, width = 14)
print(


densityplot(~ TFT_ratio | reporter,
            groups = strain_rep,
            data = out_all,
            xlim = c(-7, 1.5),
            ## set alternating = F for one side, same side labeling
            scales = list(alternating = 3),
            grid = T,
            plot.points = F,
            lwd = 2,
            as.table = T,
            ylab = ",,",
            par.settings = list(strip.background = list(col = gray(0.9)),
                                clip = list(panel = FALSE),
                                par.main.text = list(font = 2,
                                                     cex = 1.25,
                                                     just = "center", 
                                                     x = grid::unit(7, "in")),
                                par.sub.text = list(font = 2,
                                                    just = "center",
                                                    cex = 1.25,
                                                    x = grid::unit(7.05, "in"),
                                                    y = grid::unit(5.95, "in")),
                                axis.text = list(cex = 1),
                                par.ylab.text = list(cex = 1.25,
                                                     col = "white"),
                                par.xlab.text = list(cex = 1.25)),
            ## legend = list(inside = list(fun = grid.legend,
            ##                             args = list(labels = c("BY", "RM",
            ##                                   expression(paste("BY rpn4", Delta)), 
            ##                                   expression(paste("BY ubr1", Delta)), 
            ##                                   expression(paste("BY doa10", Delta))),
            ##                                   do.lines = T,
            ##                                   nrow = 5,
            ##                                   draw = T,
            ##                                   hgap = 1,
            ##                                   vgap = 0.25,
            ##                                   gp = gpar(col = all_cols,
            ##                                             lwd = 5,
            ##                                             cex = 1,
            ##                                             lineend = "butt",
            ##                                             npc = 50
            ##                                                   )))),
            ## key = list(text = list(c("BY", "RM",
            ##                           expression(paste("BY rpn4", Delta)),
            ##                           expression(paste("BY ubr1", Delta)),
            ##                           expression(paste("BY doa10", Delta)))),
            ##             lines = list(col = all_cols,
            ##                          lwd = 5),
            ##            corner = c(0, 1),
            ##            y = 0.98),
            panel = function(x, y, q, subscripts, ...) {
                panel.grid(h = -1, v = -1)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = out_all$strain_rep,
                                  subscripts = subscripts,
                                  as.table = T,
                                  lty = 1,
                                  col = rep_cols,
                                  lwd = 0.75)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = out_all$strain,
                                  subscripts = subscripts,
                                  as.table = t,
                                  lty = 1,
                                  lwd = 1.5,
                                  col = all_cols,
                                  ylim = c(0, 2))
            })

)
## <<plot_legend>>
## this gets placed outside the 'print' call
## write out a legend using 'grid.text' and 'grid.lines'
## because I separate the 2 N-end pathways, doubling
## the legend makes for a better visual layout.
## turns out there's not a straightforward way to
## double or position legends built using the lattice
## 'key' argument or grid.legend.  the code below works,
## but it's a bit hacky...
for (k in 1:length(legend_params)) {
    for (l in 1:length(legend_params[[1]])) {
        grid.text(label = legend_params[[k]]$names[l],
                  x = legend_params[[k]]$x_positions[l],
                  y = legend_params[[k]]$y_positions[l],
                  default.units = "in",
                  just = "left",
                  gp = gpar(col = "black", cex = 1))
        grid.lines(x = c(legend_params[[k]]$line_x1[l],
                         legend_params[[k]]$line_x2[l]),
                   y = c(legend_params[[k]]$y_positions[l],
                         legend_params[[k]]$y_positions[l]),
                   default.units = "in",
                   gp = gpar(lwd = 4, lineend = "butt",
                             col = legend_params[[k]]$color[l]))
    }
}

## replace improper y label positioning w/ custom text
## and double it since we've split the plot into 2 panels
grid.text(label = "Density",
          x = c(0.15, 0.15),
          y = c(7.5, 2),
          rot = 90,
          default.units = "in",
          gp = gpar(col = "black", cex = 1.25)
          )

dev.off()
}


## <<example_density_plot_trp_met_final>>
## grab a set of reporters that illustrate
## the deletion phenotypes.  for now, we'll
## use Met and Trp TFTs for this purpose.
out_tw <- out_all[out_all$reporter == "Met TFT" | out_all$reporter == "Trp TFT", ]

{
pdf(file = "~/Desktop/example_density_2_panel.pdf", height = 8, width = 5)
print(
densityplot(~ TFT_ratio | reporter,
            groups = strain_rep,
            data = out_tw,
            xlim = c(-8, 1.5),
            ## set alternating = F for one side, same side labeling
            scales = list(alternating = 1,
                          tck = c(1, 0)),
            grid = T,
            plot.points = F,
            lwd = 2,
            as.table = F,
            ylab = ",",
            xlab = "log2 TFT ratio",
            par.settings = list(strip.background = list(col = gray(0.9)),
                                clip = list(panel = FALSE),
                                par.main.text = list(font = 2,
                                                     cex = 1.25,
                                                     just = "center", 
                                                     x = grid::unit(7, "in")),
                                par.sub.text = list(font = 2,
                                                    just = "center",
                                                    cex = 1.25,
                                                    x = grid::unit(7.05, "in"),
                                                    y = grid::unit(5.95, "in")),
                                axis.text = list(cex = 1),
                                par.ylab.text = list(cex = 1.25,
                                                     col = "white"),
                                par.xlab.text = list(cex = 1.25)),
            panel = function(x, y, q, subscripts, ...) {
                panel.grid(h = -1, v = -1)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = out_tw$strain_rep,
                                  subscripts = subscripts,
                                  as.table = T,
                                  lty = 1,
                                  col = rep_cols,
                                  lwd = 0.75)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = out_tw$strain,
                                  subscripts = subscripts,
                                  as.table = t,
                                  lty = 1,
                                  lwd = 1.5,
                                  col = all_cols,
                                  ylim = c(0, 2))
            })
)
## this gets placed outside the 'print' call
## write out a legend using 'grid.text' and 'grid.lines'
## because I separate the 2 N-end pathways, doubling
## the legend makes for a better visual layout.
## turns out there's not a straightforward way to
## double or position legends built using the lattice
## 'key' argument or grid.legend.  the code below works,
## but it's a bit hacky...
## legend parameters
## drop everything for building a custom legend
## into a list.  loop over the list by position
## ('top' or 'bottom') and strain to make 2
## legends in the panels 
ex_top_legend_params <- list()
ex_top_legend_params$names <- c("BY", "RM",
                                expression(paste("BY rpn4", Delta)), 
                                expression(paste("BY ubr1", Delta)), 
                                expression(paste("BY doa10", Delta)))
## starting point of the lines in 'x'
ex_top_legend_params$line_x1     <- rep(0.9, 5)
## endind position of the lines in 'x'
ex_top_legend_params$line_x2     <- rep(1.25, 5)    
## position of the text in x - rep this 5 times for 5 strains
ex_top_legend_params$x_positions <- rep(x = 1.35, times = 5)
## position of the text in x - rep this 5 times for 5 strains
ex_top_legend_params$y_positions <- rev(seq(from = 6.55, to = 7.25, length.out = 5))
ex_top_legend_params$color       <- all_cols
ex_bot_legend_params <- ex_top_legend_params
ex_top_legend_params$y_positions <- rev(seq(from = 3.1, to = 3.85, length.out = 5))
ex_legend_params <- list(ex_top_legend_params, ex_bot_legend_params)
for (k in 1:length(ex_legend_params)) {
    for (l in 1:length(ex_legend_params[[1]])) {
        grid.text(label = ex_legend_params[[k]]$names[l],
                  x = ex_legend_params[[k]]$x_positions[l],
                  y = ex_legend_params[[k]]$y_positions[l],
                  default.units = "in",
                  just = "left",
                  gp = gpar(col = "black", cex = 1))
        grid.lines(x = c(ex_legend_params[[k]]$line_x1[l],
                         ex_legend_params[[k]]$line_x2[l]),
                   y = c(ex_legend_params[[k]]$y_positions[l],
                         ex_legend_params[[k]]$y_positions[l]),
                   default.units = "in",
                   gp = gpar(lwd = 4, lineend = "butt",
                             col = ex_legend_params[[k]]$color[l]))
    }
}
## replace improper y label positioning w/ custom text
## and double it since we've split the plot into 2 panels
grid.text(label = "Density",
          x = c(0.2, 0.2),
          y = c(2.3, 5.7),
          rot = 90,
          gp = gpar(cex = 1.25),
          default.units = "in")
dev.off()
}



## <<strip_plots>>
## these plots are built by extracting the mean/median
## of each biological replicate of each strain.  Thus,
## we reduce 10,000 observations of a replicate to a
## single value.  w/ 8 biological replicates per strain,
## we can make a nice stripplot of strain * reporter
## for the different parameters.  We'll also use this
## to make a levelplot/heatmap

## 'aggregate' creates a new dataframe from x by applying FUN to
## all unique combinations of the factors supplied to the 'by'
## argument - in this case, grab the mean of numeric data and
## keep everything else a factor 
out_agg <- aggregate.data.frame(x = out_all,
                                by = list(out_all$strain_order,
                                          out_all$reporter,
                                          out_all$replicate),
                            FUN = function(x) {
                                ifelse(is.numeric(x), mean(x), as.factor(x))
                            })

## 'aggregate' seems to strip the levels from factors, so add
## these back using the values present in the original dataframe
out_agg$strain_order <- factor(out_agg$strain_order,
                               levels = unique(out_agg$strain_order),
                               labels = levels(out_all$strain_order))

out_agg$reporter <- factor(out_agg$reporter,
                     levels = unique(out_agg$reporter),
                     labels = levels(out_all$reporter))

out_agg$strain_rep <- factor(out_agg$strain_rep,
                             levels = unique(out_agg$strain_rep),
                             labels = levels(out_all$strain_rep))


## need a color vector that maps to strains that's the
## length of levels(strain) * levels(replicate) (usually 40)
out_agg_cols <- vector()
for (i in 1:nrow(out_agg)) {
    out_agg_cols[i] <- all_cols[out_agg$strain_order[i] == names(all_cols)]
}


stripplot(TFT_ratio ~ strain_order | reporter,
          data = out_agg,
          col = gray(0),
          fill = out_agg_cols,
          pch = 21,
          jitter.data = T,
          factor = 1.5,
          horizontal = F)

aov_out <- aov(out_agg$TFT_ratio ~ out_agg$strain_order)
PostHocTest(x = aov_out,
            method = "lsd",
            conf.level = 0.95)

{
pdf(file = "~/Desktop/strip_full_test.pdf", height = 14.5, width = 14)
print(
stripplot(TFT_ratio ~ strain | reporter,
          data = out_agg,
          col = gray(0),
          fill = out_agg_cols,
          pch = 21,
          cex = 1.1,
          scales = list(alternating = 3,
                        x = list(labels = c("BY", "RM",
                         expression(paste("BY rpn4", Delta)), 
                         expression(paste("BY ubr1", Delta)), 
                         expression(paste("BY doa10", Delta))),
                         rot = 45)),
          layout = c(4, 5),
          grid = T,
          main = list(label = "Arg/N-end Reporters"),
          sub = list(label = "Ac/N-end Reporters"),
          between = list(x = c(0, 0, 0),
                         y = c(0, 0, 3)),
          as.table = T,
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.main.text = list(font = 2,
                                                   cex = 1.25,
                                                   just = "center", 
                                                   x = grid::unit(7, "in"),
                                                   y = grid::unit(13, "in")),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.25,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(6.25, "in")),
                              axis.text = list(cex = 1),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.25)),
          jitter.data = T,
          ## factor for jittering
          factor = 1.5,
          index.cond = list(aa_order),
          horizontal = F)
)

## main title, not sure why this doesn't show up otherwise
## probably some par setting re: going outside the grid....
grid.text(label = "Arg/N-end Reporters",
          x = 7.0,
          y = 14.2,
          default.units = "in",
          gp = gpar(cex = 1.25, font = 2))

## y axis labels for the strip
grid.text(label = "log2 TFT ratio",
          x = c(0.15, 0.15),
          y = c(7.75, 2.25),
          rot = 90,
          default.units = "in",
          gp = gpar(col = "black", cex = 1.25)
          )
dev.off()
}


## let's try to convert to Z scores 
i <- 1

out_z <- list()
reporter <- levels(out_agg$reporter)
for (i in 1:length(reporter)) {
    
    z_mean <- mean(out_agg$TFT_ratio[out_agg$reporter == reporter[i]])
    z_sd   <- sd(out_agg$TFT_ratio[out_agg$reporter == reporter[i]])
    z_out  <- function(x) { ((x - z_mean) / (z_sd))  }
    out_subset <- out_agg[out_agg$reporter == reporter[i], ]
    
    for (j in 1:nrow(out_subset)) {
        out_subset$zTFT[j] <- z_out(out_subset$TFT_ratio[j])
        out_z[[i]] <- out_subset
}}

out_z <- do.call("rbind", out_z)
range(out_z$zTFT)

out_z$r_order <- factor(out_z$reporter,
                        levels = levels(out_z$reporter)[rev(aa_order)])

## works, but we don't use this....
levelplot(zTFT ~ strain * r_order,
          strip = T,
          xlab = "Strain",
          ylab = "Reporter",
          data = out_z,
          pretty = T,
          scales = list(alternating = F,
                        x = list(labels = c("BY", "RM",
                                            expression(paste("BY rpn4", Delta)), 
                                            expression(paste("BY ubr1", Delta)), 
                                            expression(paste("BY doa10", Delta))),
                                 rot = 45)),
          col.regions = gray(level = 29:0/29),
          at = seq(from = -2, to = 2.1, length.out = 30),
          colorkey = list(at = seq(from = -2, to = 2.1, length.out = 30)),
          border = gray(0.3),
          as.table = T,
          ## index.cond = list(aa_order),
          border.lwd = 2)



## aggregate into a smaller data frame for the actual heatmap
out_m <- aggregate.data.frame(x = out_z,
                               by = list(out_z$strain,
                                         out_z$reporter),
                               FUN = function(x) {
                                   ifelse(is.numeric(x), mean(x), as.factor(x))
                               })

out_m$strain <- factor(out_m$strain,
                        levels = unique(out_m$strain),
                        labels = levels(out_all$strain))

out_m$reporter <- factor(out_m$reporter,
                          levels = unique(out_m$reporter),
                          labels = levels(out_all$reporter))


range(out_m$zTFT)

out_m$r_order <- factor(out_m$reporter,
                        levels = levels(out_m$reporter)[rev(aa_order)])



{
pdf(file = "~/Desktop/heat_test.pdf", height = 14, width = 6)
print(
levelplot(zTFT ~ strain * r_order,
          strip = T,
          xlab = "normalized TFT score",
          ylab = "Reporter",
          data = out_m,
          pretty = T,
          ylab.right = "Z score",
          scales = list(alternating = F,
                        x = list(labels = c("BY", "RM",
                                            expression(paste("BY rpn4", Delta)), 
                                            expression(paste("BY ubr1", Delta)), 
                                            expression(paste("BY doa10", Delta))),
                                 rot = 45),
                        ## scales only on left/bottom
                        tck = c(1, 0)),
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.25,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(6.25, "in")),
                              layout.heights=list(xlab.key.padding=1),
                              axis.text = list(cex = 1.25),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.25),
                              list(layout.widths = list(axis.key.padding = 0, 
                                                        ylab.right = 2))), 
##          col.regions = gray(level = 29:0/29),
          at = seq(from = -2, to = 2, length.out = 30),
          colorkey = list(at = seq(from = -2, to = 2, length.out = 30),
                          cex = 1.25,
                          title = "normalized TFT score",
                          space = "bottom",
                          columns = 1,
                          row = 10),
          border = gray(0.3),
          as.table = T,
          ## index.cond = list(aa_order),
          border.lwd = 2)
)
## Ac/N-end reporter lines
grid.lines(x = c(0.32, 0.32),
           y = c(2.4, 6.42),
           default.units = "in",
           gp = gpar(lwd = 2, col = gray(0)))
## Ac/N-end reporter text
grid.text(x = 0.15, y = 4.41,
          label = "Ac/N-end Reporters",
          default.units = "in",
          rot = 90,
          gp = gpar(cex = 1.25))
## Arg/N-end reporter lines
grid.lines(x = c(0.32, 0.32),
           y = c(6.95, 13.25),
           default.units = "in",
           gp = gpar(lwd = 2, col = gray(0)))
## Arg/N-end reporter text
grid.text(x = 0.15, y = 10.1,
          label = "Arg/N-end Reporters",
          default.units = "in",
          rot = 90,
          gp = gpar(cex = 1.25))
dev.off()
}


## <<Z_score_stripplot_final>>
{
pdf(file = "~/Desktop/z_strip_full_test.pdf", height = 14.5, width = 14)
print(
stripplot(zTFT ~ strain | reporter,
          data = out_z,
          col = gray(0),
          fill = out_agg_cols,
          pch = 21,
          cex = 1.1,
          scales = list(alternating = 3,
                        x = list(labels = c("BY", "RM",
                         expression(paste("BY rpn4", Delta)), 
                         expression(paste("BY ubr1", Delta)), 
                         expression(paste("BY doa10", Delta))),
                         rot = 45)),
          layout = c(4, 5),
          grid = T,
          main = list(label = "Arg/N-end Reporters"),
          sub = list(label = "Ac/N-end Reporters"),
          between = list(x = c(0, 0, 0),
                         y = c(0, 0, 3)),
          as.table = T,
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.main.text = list(font = 2,
                                                   cex = 1.25,
                                                   just = "center", 
                                                   x = grid::unit(7, "in"),
                                                   y = grid::unit(13, "in")),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.25,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(6.25, "in")),
                              axis.text = list(cex = 1),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.25)),
          jitter.data = T,
          ## factor for jittering
          factor = 1.5,
          index.cond = list(aa_order),
          horizontal = F)
)
## main title, not sure why this doesn't show up otherwise
## probably some par setting re: going outside the grid....
grid.text(label = "Arg/N-end Reporters",
          x = 7.0,
          y = 14.2,
          default.units = "in",
          gp = gpar(cex = 1.25, font = 2))
## y axis labels for the strip
grid.text(label = "normalized TFT score",
          x = c(0.15, 0.15),
          y = c(10.17, 3.9),
          rot = 90,
          default.units = "in",
          gp = gpar(col = "black", cex = 1.25)
          )
dev.off()
}

## <<example_stripplots_final>>
## use met and trp for this purpose
## these will go into figure 1, but
## are just for illustration purposes...
out_x <- out_z[out_z$reporter == "Met TFT" | out_z$reporter == "Trp TFT", ]

{
pdf(file = "~/Desktop/example_strip_2_panel.pdf", height = 8, width = 5)
print(
stripplot(zTFT ~ strain | reporter,
          data = out_x,
          col = gray(0),
          fill = out_agg_cols,
          pch = 21,
          cex = 1.25,
          scales = list(alternating = 1,
                        tck = c(1, 0),
                        x = list(labels = c("BY", "RM",
                         expression(paste("BY rpn4", Delta)), 
                         expression(paste("BY ubr1", Delta)), 
                         expression(paste("BY doa10", Delta))),
                         rot = 45)),
          layout = c(1, 2),
          grid = T,
          as.table = F,
          jitter = T,
          factor = 1.7,
          ylab = "Z-score",
          xlab = "Strain",
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.main.text = list(font = 2,
                                                   cex = 1.25,
                                                   just = "center", 
                                                   x = grid::unit(7, "in"),
                                                   y = grid::unit(13, "in")),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.25,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(6.25, "in")),
                              axis.text = list(cex = 1.25),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.25)),
          horizontal = F)
)
grid.text(label = "normalized TFT score",
          x = c(0.2, 0.2),
          y = c(2.75, 5.85),
          rot = 90,
          gp = gpar(cex = 1.25),
          default.units = "in")
dev.off()
}

## no longer using this, as the TFT score colorkey
## goes on the bottom, but might want to come back to this later...
## TFT_hm$legend$right <- 
##     list(fun = mergedTrellisLegendGrob(TFT_hm$legend$right, 
##                                        list(fun = textGrob, 
##                                             args = list("Z score", 
##                                                         rot = 90,
##                                                         gp = gpar(cex = 1.25))), 
##                                        vertical = FALSE))

## <<BY_RM_plot>>
## nrow(out_agg) = 800, so 300 should be BY or RM 
out_by_rm <- grepl(pattern = "[BR][YM]",
                   x = as.character(out_agg$strain))

out_br <- out_agg[out_by_rm, ]

out_br_cols <- vector

for (i in 1:nrow(out_br)) {
out_br_cols[i] <- all_cols[out_br$strain[i] == names(all_cols)]
}

{
pdf(file = "~/Desktop/by_rm_test.pdf", height = 14.5, width = 14)
print(
## need to make a TFT ratio amino acid index 
stripplot(TFT_ratio ~ strain | reporter,
          data = out_br,
          type = c("g", "p"),
          col = gray(0),
          fill = out_br_cols,
          pch = 21,
          cex = 1.1,
          scales = list(alternating = 3,
                        x = list(labels = c("BY", "RM"))),
          layout = c(4, 5),
          grid = T,
          main = list(label = "Arg/N-end Reporters"),
          sub = list(label = "Ac/N-end Reporters"),
          between = list(x = c(0, 0, 0),
                         y = c(0, 0, 3)),
          as.table = T,
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.main.text = list(font = 2,
                                                   cex = 1.25,
                                                   just = "center", 
                                                   x = grid::unit(7, "in"),
                                                   y = grid::unit(13, "in")),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.25,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(5.95, "in")),
                              axis.text = list(cex = 1),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.25)),
          jitter.data = T,
          ## factor for jittering
          factor = 1.5,
          index.cond = list(aa_order),
          horizontal = F)
)
## main title, not sure why this doesn't show up otherwise
## probably some par setting re: going outside the grid....
grid.text(label = "Arg/N-end Reporters",
          x = 7.0,
          y = 14.2,
          default.units = "in",
          gp = gpar(cex = 1.25, font = 2))

## y axis labels for the strip
grid.text(label = "log2 TFT ratio",
          x = c(0.15, 0.15),
          y = c(7.45, 1.85),
          rot = 90,
          default.units = "in",
          gp = gpar(col = "black", cex = 1.25))
dev.off() 
}


## TODO 
## - [1] add reporter variable and transforms (GFP, RFP, TFT)
## - [2] extract replicate mean/media parameters
##       + possibly as separate frames, though maybe not necessary
reporter_var <- as.factor(gsub(pattern = "_",
                               replacement = " ",
                               x = reporter_name))


## working plots
## 5 plots by strain, split by replciates
densityplot(~ TFT_ratio | strain,
            data = fsc_gate_exprs,
            groups = replicate,
            layout = c(5, 1),
            plot.points = F,
            auto.key = list(space = "right"))

## single plot split by strain
densityplot(~ TFT_ratio,
            groups = strain,
            data = fsc_gate_exprs,
            plot.points = F,
            auto.key = list(space = "right"))

## strain by replicate heat map (but cols scaled wrong)
levelplot(TFT_ratio ~ strain * replicate,
          data = fsc_gate_exprs,
          border = gray(0.9),
          border.lwd = 4,
          scales = list(x=list(rot=45)),
          aspect = "iso") 

## single row heatmap
levelplot(TFT_ratio ~ strain * sample_id,
          data = fsc_gate_exprs,
          border = gray(0.9),
          border.lwd = 4,
          scales = list(x=list(rot=45)),
          aspect = "iso")

## recall that you can summarize trellis objects 
## and view high-level information about them:
t_obj <- densityplot(~ TFT_ratio | strain,
            data = fsc_gate_exprs,
            groups = replicate,
            layout = c(5, 1),
            plot.points = F,
            auto.key = list(space = "right"))
summary(t_obj)
## and plot
print(t_obj)

## 2D plot allow conditioning via x ~ y formulas
## these nicely show no relationship betw. FSC and TFT ratio
xyplot(TFT_ratio ~ FSC.A | strain,
       data = fsc_gate_exprs)
xyplot(TFT_ratio ~ FSC.A | strain,
       data = no_gate_exprs)

## no strong relationship betw. GFP and TFT ratio either 
xyplot(TFT_ratio ~ log_GFP | strain,
       data = fsc_gate_exprs)

## TFT ratio directly related to RFP
xyplot(TFT_ratio ~ log_RFP | strain,
       data = fsc_gate_exprs)
## not as much GFP
xyplot(log_RFP ~ log_GFP | strain,
       data = fsc_gate_exprs)

## this plot nicely shows that relative
## differences between strains don't
## change at various levels of FSC/SSC
a <- equal.count(no_gate_exprs$FSC.A)
plot(a)
b <- equal.count(no_gate_exprs$SSC.A)
plot(b)
f_shingle <- equal.count(no_gate_exprs$FSC.A)
densityplot(~ TFT_ratio | b,
            groups = strain,
            data = no_gate_exprs,
            plot.points = F,
            auto.key = list(col = 1))

## same plot w/ a custom shingle 
c_shingle <- equal.count(no_gate_exprs$FSC.A, number = 5, overlap = 0.1)
densityplot(~ TFT_ratio | c_shingle,
            groups = strain,
            data = no_gate_exprs,
            plot.points = F,
            auto.key = list(col = 1)) 


## nice cross-contingency table of n. cells
## per strain per replicate
xtabs(~strain + replicate,
      data = fsc_gate_exprs)

write.table(x = fsc_gate_exprs,
            file = paste0("~/Desktop/fsc_gated_", reporter_name, ".csv"),
            append = F, quote = F, sep = ",",
            row.names = F, col.names = T)


## basic example of reading in 
a <- read.table("~/Desktop/fsc_gated_rpn4_TFT.csv",
                header = T, sep = ",")
a$reporter <- as.factor(rep("Rpn4 TFT", nrow(a)))

b <- read.table("~/Desktop/fsc_gated_0662_TFT.csv",
                header = T, sep = ",")
b$reporter <- as.factor(rep("Tyr TFT", nrow(b)))

c <- rbind(a, b)

## basic levelplot conditioned on strain and reporter
levelplot(TFT_ratio ~ strain * reporter,
          data = c)


my.at=c(min(values(r)), 0,1,5,10,15,20,25,30,40,50,75,100,150,200, max(values(r)))
my.brks=seq(0, 200, by=13)

TFT_cols   <- diverging_hcl(n = 11, h = c(90, 180), c = 70, l = 90)
TFT_breaks <- seq(from = -4, to = 1, by = 0.5)
TFT_labels <- TFT_breaks

TFT_key <- list(at = TFT_breaks,
                labels = list(at = TFT_labels,
                              labels = TFT_labels),
                space = "right")

out <- levelplot(TFT_ratio ~ strain * reporter,
                 data = c,
                 colorkey = TFT_key,
                 col.regions = TFT_cols,
                 at = TFT_breaks)
print(out)


## basic density plot that compares groups w/in a 
## plot and splits reporter into separate plots
## line cols, x axis limits, and line width custom set
densityplot(~ TFT_ratio | reporter,
            groups = strain,
            data = c,
            plot.points = F,
            auto.key = list(space = "top"),
            par.settings = list(superpose.line = list(col = all_cols)),
            scales = list(alternating = F),
            lwd = 2.5,
            xlim = c(-4, 1))

str(make.groups(c$replicate, c$strain))
combn(x = letters[1:4], 2)

b$strain_rep <- as.factor(paste0(b[, "strain"], "_", b[, "replicate"]))
sr_cols <- list()
for (i in 1:length(all_cols)) {
    sr_cols[[i]] <- rep(all_cols[i], 8)
}
sr_cols <- unlist(sr_cols)

densityplot(replicate ~ TFT_ratio | reporter,
            groups = strain_rep,
            data = c,
            plot.points = F,
            auto.key = F,
            par.settings = list(superpose.line = list(col = sr_cols)),
            scales = list(alternating = F),
            lwd = 1,
            xlim = c(-4, 1))

densityplot(~ TFT_ratio | reporter,
            data = c,
            plot.points = F,
            auto.key = F,
            panel = function(x, ...){
                panel.densityplot(x = x,
                                  plot.points = F)
            },
            scales = list(alternating = F),
            lwd = 1,
            xlim = c(-4, 1))


## implement xy scatter plots
## https://rstudio-pubs-static.s3.amazonaws.com/12556_4e02f5564dc24b57b7a8f6d95d2a5cf7.html
## xyplot(y ~ z, asp = 1, panel = panel.smoothScatter, nbin = 150)
xyplot(log_RFP ~ log_GFP | reporter * strain,
       data = c,
       panel = panel.smoothScatter,
       nbin = 140,
       xlim = c(2.5, 5))

xyplot(log_RFP ~ log_GFP | reporter,
       groups = strain,
       data = c,
       pch = ".",
       cex = 2,
       nbin = 140,
       xlim = c(2.5, 5))


c$strain[1] == names(all_cols[])

c$strain_rep <- as.factor(paste0(c$strain, "_", c$replicate))



densityplot(~ TFT_ratio | reporter,
            groups = strain_rep,
            data = c,
            plot.points = F,
            xlim = c(-4, 1))


densityplot(~ TFT_ratio | reporter,
            groups = strain,
            data = c,
            xlim = c(-4, 1),
            scales = list(alternating = F),
            grid = T,
            plot.points = F,
            lwd = 2,
            col = all_cols,
            par.settings = list(strip.background = list(col = gray(0.9))),
            key = list(text = list(names(all_cols)),
                       rectangles = list(col = all_cols)))


ord <- order(c$strain)
kk <- c[ord, ]
cc <- order(names(all_cols))
all_cols <- all_cols[cc]



## 2020.11.30 - needs to incorporate the ordering above
## plus figure out a way to code the replicate colors -
## basically needs to be a repetition of each color n replciate times
## demo of using logical subsetting
## ddd$strain[1] == names(all_cols)
## regexp filter on unique(c$strain_rep)?
pdf(file = "~/Desktop/density_test.pdf", height = 5, width = 10)
print(
densityplot(~ TFT_ratio | reporter,
            groups = strain_rep,
            data = c,
            xlim = c(-4, 1.25),
            scales = list(alternating = F),
            grid = T,
            plot.points = F,
            lwd = 2,
            col = all_cols,
            par.settings = list(strip.background = list(col = gray(0.9))),
            key = list(text = list(names(all_cols[c(1, 3, 4, 5, 2)])),
                       rectangles = list(col = all_cols[c(1, 3, 4, 5, 2)])),
            panel = function(x, y, q, subscripts, ...) {
                xx <- rep(all_cols, each = 8)
                panel.grid(h = -1, v = -1)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = c$strain_rep,
                                  subscripts = subscripts,
                                  lty = 1,
                                  col = xx,
                                  lwd = 1)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = c$strain,
                                  subscripts = subscripts,
                                  lty = 1,
                                  lwd = 4,
                                  col = all_cols,
                                  ylim = c(0, 2))
            })
)
dev.off()

levelplot(TFT_ratio ~ reporter * strain,
          strip = T,
          data = c,
          pretty = T,
          border = gray(0.7),
          border.lwd = 2)
          


## basic working TFT_ratio ~ strain plot
## this shows all values, so not
## esp. useful 
stripplot(TFT_ratio ~ strain | reporter,
          data = c,
          jitter = T)

stripplot(TFT_ratio ~ strain | reporter,
          groups = strain_rep,
          data = c,
          panel = function(x, y, q, subscripts, ...) {
              panel.points( )
              panel.stripplot(x, y,
                              subscripts = subscripts,
                              groups = c$strain,
                              jitter.data = T,
                              horizontal = F,
                              factor = 2.5)
              })

ccc <- aggregate(x = c, by = list(c$strain_rep), FUN = function(x) {
          ifelse(is.numeric(x), mean(x), as.factor(x))
          })

## 'aggregate' creates a new dataframe from x by applying FUN to
## all unique combinations of the factors supplied to the 'by'
## argument - in this case, grab the mean of numeric data and
## keep everything else a factor 
ddd <- aggregate.data.frame(x = c,
                            by = list(c$strain, c$reporter, c$replicate),
                            FUN = function(x) {
                                ifelse(is.numeric(x), mean(x), as.factor(x))
                            })

## 'aggregate' seems to strip the levels from factors, so add
## these back using the values present in the original dataframe
ddd$strain <- factor(ddd$strain,
                     levels = unique(ddd$strain),
                     labels = levels(c$strain))

ddd$reporter <- factor(ddd$reporter,
                     levels = unique(ddd$reporter),
                     labels = levels(c$reporter))

## need a color vector that maps to strains that's the
## length of levels(strain) * levels(replicate) (usually 40)
ddd_cols <- vector()
for (i in 1:nrow(ddd)) {
    ddd_cols[i] <- all_cols[ddd$strain[i] == names(all_cols)]
}

## now, re-order strain to present levels in the order
## I'd like (BY, RM, rpn4, ubr1, doa10) instead of the
## default alphabetical order
ddd$out_fac <- factor(ddd$strain, levels = levels(ddd$strain)[c(1, 3, 4, 5, 2)])

pdf(file = "~/Desktop/strip_test.pdf", height = 6, width = 10)
print(
stripplot(TFT_ratio ~ out_fac | reporter,
          data = ddd,
          col = gray(0),
          fill = ddd_cols,
          pch = 21,
          cex = 1.1,
          
          scales = list(alternating = F),
          layout = c(2, 1),
          grid = T,
          par.settings = list(strip.background = list(col = gray(0.9))),
          jitter.data = T,
          ## factor for jittering
          factor = 1.25,
          horizontal = F)
)
dev.off()
expression(paste("rpn4", Delta))

rr <- colorRampPalette(c(gray(0.4), "white", "#882255"))
rr <- colorRampPalette(c("white", "#C92AA4"))
rr <- colorRampPalette(c("white", "black"))
## needs x axis label

pdf(file = "~/Desktop/heat_test.pdf", height = 4, width = 9)
print(
levelplot(TFT_ratio ~ out_fac * reporter,
          strip = T,
          xlab = "Strain",
          ylab = "Reporter",
          data = ddd,
          pretty = T,
          ## col.regions = gray(100:0/100)),
          col.regions = rr(20),
          border = gray(0.3),
          border.lwd = 2)
)
dev.off()


## adds a grid via 'type = c("g")'
xyplot(log_GFP ~ log_RFP,
       data = c,
       panel = function(x, y, ...) {
           panel.fill(col = gray(1))
           panel.grid(h = -1, v = -1,
                      col.line = gray(0.9), lwd = 1.5)
           panel.xyplot(x, y,
                        type = "p",
                        pch = ".",
                        cex = 2,
                        col.symbol = rgb(0, 0, 0, 0.01)
                      )
}
)


## you can 'rbind' the dataframes together 
## a <- data.frame(a = 1:5, b = 11:15)
## b <- data.frame(a = 6:10, b = 16:20)
## c <- rbind(a, b) ## works

#+END_SRC

# need to figure out how to plot delta symbols
# https://stats.idre.ucla.edu/r/codefragments/greek_letters/
#+BEGIN_SRC R :results graphics :file /tmp/delta.pdf
barplot(c(4,4,4), ylab = expression(paste("BY rpn4", Delta)))
#+END_SRC


* Local Variables                                                  :noexport:
Local Variables:
org-confirm-elisp-link-function: nil
End:
