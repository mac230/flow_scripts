# My notes on the use-R lattice book
file+emacs:~/foundational_books/lattice.pdf 

* Table of Contents
[[elisp:(mplink "~/foundational_books/lattice.pdf" 13)]]

[[elisp:(mplink "~/foundational_books/lattice.pdf" 49)]] - chapter 3
[[elisp:(mplink "~/foundational_books/lattice.pdf" 81)]] - chapter 5

* REVIEW Notes
file+emacs:~/foundational_books/lattice.pdf 

** All Lattice Plots
[[elisp:(mplink "~/foundational_books/lattice.pdf" 26)]]
+ all forms of lattice plots

    - histogram()   ::
    - densityplot() ::
    - qqmath()	    :: theoretrical
    - qq()	    ::
    - stripplot()   ::
    - bwplot()	    :: boxplot 
    - dotplot()	    ::
    - barchart()    ::
    - xyplot()	    ::
    - splom()	    :: all x all scatter plot matrix
    - levelplot()   :: heatmap
    - wireframe()   ::
    - cloud()	    ::
    - parallel	    :: 


[[elisp:(mplink "~/foundational_books/lattice.pdf" 46)]]
+ *critical early section on the panel function*

** Overall and Key Concepts
The structure of lattice functions is as follows:

    - [1] display type :: e.g., histogram, density plot
                          + this is the function you cal
    - [2] variable role :: dependent measure, conditioning, superpositioing
                           + conditioning = multiple panels
                           + superpositioning = all in the same plot
    - [3] aspect ratio :: height/width
                          + often have to trial and error this
                          + in lattice, can be a number (v/h)
                          + "fill" - make panels as big as possible
                          + "xy" - 45 degree banking rule
                          + "iso" - use when data have same scale
    - [4] layout :: numeric vector specifying n. columns, rows, pages
                    + don't need to supply pages arg. 
    - [5] as.table :: T means plot the first panel in the top left
                      + I think this is usually what I want
    - [6] t(trellis.obj) :: this can improve the layout of the plot 
                            + see [[tp_oats_example]]

A key concept is the 'auto.key' parameter, which specifies how the legend is
formatted.  e.g., auto.key = list(columns = 4) says use 4 columns in the
legend. 

**** Printing Multiple Plots to the Same Page
#+BEGIN_SRC R :results graphics :file /tmp/lat_page.pdf
## -----
## make several plots and put them on the same page
a <- rnorm(500, mean = 100, sd = 10)
b <- runif(n = 500, min = 10, max = 150)
c <- rcauchy(n = 500, location = 1, scale = 2)
d <- as.factor(rep(c(1, 2, 3, 4), 500/4))
dat <- data.frame(a = a, b = b, c = c, fac = d)

## first store plots as objects
library("lattice")
aplot <- densityplot(~ a | fac,
                     data = dat,
                     ref = T,
                     plot.points = F,
                     )
bplot <- densityplot(~ b | fac,
                     data = dat,
                     ref = T,
                     plot.points = F,
                     )
cplot <- densityplot(~ c | fac,
                     data = dat,
                     ref = T,
                     plot.points = F,
                     )

## now specify a layout as (x, y, nx, ny)
## put 'a' as the first plot in a row of three
## make sure to include 'newpage = F' too!
print(aplot, split = c(1, 1, 3, 1))
print(plot(bplot, split = c(2, 1, 3, 1), newpage = F))
print(plot(cplot, split = c(3, 1, 3, 1), newpage = F))

#+END_SRC

#+RESULTS:
[[file:/tmp/lat_page.pdf]]

** Tips and Tricks

    - [1] pch = "." makes nice little dots
          + works well w/ xyplot 
          + can evidently use any string for pch
            - e.g., pch = "a" also works 
          + pair w/ cex = 2 for better sizing

* 1 - Introduction
[[elisp:(mplink "~/foundational_books/lattice.pdf" 18)]]

**** 1.1 - Multipanel Conditioning
[[elisp:(mplink "~/foundational_books/lattice.pdf" 19)]]

#+BEGIN_SRC R
## -----
## load some data
## British chemical exam performance 
if(!requireNamespace("mlmRev"))
   install.packages("mlmRev")
requireNamespace("mlmRev")

library("mlmRev")
xtabs(~ score, data = Chem97)

## we'll use GCSE score to predict chem score
library("lattice")
histogram(~ gcsescore | factor(score), data = Chem97)

#+END_SRC

#+RESULTS:

In the code above, the "|" denotes the conditioning factor.  For this specific
piece of code, the dependent variable (chem exam score) actually becomes the
conditioning variable via a call to 'factor'.  

Note that multiple conditioning variables can be used: 

#+BEGIN_SRC R
if(!requireNamespace("mlmRev"))
   install.packages("mlmRev")
requireNamespace("mlmRev")
xtabs(~ score, data = Chem97)

## we'll use GCSE score to predict chem score
library("lattice")
histogram(~ gcsescore | factor(age) * factor(score), data = Chem97)

#+END_SRC

**** 1.1.3 Kernel Density Plots
[[elisp:(mplink "~/foundational_books/lattice.pdf" 21)]]
The lattice equivalent to a density plot is accessed via 'densityplot':

#+BEGIN_SRC R :results graphics :file /tmp/density.pdf
## -----
## set up a multi-conditioned density plot
if(!requireNamespace("mlmRev"))
   install.packages("mlmRev")
requireNamespace("mlmRev")

## more histogram fiddling 
library("mlmRev")
library("lattice")
histogram(~ gcsescore | factor(gender), data = Chem97)

## now do it as a density plot for comparison
## ref adds a reference line at 0
densityplot(~ gcsescore | factor(gender),
            data = Chem97,
            plot.points = F,
            ref = T)

## the actual example from the text
## ref adds a reference line at 0
print(densityplot(~ gcsescore | factor(score),
            data = Chem97,
            plot.points = F,
            ref = T))
#+END_SRC

#+RESULTS:
[[file:/tmp/density.pdf]]

** 1.2 Superposition
[[elisp:(mplink "~/foundational_books/lattice.pdf" 22)]]
This section introduces a key concept, superposition, and by doing so creates a
relevant contrast with the previous concept of conditioning:

    - [1] conditioning :: creating multiple /panels/ in a single plot across the
         various levels of some factor

    - [2] superpositing :: plotting all of the various levels of some factor in
         a single plot and distinguishing factor levels by, e.g., lty

Compare the plots below: 

#+BEGIN_SRC R :results graphics :file /tmp/super.pdf
## -----
## setup
if(!requireNamespace("mlmRev"))
    install.packages("mlmRev")
library("mlmRev")
library("lattice")
densityplot(~ gcsescore,
            data = Chem97,
            groups = score,
            plot.points = F,
            ref = T,
            auto.key = list(columns = 3))

## compare conditioning versus superposition
## use gender for conditioning; score for superposition
print(
densityplot(~ gcsescore | gender,
            data = Chem97,
            groups = score,
            plot.points = F,
            ref = T,
            auto.key = list(columns = 2))
)
## 'auto.key' sets the legend (here we specify 3 columns for it)
#+END_SRC

#+RESULTS:
[[file:/tmp/super.pdf]]

** 1.3 the "Trellis" Object
[[elisp:(mplink "~/foundational_books/lattice.pdf" 23)]]
This section deals with the need to call 'print' in order to display the results
of a lattice plot.  It contains a few additional 'under-the-hood' notes about
how R works:

    - [1] most functions in R do not produce output; instead they return an object
          + makes a distinction betw. output vs. object clearer

    - [2] lattice functions don't draw anything; they return 'trellis' objects.
      Calling print with these objects will return the graphical display, but
      more interestingly, the trellis objects themselves contain high-level
      summary information that can be viewed:

#+BEGIN_SRC R :results graphics :file /tmp/trellis.png
library("mlmRev")
library("lattice")

## make a 'trellis' object
t.obj <- densityplot(~ gcsescore | score,
                     data = Chem97,
                     groups = gender,
                     plot.points = F,
                     ref = T,
                     auto.key = list(columns = 2,
                                     space = "top",
                                     title = "score"))
                     
## a call to 'print' will display the object
## equiv. to 'plot()'
print(t.obj)
## or plot(t.obj)

## grab useful summary information from the 'trellis' object
## in particular, the contingency table is cool 
summary(t.obj)

#+END_SRC

#+RESULTS:
[[file:/tmp/trellis.png]]

The notion that lattice plots are R objects allows them to be easily and readily
put together in multiplot pages, as in the following example: 

#+BEGIN_SRC R :results graphics :file /tmp/multipanel.png
## -----
## setup
library("mlmRev")
library("lattice")

## make a 'trellis' density plot object
t1.obj <- densityplot(~ gcsescore,
                      groups = score,
                      data = Chem97,
                      plot.points = F,
                      ref = T,
                      auto.key = list(columns = 2,
                                      space = "top",
                                      title = "score"))

t2.obj <- histogram(~ gcsescore | score * gender,
                    data = Chem97,
                    )

## now do the print call and specify the layout
## so that we get both plots in the same page
print(t2.obj, split = c(1, 1, 1, 2))
print(t1.obj, split = c(1, 2, 1, 2),
      newpage = F)

#+END_SRC

#+RESULTS:
[[file:/tmp/multipanel.png]]

* 2 - A Technical Overview of Lattice
[[elisp:(mplink "~/foundational_books/lattice.pdf" 28)]]

#+BEGIN_SRC R

library("mlmRev")
library("lattice")

## make a 'trellis' density plot object
## I think for a 1D plot, you can't do x ~ y formulas
densityplot(score ~ gcsescore,
            groups = gender,
            data = Chem97,
            plot.points = F,
            ref = T,
            auto.key = list(columns = 2,
                            space = "top",
                            title = "Score",
                            lwd = 4,
                            cex = 0.75,
                            size = 4))

## but, w/ a 2D plot setup, you can do x~y: 
xyplot(score ~ gcsescore,
       groups = gender,
       data = Chem97,
       pch = 19,
       auto.key = list(columns = 2,
                       space = "top",
                       title = "Score",
                       lwd = 2,
                       cex = 0.75,
                       size = 4))

xyplot(score ~ gender,
       data = Chem97,
       pch = 19,
       auto.key = list(columns = 2,
                       space = "top",
                       title = "Score",
                       lwd = 2,
                       cex = 0.75,
                       size = 4))


#+END_SRC

**** 2.1.2 The 'data' Argument
[[elisp:(mplink "~/foundational_books/lattice.pdf" 29)]]
This section mentions that the 'data' argument:

    - [1] occurs as the second arg in high-level lattice functions
    - [2] does not have to be named (but can be)

In regards to [2], I think this would mean that you could avoid having to make
calls like "flow_object$FSC.A" and simply replace it with "FSC.A", provided you
supplied "data = flow_object" to the plot (and note how using 'data = ' makes
for cleaner axis labeling in the plots): 

#+BEGIN_SRC R :results graphics :file /tmp/data.png
library("lattice")
dat <- data.frame(x = rnorm(100, mean = 100, sd = 10),
                  y = runif(n = 100, min = 10, max = 140))

## two separate ways to plot the same data
## and notice how using 'data = ' produces a cleaner legend! 
one <- xyplot(x ~ y, data = dat)
two <- xyplot(dat$x ~ dat$y)

print(one, split = c(1, 1, 1, 2))
print(two, split = c(1, 2, 1, 2), newpage = F)

#+END_SRC

#+RESULTS:
[[file:/tmp/data.png]]

**** REVIEW 2.1.4 Shingles
[[elisp:(mplink "~/foundational_books/lattice.pdf" 30)]]
This section discusses the concept of 'shingles', which are interval bins used
to condition continuous variables.  i.e., shingles allow you to condition on a
continuous variable.  There's a nice detail on: 

[[elisp:(mplink "~/foundational_books/lattice.pdf" 31)]]
about how to create intervalic bins for shingles.  The 'equal.count' function
uses an algorithm to make bins for a continuous variate.

A nice use of this functionality would be to bin across FSC and plot the various
other parameters.  Ideally, you'd see that while the GFP and RFP levels depend
on FSC, that's not true of the TFT ratio.  

------------
/2020.11.28/
------------
I found the description of shingles in the text and the help page confusing.
The best way to understand it, I think, is to use the example code found in the
help page.  It provides tools for visualizing a shingle.  This works better than
inspecting the data from evaluating the shingle object, which isn't especially
informative.  

#+NAME: 2020.11.29_final_shingle_example_code
#+BEGIN_SRC R 
## setup
library("lattice")

###########################################################
## EQUAL.COUNT - generate shingles w/ equal count algorithm
###########################################################
## this example uses the 'equal.count' function
## to generate the shingle
## start with a continuous variable 's' that
## we'll make a shingle from 
s <- runif(n = 500, min = 0, max = 1000)
s_shingle <- equal.count(s)

## THIS IS THE MOST IMPORTANT command
## inspect the shingle graphically
plot(s_shingle)

## now make a data frame and some conditional plots
d  <- rnorm(n = 500, mean = 100, sd = 20)
f  <- as.factor(rep(1:4, length.out = length(d)))
df <- data.frame(d = d, s_shingle = s_shingle, f = f)

## boxplot conditioned on shingle and discrete factor
bwplot(~ d | s_shingle * f,
       data = df)

## some additional useful arguments to 'equal.count':
## 1. number - the number of bins
## 2. overlap - the percentage overlap between shingles
old_s_shingle <- equal.count(s)
new_s_shingle <- equal.count(s, number = 10, overlap = 0.01)
plot(new_s_shingle)

d <- rnorm(n = 500, mean = 100, sd = 20)
f <- as.factor(rep(1:4, length.out = length(d)))
df <- data.frame(d = d, new_s_shingle = new_s_shingle,
                 old_s_shingle = old_s_shingle, f = f)

## plot the new shingle w/ pre-specified n. intervals
## and % overlap between intervals 
densityplot(~ d | new_s_shingle,
            data = df,
            plot.points = F)

## notice how 'equal.count' w/o the addn. args.
## produces a cleaner result
densityplot(~ d | old_s_shingle,
            data = df,
            plot.points = F)

###########################################################
## EQUAL.COUNT - generate shingles w/ equal count algorithm
###########################################################
## syntax for this one is hard to find, but finally found some
## information.  the shingle function isn't well documented,
## but the basic idea is that w/ no interval argument supplied,
## lattice makes every possible value a level of the shingle.
## The trick to supplying levels to the shingle function is
## rbind'ing them in the syntax as shown below:

## continuous variable we'll condition on 
shingle_var   <- rnorm(500, mean = 100, sd = 20)
discrete_var  <- rep(1:4, times = length(shingle_var))
dependent_var <- runif(n = 500, min = 10, max = 200)

## now make a shingle w/ 4 intervals: 
my_shingle <- shingle(shingle_var,
                      intervals = rbind(c(10, 50),
                                        c(51, 100),
                                        c(101, 150),
                                        c(151, 200)))

## notice the summary information you get from
## this command, incl. overlap 
my_shingle

## inspect visually
plot(my_shingle)

## now make a data frame and plot
my_frame <- data.frame(discrete_var = discrete_var,
                       dependent_var = dependent_var)

densityplot(~ dependent_var | my_shingle * discrete_var,
            data = my_frame)
#+END_SRC

#+NAME: FSC_as_shingle_plot
#+BEGIN_SRC R :results graphics :file /tmp/fsc_shingle.png
## -----
## basic example of how to use a continuous variable
## as a factor in lattice plots
dep <- rnorm(500, mean = 100, sd = 10)
fac <- equal.count(runif(n = 500, min = 10, max = 210))
Fac <- as.factor(rep(c(1, 2, 3, 4), 500/4))
dat <- data.frame(dep = dep, fac = fac, Fac = Fac)

## separate panels for the continuous factor 
## multipanel plot conditioned on continuous factor 
densityplot(~ dep | fac,
            data = dat,
            ref = T,
            plot.points = F)

## multipanel plot conditioned on discrete factor 
densityplot(~ dep | Fac,
            data = dat,
            ref = T,
            plot.points = F)

## single plot split by group levels
## this doesn't work 
densityplot(~ dep,
            groups = fac,
            data = dat,
            ref = T,
            plot.points = F,
            auto.key = list(columns = 2))

## single plot split by discrete factor 
densityplot(~ dep,
            groups = Fac,
            data = dat,
            ref = T,
            plot.points = F,
            auto.key = list(columns = 2,
                            title = "Group"))


## -----
## now try it w/ some flow data
f.name <- "~/data/flow/2020.04.28_OFA0652_TDH3pr_dsRed_TFT_flow/fcs/BY_0652_dsRed_TFT_003.fcs"
fl <- read.flowSet(files = f.name,
                   min.limit = 1,
                   alter.names = T)

trunc.trans   <- truncateTransform("Convert 0's to 1's.", a = 1)
trunc.fluors  <- function(x){
    transform(x,
              `eGFP.A` = trunc.trans(`eGFP.A`),
              `DsRed.A` = trunc.trans(`DsRed.A`))}

fl <- fsApply(x = fl, FUN = trunc.fluors)

PSV.TFT.transform <- function(x){
    transform(x,
              `log_GFP` = log10(`eGFP.A`),
              `log_RFP` = log10(`DsRed.A`),
              `TFT_ratio` = log(`DsRed.A`/`eGFP.A`, base = 2),
              `PSV_ratio` = log(`eGFP.A`/`DsRed.A`, base = 2),
              ## 'no log' TFT ratio
              `nl_TFT_ratio` = (`DsRed.A`/`eGFP.A`)
              )}

fl <- fsApply(x = fl, FUN = PSV.TFT.transform)
fld <- as.data.frame(exprs(fl[[1]]))
fld$fac <- equal.count(fld$FSC.A)
str(fld)


gplot <- densityplot(~ log_GFP | fac,
                     data = fld,
                     ref = T,
                     plot.points = F)

rplot <- densityplot(~ log_RFP | fac,
                     data = fld,
                     ref = T,
                     plot.points = F)

tplot <- densityplot(~ TFT_ratio | fac,
                     data = fld,
                     ref = T,
                     plot.points = F)

plot(gplot, split = c(1, 1, 1, 3))
plot(rplot, split = c(1, 2, 1, 3),
     newpage = F)
plot(tplot, split = c(1, 3, 1, 3),
     newpage = F)

print(tplot)
#+END_SRC

#+RESULTS: FSC_as_shingle_plot
[[file:/tmp/fsc_shingle.png]]

** 2.2 Dimension and Physical Layout
[[elisp:(mplink "~/foundational_books/lattice.pdf" 31)]]

Functions used:

    - [1] xtabs :: create a contingency table of 2 or more factor levels
                   + tells you n. obs. per combination of factor levels
                   + xtabs(~var_1 + var_2, data = dataframe)
                     xtabs(~strain + replicate,
                           data = fsc_gate_exprs)

:xtabs-output:
        replicate
strain     1    2    3    4    5    6    7    8
  BY    2757 2611 2697 2458 2530 2737 2944 2629
  RM    2835 2665 2684 2612 2585 2890 2892 2741
  rpn4  2801 2593 2040 2041 2516 1879 1948 2464
  ubr1  2584 2526 3840 2411 2547 2478 2602 2730
  doa10 2750 2749 2656 2480 2594 2584 2710 3073
:END:

#+BEGIN_SRC R
if(!requireNamespace("MEMSS"))
    install.packages("MEMSS")

library("MEMSS")

tp1.oats <- xyplot(yield ~ nitro | Variety * Block,
                   data = Oats,
                   type = "o")

plot(tp1.oats)

dim(tp1.oats) ## 3 6 -> varities * 6 blocks (see next line)
dimnames(tp1.oats)

## nice cross-tab table of data
xtabs(~Variety + Block, data = Oats)

## even more summarization
summary(tp1.oats)

## we can subset elements of the the trellis object
summary(tp1.oats[, 1])
summary(tp1.oats[, 4])
summary(tp1.oats[2, 1])

print(tp1.oats[, 1]) ## or
plot(tp1.oats[, 1])
plot(tp1.oats[1 , ])

## extract a plot of a single level
plot(tp1.oats[3, 4])

## grab a subset of plots
dim(tp1.oats)
plot(tp1.oats[1:2, 3:4])
plot(tp1.oats[c(1,2), c(1,2)])
## seems they need to be contiguous though...
plot(tp1.oats[c(1,4), c(1,6)])
#+END_SRC

**** 2.2.1 Aspect Ratio
[[elisp:(mplink "~/foundational_books/lattice.pdf" 34)]]

    - [1] aspect ratio :: height/width
                          + often have to trial and error this
                          + can be a number 
                          + "xy"
                            - tries to make slope = 45°
                          + "iso"
                            - use when data have same scale

#+BEGIN_SRC R
if(!requireNamespace("MEMSS"))
    install.packages("MEMSS")

library("MEMSS")

## the "xy" argument attempts to put the slope of the lines
## in the plot on a 45 degree angle - here, with a small
## slope, the plot gets squishy
tp1.oats <- xyplot(yield ~ nitro | Variety * Block,
                   data = Oats,
                   type = "o",
                   aspect = "xy")
plot(tp1.oats)

## yeesh
tp1.oats <- xyplot(yield ~ nitro | Variety * Block,
                   data = Oats,
                   type = "o",
                   aspect = "iso")
plot(tp1.oats)

## not bad...
tp1.oats <- xyplot(yield ~ nitro | Variety * Block,
                   data = Oats,
                   type = "o",
                   aspect = 5)
plot(tp1.oats)


#+END_SRC

**** 2.2.2 Layout
[[elisp:(mplink "~/foundational_books/lattice.pdf" 35)]]
The "xy" aspect ratio is a good way to show rates of change in an xyplot, but
can lead to a squished layout.  By altering the "layout" parameter, we can get
around this issue. 

#+BEGIN_SRC R :results graphics :file /tmp/layout.png
library("lattice")
library("MEMSS")

## <<tp_oats_example>>
## start with a plot; use "xy" aspect ratio to make
## the differences across time points more clear
tp1.oats <- xyplot(yield ~ nitro | Variety + Block,
                   data = Oats,
                   type = "o",
                   aspect = "xy",
                   as.table = T)

plot(tp1.oats)

## but the plot is squished now; let's fix that.

## one option is to transpose the matrix:
plot(t(tp1.oats))
## surprisingly better!
## notice how the layout improves as well


## -----
## using the 'layout' option
## update can be used to change lattice objects
## layout sets bounds on n. panels per page
tp1.oats <- xyplot(yield ~ nitro | Variety + Block,
                   data = Oats,
                   type = "o",
                   aspect = "xy",
                   as.table = F,
                   layout = c(0, 18))

tp1.oats <- xyplot(yield ~ nitro | Variety + Block,
                   data = Oats,
                   type = "o",
                   aspect = "xy",
                   as.table = F,
                   layout = c(0, 18),
                   between = list(x = c(0, 0, 0.5),
                                  y = 0.5))

print(tp1.oats)

#+END_SRC

#+RESULTS:
[[file:/tmp/layout.png]]

** 2.3 Grouped Displays
[[elisp:(mplink "~/foundational_books/lattice.pdf" 39)]]
Here, we expand on the familiar formula call to create what is effectively an xy
plot of a continuous variable (x axis) and a discrete variable (y axis).  The
effect is to see the different values that the x axis variable takes at the
different levels of the y axis variable.  

#+BEGIN_SRC R

dotplot(variety ~ yield | site,
        data = barley,
        layout = c(1, 6),
        aspect = c(0.7),
        groups = year,
        auto.key = list(space = "top"))

#+END_SRC

** 2.4 Annotation
[[elisp:(mplink "~/foundational_books/lattice.pdf" 41)]]
There is considerable flexibility in how the legends are produced by lattice.
The main point of this section seems to be that 'auto.key' is the way to
customize a legend, rather than via explicit calls to formatting parameters.
Also of note is the mention that outside of 'auto.key', the following are
available for customizing the plot:

    - [1] xlab
    - [2] ylab
    - [3] main

A brief example of customizing a legend follows: 
#+BEGIN_SRC R :results graphics :file /tmp/leg.png
library("lattice")
library("MEMSS")
## -----
## make a legend then apply it to a lattice plot
key.variety <- list(space = "right",
                    text = list(levels(Oats$Variety)),
                    points = list(pch = 1:3,
                                  col = "black"),
                    columns = 1)

print(
xyplot(yield ~ nitro | Block,
       data = Oats,
       type = "o",
       aspect = "xy",
       groups = Variety,
       key = key.variety,
       lty = 1,
       pch = seq_along(levels(Oats$Variety)),
       col.line = "darkgrey",
       col.symbol = "black",
       xlab = "Nitrogen conc. (cwt/acre)",
       ylab = "Yield (bushels/acre)",
       main = "Yield of three varieties of oats",
       sub = "A 3 x 4 split-plot experiment with 6 blocks")
)
       
#+END_SRC

#+RESULTS:
[[file:/tmp/leg.png]]

**** 2.5.1 Scales and Axes
[[elisp:(mplink "~/foundational_books/lattice.pdf" 43)]]
The default choice for axes in a lattice plot is the smallest window that
encompasses the range of the data.  This may not produce a satisfactory plotting
result if there are large differences in range across panels, as in the
following example:

#+BEGIN_SRC R :results graphics :file /tmp/axes.png
## -----
## use the Titanic dataset
td <- as.data.frame(Titanic)

## in the default setting of scales, the x axis
## is constant across panels.  this doesn't work
## well when the number/range in the panels is
## highly divergent
barchart(Class ~ Freq | Sex + Age,
         groups = Survived,
         data = td,
         stack = T,
         layout = c(4, 1),
         auto.key = list(title = "Survived",
                         columns = 2,
                         space = "top"))

## setting the scales arg to "free" provides
## better visualization of highly variable numbers
## of observations.  notice how this example is
## particularly well-suited to this approach due to
## the fact that each panel visualizes a proportion
## through the use of stacked bars 
barchart(Class ~ Freq | Sex + Age,
         groups = Survived,
         data = td,
         stack = T,
         layout = c(4, 1),
         auto.key = list(title = "Survived",
                         columns = 2,
                         space = "top"),
         scales = list(x = "free"))

#+END_SRC

**** 2.5.2 the Panel Function
[[elisp:(mplink "~/foundational_books/lattice.pdf" 45)]]
"By convention, the name of the panel function is given by 'panel.' followed by
the name of the high-level function.  For example, the default panel function for barchart() is called panel.barchart." 

#+BEGIN_SRC R
## -----
## setup
t.bc <- barchart(Class ~ Freq | Sex + Age,
                 as.data.frame(Titanic),
                 groups = Survived,
                 stack = T,
                 layout = c(4, 1),
                 auto.key = list(title = "Survived",
                                 columns = 2),
                 scales = list(x = "free")
                 )
print(t.bc)

## calling 'update' seems to re-print the trellis obj.
update(t.bc, layout = c(1, 4))

## but the update isn't preserved if we call print ourselves
print(t.bc)

## but, the text says we can assign the updated object
u.bc <- update(t.bc, layout = c(1, 4))
print(u.bc,
      split = c(1, 1, 1, 2))
print(t.bc,
      split = c(1, 2, 1, 2),
      newpage = F)


## -----
## we can specify the panel function with a call to 'update'
update(t.bc, panel = panel.barchart)
## I think this gets at the difference between trellis objects
## and the graphics they produce.  notice that calling the
## barchart trellis object with a stripplot function leads
## to a stripplot
update(t.bc, panel = panel.stripplot)
update(t.bc, panel = panel.xyplot)
update(t.bc, panel = panel.dotplot)

#+END_SRC

**** REVIEW 2.5.3 the Panel Function Demystified
[[elisp:(mplink "~/foundational_books/lattice.pdf" 46)]]
This is a critical section.  Re-read this and be sure to understand it.

This section deals with the idea that *panel functions are themselves functions*
*and they are applied to lattice functions to generate the desired plot.*

A key concept is the notion of the "..." function argument listing.  With this
listing we can supply arguments to functions without needing to explicitly know
the name of those functions' arguments.  (can I do this w/ my own functions?).  

#+BEGIN_SRC R
## -----
## setup
t.bc <- barchart(Class ~ Freq | Sex + Age,
                 as.data.frame(Titanic),
                 groups = Survived,
                 stack = T,
                 layout = c(4, 1),
                 auto.key = list(title = "Survived",
                                 columns = 2),
                 scales = list(x = "free")
                 )
print(t.bc)


## -----
## now with a custom panel function that we use when printing
update(t.bc,
       panel = function(...){
           panel.barchart(...)
       })

## now with some actual modifications
## I think the idea here is that we call panel.barchart
## without knowing what formal arguments it requires
## (and indeed, a quick inspection of the args via
## eldoc shows we would need many args)
update(t.bc,
       panel = function(...){
           ## add vertical grid lines
           panel.grid(h = 0, v = -1)
           panel.barchart(...)
       })


update(t.bc,
       panel = function(...){
           ## add vertical grid lines
           panel.grid(h = 0, v = -1)
           panel.barchart(...,
                          ## remove box borders
                          border = "transparent")
       })


## -----
## impressively, we don't even have to call the function
## to supply these addn. args, we can just directly
## supply extra args and they get used appropriately
update(t.bc, border = "transparent")

## you can call this after, but notice how terrible it looks 
panel.grid(h = 0, v = -1)
#+END_SRC

* 3 - Visualizing Univariate Distributions
[[elisp:(mplink "~/foundational_books/lattice.pdf" 49)]]
Common distribution functions:

    - [1] CDF
          + ecdf
          + plot.ecdf

    - [2] density function
          + e.g., dnorm, dunif, etc...

    - [3] quantile function
          + qnorm, qunif, etc...
#+BEGIN_SRC R
## -----
## variations on a simple density plot

## basic version
densityplot(~ eruptions,
            data = faithful,
            plot.points = F,
            ref = T)

## change the density estimation method
densityplot(~ eruptions,
            data = faithful,
            plot.points = F,
            ref = T,
            ## kernel and bw are the parameters
            ## of the density estimate
            kernel = "rect",
            bw = 0.2)

## add the plotted points
densityplot(~ eruptions,
            data = faithful,
            plot.points = "rug",
            ref = T)

## seems we can specify how many points to use
## in the density estimate as well
## BUT THAT DOESN'T AFFECT THE RUG!!!!
densityplot(~ eruptions,
            data = faithful,
            plot.points = "rug",
            ref = T,
            kernel = "rect",
            n = 50)

densityplot(~ eruptions,
            data = faithful,
            plot.points = "rug",
            ref = T,
            n = 10)

## wide bandwidth gives a narrow density 
densityplot(~ eruptions,
            data = faithful,
            plot.points = "rug",
            ref = T,
            bw = 0.1,
            n = 200)

densityplot(~ eruptions,
            data = faithful,
            plot.points = "rug",
            ref = T,
            bw = 1,
            n = 200)

densityplot(~ eruptions,
            data = faithful,
            plot.points = "rug",
            ref = T,
            bw = 0.01,
            n = 200)

densityplot(~ eruptions,
            data = faithful,
            plot.points = "rug",
            ref = T,
            n = 200)

densityplot(~ eruptions,
            data = faithful,
            plot.points = T,
            ref = T,
            n = 200)

#+END_SRC

**** 3.2 Large Datasets
[[elisp:(mplink "~/foundational_books/lattice.pdf" 51)]]
Working with some flow data in this section: 

#+BEGIN_SRC R
## -----
## setup
library("lattice")
library("latticeExtra")

data(gvhd10)
summary(gvhd10)


## -----
## plot
fp <- densityplot(~ log(FSC.H) | Days,
                  data = gvhd10,
                  plot.points = F,
                  ref = T,
                  layout = c(2, 4),
                  )
plot(fp)

xp <- xyplot(FSC.H ~ SSC.H | Days,
             data = gvhd10,
             layout = c(2, 4))
plot(xp)

fl <- densityplot(~ log(FL4.H) | equal.count(FSC.H),
                  data = gvhd10,
                  ref = T,
                  plot.points = F
                  )
plot(fl)
#+END_SRC

**** 3.3 Histograms
[[elisp:(mplink "~/foundational_books/lattice.pdf" 53)]]
Just buries the concept of a histogram in the opening sentence of this
section....

In all seriousness, the text convincingly argues against the use of histograms
in favor of density plots for continuous variates. 

#+BEGIN_SRC R
## -----
## setup
library("lattice")
library("latticeExtra")

data(gvhd10)
summary(gvhd10)

histogram(~ log(FL1.H) | Days,
          data = gvhd10,
          xlab = "Fluorescent Parameter 1",
          type = "density",
          nint = 50,
          layout = c(2, 4)
)

#+END_SRC

**** REVIEW 3.4 Normal Q-Q Plots
[[elisp:(mplink "~/foundational_books/lattice.pdf" 54)]]
This is a explanation of the purpose of a Q-Q plot:

"Graphs quantiles of the observed data against similar quantiles of a
probability distribution conjectured to be a reasonable match.
*For a good fit, the plot is roughly linear.*"

"Q-Q plots are particularly effective because the human eye finds it easier to
perceive deviations from a straight line than from a curve."

#+BEGIN_SRC R
## -----
## notice how the plot below tests normality at all factor levels
## this would be useful, e.g., in looking at whether something like
## strains or treatment conditions BOTH have a normal distribution
library("mlmRev")
qqmath(~ gcsescore | factor(score),
       data = Chem97,
       f.value = ppoints(100))

## the variable "ppoints" indicates how many quantiles (intervals)
## to plot 
qqmath(~ gcsescore | factor(score),
       data = Chem97,
       f.value = ppoints(1000))

## add some annotation
## note that we can supply an 'aspect' arg here
qqmath(~ gcsescore | factor(score),
       data = Chem97,
       f.value = ppoints(100),
       auto.key = list(space = "right"),
       xlab = "Standard Normal Quantiles",
       ylab = "Average GCSE Score",
       aspect = "xy"
       )

qqmath(~ gcsescore | gender,
       groups = factor(score),
       data = Chem97,
       f.value = ppoints(100),
       auto.key = list(space = "right"),
       xlab = "Standard Normal Quantiles",
       ylab = "Average GCSE Score",
       aspect = "iso"
)

#+END_SRC

**** REVIEW 3.4.1 Normality and the Box-Cox Transformation
[[elisp:(mplink "~/foundational_books/lattice.pdf" 56)]]
The Box-Cox transformation is a procedure that helps normalize data according to
the transformation: 

\( f_\lambda(x) = \frac{x^\lambda -1}{\lambda} \)

The "MASS" package can compute an optimum lambda value for a transformation. 

*lot of cool stuff in this section*

#+BEGIN_SRC R :results graphics :file /tmp/box-cox.png
## -----
## setup
packs <- c("lattice", "latticeExtra", "MASS", "mlmRev")
lapply(X = packs, FUN = require, character.only = T)


## have to remove scores of 0 for the transformation
## as n/0 = Inf
chem <- subset(Chem97, gcsescore > 0)
with(chem,
     boxcox(gcsescore ~ score * gender,
            lambda = seq(0, 4, 1/10)))

## now do the transform and re-plot
chem.t <- transform(Chem97,
                    gcsescore.trans = gcsescore^2.34)
print(
qqmath(~ gcsescore.trans | gender,
       data = chem.t,
       groups = score,
       f.value = ppoints(200),
       aspect = "xy",
       auto.key = list(space = "right",
                       title = "score"),
       xlab = "Standard Normal Quantiles",
       ylab = "Transformed GCSE Score"
       ))
#+END_SRC

#+RESULTS:
[[file:/tmp/box-cox.png]]

* 5 - Scatter Plots and Extensions
[[elisp:(mplink "~/foundational_books/lattice.pdf" 81)]]

Functions used:

    - [1] xyplot :: standard xy scatter
    - [2] splom  :: scatter plot matrix

** 5.1 - the Standard Scatter Plot
[[elisp:(mplink "~/foundational_books/lattice.pdf" 81)]]
This section uses the 'quakes' example dataset:

#+NAME: first_example_defaults
#+BEGIN_SRC R

library("lattice")
xyplot(lat ~ long | cut(depth, 2),
       data = quakes)

## note that 'cut':
## divides the range of ‘x’ into intervals and codes the values
## in ‘x’ according to which interval they fall.  The leftmost
## interval corresponds to level one, the next leftmost to level two
## and so on.

cut(quakes$depth, 2)
range(quakes$depth, 2)

## basically, this makes 'depth' a two-level factor that spans 
## two intervals (notice how the output is written in interval notation)

## quakes
## 'data.frame':	1000 obs. of  5 variables:
##  $ lat     : num  -20.4 -20.6 -26 -18 -20.4 ...
##  $ long    : num  182 181 184 182 182 ...
##  $ depth   : int  562 650 42 626 649 195 82 194 211 622 ...
##  $ mag     : num  4.8 4.2 5.4 4.1 4 4 4.8 4.4 4.7 4.3 ...
##  $ stations: int  41 15 43 19 11 12 43 15 35 19 ...


#+END_SRC

#+NAME: second_example_customized
#+BEGIN_SRC R :results graphics :file /tmp/quake.pdf

library("lattice")
## add 3 levels to depth
q <- xyplot(lat ~ long | cut(depth, 3),
       data = quakes,
       aspect = "iso",
       pch = ".",
       cex = 2,
       type = c("p", "g"),
       xlab = "Longitude",
       ylab = "Latitude",
       strip = strip.custom(strip.names = T, var.name = "Depth"),
       scales = list(alternating = F))
print(q)
#+END_SRC

#+RESULTS: second_example_customized
[[file:/tmp/quake.pdf]]

#+NAME: third_example_gray_gradient
#+BEGIN_SRC R :results graphics :file /tmp/gray.pdf

library("lattice")
depth.col <- grey.colors(n = 100)[cut(quakes$depth, 100, label = F)]
depth.ord <- rev(order(quakes$depth))
xyplot(lat ~ long, 
       data = quakes[depth.ord, ],
       aspect = "iso", typ = c("p", "g"),
       col = "black", pch = 21,
       fill = depth.col[depth.ord], 
       cex = 2)

#+END_SRC

*** 5.2 - Advanced Indexing Using Subscripts
[[elisp:(mplink "~/foundational_books/lattice.pdf" 85)]]

#+BEGIN_SRC R
library("lattice")

## use the quakes dataset and make a shingle of the 
## continuous variable magnitude (earthquake magnitude)
## use 'equal.count', rather than 'cut' for this purpose
quakes$Magnitude <- equal.count(quakes$mag, 4)

depth.col    <- grey.colors(n = 100)[cut(quakes$depth, 100, label = F)]

grey.colors(n = 100)[500]

depth.ord    <- rev(order(quakes$depth))
quakes$color <- depth.col
quakes.ordered <- quakes[depth.ord, ]

length(unique(depth.col))

xyplot(lat ~ long | Magnitude,
       data = quakes.ordered, 
       col = "black", aspect = "iso", 
       fill.color = quakes.ordered$color,
       cex = 2,
       panel = function(x, y, fill.color, subscripts, ...) {
           fill <- fill.color[subscripts]
           panel.grid(h = -1, v = 1)
           panel.xyplot(x, y, pch = 21, fill = fill, ...)
},
xlab = "Longitude", ylab = "Latitude")

#+END_SRC

* 13 - Advanced Panel Functions
[[elisp:(mplink "~/foundational_books/lattice.pdf" 238)]]

* My Data
#+BEGIN_SRC R
##### OLD CODE START POINT - 2020.11.25
setwd("~/data/flow/lattice_testing/fcs/")
fl <- read.FCS(filename = "~/data/flow/lattice_testing/fcs/BY_0648_dsRed_TFT_001.fcs",
               min.limit = 1,
               alter.names = T)

fr <- read.FCS(filename = "~/data/flow/lattice_testing/fcs/RM_0649_dsRed_TFT_001.fcs",
               min.limit = 1,
               alter.names = T)


fld           <- as.data.frame(exprs(fl))
frd           <- as.data.frame(exprs(fr))

fld$strain <- rep("BY", nrow(fld))
frd$strain <- rep("RM", nrow(frd))

all <- rbind(fld, frd)
all$strain = as.factor(all$strain)

densityplot(~ eGFP.A, data = all,
            groups = strain)

<<stopping_point>>
fld$log_GFP   <- log10(fld$eGFP.A)
fld$log_RFP   <- log10(fld$DsRed.A)
fld$TFT_ratio <- log2(fld$DsRed.A/fld$eGFP.A)

xyplot(eGFP.A ~ DsRed.A,
       data = fld)

xyplot(log_GFP ~ log_RFP,
       data = fld)

dcols <- colorRampPalette(rev(rainbow(n = 10, s = 0.7, v = 0.7, alpha = 1, end = 4/6)))

xyplot(SSC.A ~ FSC.A,
       data = c,
       pch = ".",
       )

<<stopping_point>>


## no truncation of log10 fluors
fl <- transform(fl,
                `log_GFP`   = log10(`eGFP.A`),
                `log_RFP`   = log10(`DsRed.A`)
                )

densityplot(~ `log_RFP`, data = fl,
            xlim = c(0, 7))

densityplot(exprs(fl$log_RFP),
            ref = T,
            plot.points = "rug")

summary(exprs(fl$log_RFP))
xyplot(`log_RFP` ~ `log_GFP`, data = fl)

fl <- transform(fl,
                `log_GFP`   = trunc.trans(log10(`eGFP.A`)),
                `log_RFP`   = trunc.trans(log10(`DsRed.A`))
                )



summary(exprs(fl$TFT_ratio))
## plot(density(exprs(fl$TFT_ratio)))
densityplot(~ `TFT_ratio`,
            data = fl)
scaleTransform


exprs(fl$TFT_ratio)
xyplot(`log_GFP` ~ `log_RFP`,
       data = fl,
       smooth = F)

log10(5e5)

xyplot(`DsRed.A` ~ `eGFP.A`,
       data = fl,
       smooth = F)

densityplot(log2(`DsRed.A`/`FSC.A`, data = fl), data = fl)

xyplot(`TFT_ratio` ~ `FSC.A`,
       data = fl,
       smooth = F)

densityplot(~ `TFT_ratio`, data = fl)
xyplot(fl@exprs[, 9] ~ fl@exprs[, 1])

unique(is.na(fuck))
fuck <- exprs(fl$TFT_ratio)
densityplot(fuck)
xyplot(1:10000 ~ fuck)
range(fuck)
fuck[is.na(fuck) == T]
#+END_SRC


#+BEGIN_SRC R
## -----
## load all the required packages
source("~/emacs/R/functions/load_flow_packages.R")

#############
## USER INPUT
#############
reporter_names <- c("Gln_TFT", "Asn_TFT", "Glu_TFT", "Asp_TFT",
                    "Ile_TFT", "His_TFT", "Tyr_TFT", "Trp_TFT",
                    "Leu_TFT", "Phe_TFT", "Lys_TFT", "Arg_TFT",
                    "Thr_TFT", "Met_TFT", "Pro_TFT", "Val_TFT",
                    "Gly_TFT", "Ser_TFT", "Ala_TFT", "Cys_TFT")

base_dir       <- "~/data/flow/N-end_all_reporters/"
work_dir       <- paste0(base_dir, "fcs/")
frame_dir      <- paste0(base_dir, "dataframes/")
gated_dir      <- paste0(frame_dir, "gated/")
ungated_dir    <- paste0(frame_dir, "ungated/")
## reporter_name <- "rpn4_TFT"
## reporter_name <- "0662_TFT"
#################
## END USER INPUT
#################

for (k in 1:length(reporter_names)) {

##-----
## [x]
## name the strains based on reporter, then set
## regex for getting flowsets of the different strains
## generally, should name fcs files as follows:
## strain    - by, rm, rpn4, rpn10
## reporter  - PSV, TFT, untagged
## replicate - 001, 002, etc... per strain
## e.g., "RM_Arg_TFT_001.fcs"

## 2020.05.09
## this is my current approach to reading in files.  the idea is to
## put all the various strains I've used in the past here and filter this
## complete set to those strains present in the actual data I'm analyzing.  I
## pre-filter using 'grepl' because 'read.flowset' throws an error if any term
## you supply it doesn't match.
no_reporter  <- paste0(".*untagged.*", reporter_names[k], ".*fcs") 
by_strain    <- paste0("BY.*", reporter_names[k], ".*fcs") 
rm_strain    <- paste0("RM.*", reporter_names[k], ".*fcs") 
rpn4_strain  <- paste0("rpn4.*", reporter_names[k], ".*fcs") 
ubr1_strain  <- paste0("ubr1.*", reporter_names[k], ".*fcs") 
doa10_strain <- paste0("doa10.*", reporter_names[k], ".*fcs") 
pop_1_strain <- paste0("SFA.*pop_001.*", reporter_names[k], ".*fcs") 
pop_5_strain <- paste0("SFA.*pop_005.*", reporter_names[k], ".*fcs") 
pop_6_strain <- paste0("SFA.*pop_006.*", reporter_names[k], ".*fcs") 

all_strains <- c(no_reporter, by_strain, rm_strain,
                 rpn4_strain, ubr1_strain, doa10_strain,
                 pop_1_strain, pop_5_strain, pop_6_strain)

## 'dir' lists the contents of a directory - test whether each strain regex
## matches any files in the list produced by 'dir'.  if a match occurs, the
## value returned by 'max' will be 1, else 0.  take only the strains that
## returned a match in the 2nd step below w/ 'all.strains <- ...'
true_strains <- sapply(all_strains, function(strain){
                           as.logical(max(grepl(pattern = strain,
                                                x = dir(path = work_dir,
                                                        pattern = ".*.fcs",
                                                        include.dirs = F,
                                                        ignore.case = T,
                                                        recursive = F,
                                                        no.. = T))))
                       })

all_strains <- as.list(all_strains[true_strains])

all_set     <- lapply(all_strains, function(strain){
                          read.flowSet(files = NULL,
                                       path = work_dir,
                                       pattern = strain,
                                       alter.names = T,
                                       min.limit = 1)
                      })
## str(all_set[[1]]@phenoData@data$name)

name_list <- strsplit(x = names(true_strains)[true_strains == T],
                      split = "\\.\\*")

names(all_set) <- unlist(lapply(X = name_list, FUN = function(x) {
                                    x[1] }))

## -----
## <<Color_Setup>>
## linking colors to strain names in R
## I think I should be able to make something
## akin to an lisp association list where
## there is a strain name and associated color
col_untagged <- c(color = gray(0.7),   name = "no reporter")
col_by       <- c(color = "#7A9BCCFF", name = ".*BY.*")
col_rm       <- c(color = "#CC7AAAFF", name = ".*RM.*")
col_rpn4     <- c(color = "#CCAB7AFF", name = ".*rpn4.*")
col_ubr1     <- c(color = "#88CCBBFF", name = ".*ubr1.*")
col_doa10    <- c(color = "#A3CC7AFF", name = ".*doa10.*")
col_pop_1    <- c(color = gray(0.7),   name = ".*population.*1.*")
col_pop_5    <- c(color = "#AA1111FF", name = ".*population.*5.*")
col_pop_6    <- c(color = gray(0),     name = ".*population.*6.*")

cols_list    <- list(col_untagged, col_by, col_rm, 
                     col_rpn4, col_ubr1, col_doa10,
                     col_pop_1, col_pop_5, col_pop_6)

col_out <- sapply(X = cols_list, FUN = function(x){
                      grepl(pattern = x["name"],
                            x = name_list)
                  })

col_out <- as.logical(unlist(sapply(1:ncol(col_out),
                                    FUN = function(x){
                                        max(col_out[, x])
                                    })))

all_cols <- unlist(sapply(X = cols_list[col_out],
                          FUN = function(x){identity(x["color"])}))

names(all_cols) <- names(all_set)

## output a dummmy plot to assess strain/color mapping
## setwd(results.dir)
## pdf(file = "color_mapping.pdf", height = 7, width = 7, bg = "transparent")
barplot(rep(4, length(name_list)), col = all_cols, ylim = c(0, 7))
box()
legend(x = "topleft", legend = names(all_set),
       lty = 1, lwd = 7.5, col = all_cols,
       bg = "white")
legend(x = "topright", y = NA,
       legend = unlist(lapply(X = cols_list, FUN = function(x){identity(x)["name"]})),
       col = unlist(lapply(X = cols_list, FUN = function(x){identity(x)["color"]})),
       lty = 1, lwd = 7.5,  bg = "white")
## dev.off()


## a function to gate the cells to include only haploids.
## we identify these as a sharp peak in the lower end of
## the fsc density plot.  I take 10% above and below the
## max density value
fsc_gate_generator <- function(fl_frame){
    fsc_dens  <- density(exprs(fl_frame[, 1]))
    ## return the index of the maximum y value of the density estimate
    fsc_max   <- fsc_dens[[1]][which.max(fsc_dens[[2]])]
    fsc_upper <- (fsc_max * 0.10) + fsc_max
    fsc_lower <- fsc_max - (fsc_max * 0.10)
    fsc_gate  <- c(fsc_lower, fsc_upper)
}

fsc_split <- function(x){
    split(x, f = rectangleGate("FSC.A" = fsc_gate_generator(x)),
          population = "defaultRectangleGate+",
          flowSet = T, codeflowSet = T)}

## gate all samples on FSC
fsc_set <- lapply(all_set, fsApply, fsc_split)

## convert gated samples from flowsets to flowframes 
fsc_frame <- lapply(fsc_set, function(set) {
                        lapply(set, set2Frame)
                    })

## pull dataframes from flowframes for gated and
## ungated sets of samples, then rename 
fsc_gate_exprs <- vector(mode = "list", length = length(all_set))
no_gate_exprs  <- fsc_gate_exprs

for(j in 1:length(fsc_frame)) {
    for (i in 1:length(fsc_frame[[j]])) {
        fsc_gate_exprs[[j]][[i]] <- as.data.frame(exprs(fsc_frame[[j]][[i]]))
        fsc_gate_exprs[[j]][[i]]$strain <- as.factor(names(fsc_frame[j]))
        fsc_gate_exprs[[j]][[i]]$replicate <- as.factor(i)
    }
    fsc_gate_exprs[[j]] <- do.call("rbind", fsc_gate_exprs[[j]])
} 

## bind into a single dataframe
fsc_gate_exprs <- do.call("rbind", fsc_gate_exprs)

## add transformation parameters
fsc_gate_exprs$log_GFP   <- log10(fsc_gate_exprs$eGFP.A)
fsc_gate_exprs$log_RFP   <- log10(fsc_gate_exprs$mCherry.A)
fsc_gate_exprs$TFT_ratio <- log2(fsc_gate_exprs$mCherry.A / fsc_gate_exprs$eGFP.A)
fsc_gate_exprs$reporter  <- as.factor(rep(x = gsub(pattern = "_",
                                                  replacement = " ",
                                                  x = reporter_names[k]),
                                         times = nrow(fsc_gate_exprs)))

## nested loops for the ungated data
for (j in 1:length(all_set)){
    for (i in 1:length(all_set[[j]])) {
        no_gate_exprs[[j]][[i]] <- as.data.frame(exprs(all_set[[j]][[i]]))
        no_gate_exprs[[j]][[i]]$strain <- as.factor(names(all_set[j]))
        no_gate_exprs[[j]][[i]]$replicate <- as.factor(i)
    }
    no_gate_exprs[[j]] <- do.call("rbind", no_gate_exprs[[j]])
}

## bind into a single dataframe
no_gate_exprs <- do.call("rbind", no_gate_exprs)

## add transformation parameters and reporter var
no_gate_exprs$log_GFP   <- log10(no_gate_exprs$eGFP.A)
no_gate_exprs$log_RFP   <- log10(no_gate_exprs$mCherry.A)
no_gate_exprs$TFT_ratio <- log2(no_gate_exprs$mCherry.A / no_gate_exprs$eGFP.A)
no_gate_exprs$reporter  <- as.factor(rep(x = gsub(pattern = "_",
                                                  replacement = " ",
                                                  x = reporter_names[k]),
                                         times = nrow(no_gate_exprs)))

## write the ungated data to the appropriate dir
write.table(x = no_gate_exprs,
            file = paste0(ungated_dir,
                          reporter_names[k],
                          "_all_ungated.csv"),
            append = F, sep = ",",
            quote = F, row.names = F)

## write the gated data to the appropriate dir
write.table(x = fsc_gate_exprs,
            file = paste0(gated_dir,
                          reporter_names[k],
                          "_all_gated.csv"),
            append = F, sep = ",",
            quote = F, row.names = F)

    }



## now, read each reporter's dataframe in and
## combine into a single dataframe
dir(gated_dir)
dir(ungated_dir)

out <- vector(mode = "list", length = length(dir(ungated_dir)))
for (o in 1:length(dir(gated_dir))) {
    out[[o]] <- read.table(file = paste0(ungated_dir, dir(ungated_dir)[o]),
                                 header = T, sep = ",")
       }

out <- vector(mode = "list", length = length(dir(gated_dir)))
for (o in 1:length(dir(gated_dir))) {
    out[[o]] <- read.table(file = paste0(gated_dir, dir(gated_dir)[o]),
                                 header = T, sep = ",")
       }

out_all <- do.call("rbind", out)
out_all
levels(out_all$reporter)

## Ac/N-end alphabetized
## ala, cys, gly, met, pro, ser, thr, val


aa_order <- c(2, 3, 4, 6, 7, 9, 10, 11, 12, 14, 18, 19, 1, 5, 8, 13, 15, 16, 17, 20)
aa_order <- c(20, 17, 16, 15, 13, 8, 5, 1, 19, 18, 14, 12, 11, 10, 9, 7, 6, 4, 3, 2)

out_all$strain <- factor(out_all$strain,
                         levels = levels(out_all$strain)[c(1, 3, 4, 5, 2)])

strain_paste <- expand.grid(unique(out_all$replicate),
                          levels(out_all$strain))

strain_paste <- paste0(strain_paste$Var2, "_", strain_paste$Var1)

out_all$strain_rep <- factor(paste0(out_all$strain, "_", out_all$replicate),
                             levels = strain_paste)

rep_cols <- unlist(lapply(X = 1:length(all_cols), FUN = function(x) {
                       rep(all_cols[x],
                           times = sum(grepl(pattern = names(all_cols[x]), 
                                             x = levels(out_all$strain_rep))))
                   }))

## need to order levels of 'strain_rep' like 'strain'

out_all$o_reporter <- factor(out_all$reporter,
                             levels = levels(out_all$reporter)[aa_order])


fs <- read.table(file = paste0(gated_dir, dir(gated_dir)), header = T, sep = ",")

## [x] pathway text 
## [x] x label 
## [x] strain names in legend densityplot
## [ ] strain names in stripplots 
## [ ] strain names in heatmap
## [ ] parameter loop

params <- colnames(out_all)[unlist(lapply(X = out_all, FUN = is.numeric))]
params[10] <- "log2 TFT Ratio"

## <<density_plot_final>>
{
pdf(file = "~/Desktop/den_full_test.pdf", height = 14.5, width = 14)
print(

densityplot(~ TFT_ratio | reporter,
            groups = strain_rep,
            data = out_all,
            xlim = c(-7, 1.5),
            ## set alternating = F for one side, same side labeling
            scales = list(alternating = 3),
            grid = T,
            plot.points = F,
            lwd = 2,
            main = list(label = "Arg/N-end Reporters"),
            sub = list(label = "Ac/N-end Reporters"),
            between = list(x = c(0, 0, 0),
                           y = c(0, 0, 3)),
            as.table = T,
            ylab = ",,",
            xlab = gsub(pattern = "_",
                        replacement = " ",
                        params[10]),
            index.cond = list(aa_order),
            par.settings = list(strip.background = list(col = gray(0.9)),
                                clip = list(panel = FALSE),
                                par.main.text = list(font = 2,
                                                     cex = 1.25,
                                                     just = "center", 
                                                     x = grid::unit(7, "in")),
                                par.sub.text = list(font = 2,
                                                    just = "center",
                                                    cex = 1.25,
                                                    x = grid::unit(7.05, "in"),
                                                    y = grid::unit(5.95, "in")),
                                axis.text = list(cex = 1),
                                par.ylab.text = list(cex = 1.25,
                                                     col = "white"),
                                par.xlab.text = list(cex = 1.25)),
            ## legend = list(inside = list(fun = grid.legend,
            ##                             args = list(labels = c("BY", "RM",
            ##                                   expression(paste("BY rpn4", Delta)), 
            ##                                   expression(paste("BY ubr1", Delta)), 
            ##                                   expression(paste("BY doa10", Delta))),
            ##                                   do.lines = T,
            ##                                   nrow = 5,
            ##                                   draw = T,
            ##                                   hgap = 1,
            ##                                   vgap = 0.25,
            ##                                   gp = gpar(col = all_cols,
            ##                                             lwd = 5,
            ##                                             cex = 1,
            ##                                             lineend = "butt",
            ##                                             npc = 50
            ##                                                   )))),
            ## key = list(text = list(c("BY", "RM",
            ##                           expression(paste("BY rpn4", Delta)),
            ##                           expression(paste("BY ubr1", Delta)),
            ##                           expression(paste("BY doa10", Delta)))),
            ##             lines = list(col = all_cols,
            ##                          lwd = 5),
            ##            corner = c(0, 1),
            ##            y = 0.98),
            panel = function(x, y, q, subscripts, ...) {
                panel.grid(h = -1, v = -1)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = out_all$strain_rep,
                                  subscripts = subscripts,
                                  as.table = T,
                                  lty = 1,
                                  col = rep_cols,
                                  lwd = 0.75)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = out_all$strain,
                                  subscripts = subscripts,
                                  as.table = t,
                                  lty = 1,
                                  lwd = 1.5,
                                  col = all_cols,
                                  ylim = c(0, 2))
            })

)
## <<plot_legend>>
## this gets placed outside the 'print' call
## write out a legend using 'grid.text' and 'grid.lines'
## because I separate the 2 N-end pathways, doubling
## the legend makes for a better visual layout.
## turns out there's not a straightforward way to
## double or position legends built using the lattice
## 'key' argument or grid.legend.  the code below works,
## but it's a bit hacky...
for (k in 1:length(legend_params)) {
    for (l in 1:length(legend_params[[1]])) {
        grid.text(label = legend_params[[k]]$names[l],
                  x = legend_params[[k]]$x_positions[l],
                  y = legend_params[[k]]$y_positions[l],
                  default.units = "in",
                  just = "left",
                  gp = gpar(col = "black", cex = 1))
        grid.lines(x = c(legend_params[[k]]$line_x1[l],
                         legend_params[[k]]$line_x2[l]),
                   y = c(legend_params[[k]]$y_positions[l],
                         legend_params[[k]]$y_positions[l]),
                   default.units = "in",
                   gp = gpar(lwd = 4, lineend = "butt",
                             col = legend_params[[k]]$color[l]))
    }
}

## replace improper y label positioning w/ custom text
## and double it since we've split the plot into 2 panels
grid.text(label = "Density",
          x = c(0.15, 0.15),
          y = c(7.5, 2),
          rot = 90,
          default.units = "in",
          gp = gpar(col = "black", cex = 1.25)
          )

dev.off()
}

## legend parameters
## drop everything for building a custom legend
## into a list.  loop over the list by position
## ('top' or 'bottom') and strain to make 2
## legends in the panels 
top_legend_params <- list()
top_legend_params$names <- c("BY", "RM",
                         expression(paste("BY rpn4", Delta)), 
                         expression(paste("BY ubr1", Delta)), 
                         expression(paste("BY doa10", Delta)))
top_legend_params$line_x1     <- rep(0.8, 5)
top_legend_params$line_x2     <- rep(1.15, 5)    
top_legend_params$x_positions <- rep(x = 1.2, times = 5)
top_legend_params$y_positions <- rev(seq(from = 12.7, to = 13.45, length.out = 5))
top_legend_params$color       <- all_cols
bot_legend_params <- top_legend_params
top_legend_params$y_positions <- rev(seq(from = 4.75, to = 5.5, length.out = 5))
legend_params <- list(top_legend_params, bot_legend_params)


## <<example_density_plot_trp_met>>
out_tw <- out_all[out_all$reporter == "Met TFT" | out_all$reporter == "Trp TFT", ]


{
pdf(file = "~/Desktop/example_density_2_panel.pdf", height = 8, width = 5)
print(
densityplot(~ TFT_ratio | reporter,
            groups = strain_rep,
            data = out_tw,
            xlim = c(-8, 1.5),
            ## set alternating = F for one side, same side labeling
            scales = list(alternating = 1,
                          tck = c(1, 0)),
            grid = T,
            plot.points = F,
            lwd = 2,
            as.table = F,
            ylab = ",",
            xlab = "log2 TFT ratio",
            par.settings = list(strip.background = list(col = gray(0.9)),
                                clip = list(panel = FALSE),
                                par.main.text = list(font = 2,
                                                     cex = 1.25,
                                                     just = "center", 
                                                     x = grid::unit(7, "in")),
                                par.sub.text = list(font = 2,
                                                    just = "center",
                                                    cex = 1.25,
                                                    x = grid::unit(7.05, "in"),
                                                    y = grid::unit(5.95, "in")),
                                axis.text = list(cex = 1),
                                par.ylab.text = list(cex = 1.25,
                                                     col = "white"),
                                par.xlab.text = list(cex = 1.25)),
            panel = function(x, y, q, subscripts, ...) {
                panel.grid(h = -1, v = -1)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = out_tw$strain_rep,
                                  subscripts = subscripts,
                                  as.table = T,
                                  lty = 1,
                                  col = rep_cols,
                                  lwd = 0.75)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = out_tw$strain,
                                  subscripts = subscripts,
                                  as.table = t,
                                  lty = 1,
                                  lwd = 1.5,
                                  col = all_cols,
                                  ylim = c(0, 2))
            })
)
## this gets placed outside the 'print' call
## write out a legend using 'grid.text' and 'grid.lines'
## because I separate the 2 N-end pathways, doubling
## the legend makes for a better visual layout.
## turns out there's not a straightforward way to
## double or position legends built using the lattice
## 'key' argument or grid.legend.  the code below works,
## but it's a bit hacky...
## legend parameters
## drop everything for building a custom legend
## into a list.  loop over the list by position
## ('top' or 'bottom') and strain to make 2
## legends in the panels 
ex_top_legend_params <- list()
ex_top_legend_params$names <- c("BY", "RM",
                                expression(paste("BY rpn4", Delta)), 
                                expression(paste("BY ubr1", Delta)), 
                                expression(paste("BY doa10", Delta)))
## starting point of the lines in 'x'
ex_top_legend_params$line_x1     <- rep(0.9, 5)
## endind position of the lines in 'x'
ex_top_legend_params$line_x2     <- rep(1.25, 5)    
ex_top_legend_params$x_positions <- rep(x = 1.35, times = 5)
ex_top_legend_params$y_positions <- rev(seq(from = 6.55, to = 7.25, length.out = 5))
ex_top_legend_params$color       <- all_cols
ex_bot_legend_params <- ex_top_legend_params
ex_top_legend_params$y_positions <- rev(seq(from = 3.1, to = 3.85, length.out = 5))
ex_legend_params <- list(ex_top_legend_params, ex_bot_legend_params)
for (k in 1:length(ex_legend_params)) {
    for (l in 1:length(ex_legend_params[[1]])) {
        grid.text(label = ex_legend_params[[k]]$names[l],
                  x = ex_legend_params[[k]]$x_positions[l],
                  y = ex_legend_params[[k]]$y_positions[l],
                  default.units = "in",
                  just = "left",
                  gp = gpar(col = "black", cex = 1))
        grid.lines(x = c(ex_legend_params[[k]]$line_x1[l],
                         ex_legend_params[[k]]$line_x2[l]),
                   y = c(ex_legend_params[[k]]$y_positions[l],
                         ex_legend_params[[k]]$y_positions[l]),
                   default.units = "in",
                   gp = gpar(lwd = 4, lineend = "butt",
                             col = ex_legend_params[[k]]$color[l]))
    }
}
## replace improper y label positioning w/ custom text
## and double it since we've split the plot into 2 panels
grid.text(label = "Density",
          x = c(0.2, 0.2),
          y = c(2.3, 5.7),
          rot = 90,
          gp = gpar(cex = 1.25),
          default.units = "in")
dev.off()
}



## <<strip_plots>>
## these plots are built by extracting the mean/median
## of each biological replicate of each strain.  Thus,
## we reduce 10,000 observations of a replicate to a
## single value.  w/ 8 biological replicates per strain,
## we can make a nice stripplot of strain * reporter
## for the different parameters.  We'll also use this
## to make a levelplot/heatmap

## 'aggregate' creates a new dataframe from x by applying FUN to
## all unique combinations of the factors supplied to the 'by'
## argument - in this case, grab the mean of numeric data and
## keep everything else a factor 
out_agg <- aggregate.data.frame(x = out_all,
                                by = list(out_all$strain,
                                          out_all$reporter,
                                          out_all$replicate),
                            FUN = function(x) {
                                ifelse(is.numeric(x), mean(x), as.factor(x))
                            })

## 'aggregate' seems to strip the levels from factors, so add
## these back using the values present in the original dataframe
out_agg$strain <- factor(out_agg$strain,
                     levels = unique(out_agg$strain),
                     labels = levels(out_all$strain))

out_agg$reporter <- factor(out_agg$reporter,
                     levels = unique(out_agg$reporter),
                     labels = levels(out_all$reporter))

out_agg$strain_rep <- factor(out_agg$strain_rep,
                             levels = unique(out_agg$strain_rep),
                             labels = levels(out_all$strain_rep))

## need a color vector that maps to strains that's the
## length of levels(strain) * levels(replicate) (usually 40)
out_agg_cols <- vector()
for (i in 1:nrow(out_agg)) {
    out_agg_cols[i] <- all_cols[out_agg$strain[i] == names(all_cols)]
}


{
pdf(file = "~/Desktop/strip_full_test.pdf", height = 14.5, width = 14)
print(
stripplot(TFT_ratio ~ strain | reporter,
          data = out_agg,
          col = gray(0),
          fill = out_agg_cols,
          pch = 21,
          cex = 1.1,
          scales = list(alternating = 3,
                        x = list(labels = c("BY", "RM",
                         expression(paste("BY rpn4", Delta)), 
                         expression(paste("BY ubr1", Delta)), 
                         expression(paste("BY doa10", Delta))),
                         rot = 45)),
          layout = c(4, 5),
          grid = T,
          main = list(label = "Arg/N-end Reporters"),
          sub = list(label = "Ac/N-end Reporters"),
          between = list(x = c(0, 0, 0),
                         y = c(0, 0, 3)),
          as.table = T,
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.main.text = list(font = 2,
                                                   cex = 1.25,
                                                   just = "center", 
                                                   x = grid::unit(7, "in"),
                                                   y = grid::unit(13, "in")),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.25,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(6.25, "in")),
                              axis.text = list(cex = 1),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.25)),
          jitter.data = T,
          ## factor for jittering
          factor = 1.5,
          index.cond = list(aa_order),
          horizontal = F)
)

## main title, not sure why this doesn't show up otherwise
## probably some par setting re: going outside the grid....
grid.text(label = "Arg/N-end Reporters",
          x = 7.0,
          y = 14.2,
          default.units = "in",
          gp = gpar(cex = 1.25, font = 2))

## y axis labels for the strip
grid.text(label = "log2 TFT ratio",
          x = c(0.15, 0.15),
          y = c(7.75, 2.25),
          rot = 90,
          default.units = "in",
          gp = gpar(col = "black", cex = 1.25)
          )
dev.off()
}


## let's try to convert to Z scores 
i <- 1

out_z <- list()
reporter <- levels(out_agg$reporter)
for (i in 1:length(reporter)) {
    
    z_mean <- mean(out_agg$TFT_ratio[out_agg$reporter == reporter[i]])
    z_sd   <- sd(out_agg$TFT_ratio[out_agg$reporter == reporter[i]])
    z_out  <- function(x) { ((x - z_mean) / (z_sd))  }
    out_subset <- out_agg[out_agg$reporter == reporter[i], ]
    
    for (j in 1:nrow(out_subset)) {
        out_subset$zTFT[j] <- z_out(out_subset$TFT_ratio[j])
        out_z[[i]] <- out_subset
}}

out_z <- do.call("rbind", out_z)
range(out_z$zTFT)

out_z$r_order <- factor(out_z$reporter,
                        levels = levels(out_z$reporter)[rev(aa_order)])

levelplot(zTFT ~ strain * r_order,
          strip = T,
          xlab = "Strain",
          ylab = "Reporter",
          data = out_z,
          pretty = T,
          scales = list(alternating = F,
                        x = list(labels = c("BY", "RM",
                                            expression(paste("BY rpn4", Delta)), 
                                            expression(paste("BY ubr1", Delta)), 
                                            expression(paste("BY doa10", Delta))),
                                 rot = 45)),
          col.regions = gray(level = 29:0/29),
          at = seq(from = -2, to = 2.1, length.out = 30),
          colorkey = list(at = seq(from = -2, to = 2.1, length.out = 30)),
          border = gray(0.3),
          as.table = T,
          ## index.cond = list(aa_order),
          border.lwd = 2)



## xxxx
out_m <- aggregate.data.frame(x = out_z,
                               by = list(out_z$strain,
                                         out_z$reporter),
                               FUN = function(x) {
                                   ifelse(is.numeric(x), mean(x), as.factor(x))
                               })

out_m$strain <- factor(out_m$strain,
                        levels = unique(out_m$strain),
                        labels = levels(out_all$strain))

out_m$reporter <- factor(out_m$reporter,
                          levels = unique(out_m$reporter),
                          labels = levels(out_all$reporter))


range(out_m$zTFT)

out_m$r_order <- factor(out_m$reporter,
                        levels = levels(out_m$reporter)[rev(aa_order)])



{
pdf(file = "~/Desktop/heat_test.pdf", height = 14, width = 6)
print(
levelplot(zTFT ~ strain * r_order,
          strip = T,
          xlab = "Z-score",
          ylab = "Reporter",
          data = out_m,
          pretty = T,
          ylab.right = "Z score",
          scales = list(alternating = F,
                        x = list(labels = c("BY", "RM",
                                            expression(paste("BY rpn4", Delta)), 
                                            expression(paste("BY ubr1", Delta)), 
                                            expression(paste("BY doa10", Delta))),
                                 rot = 45),
                        ## scales only on left/bottom
                        tck = c(1, 0)),
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.25,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(6.25, "in")),
                              layout.heights=list(xlab.key.padding=1),
                              axis.text = list(cex = 1.25),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.25),
                              list(layout.widths = list(axis.key.padding = 0, 
                                                        ylab.right = 2))), 
##          col.regions = gray(level = 29:0/29),
          at = seq(from = -2, to = 2, length.out = 30),
          colorkey = list(at = seq(from = -2, to = 2, length.out = 30),
                          cex = 1.25,
                          title = "Z score",
                          space = "bottom",
                          columns = 1,
                          row = 10),
          border = gray(0.3),
          as.table = T,
          ## index.cond = list(aa_order),
          border.lwd = 2)
)
## Ac/N-end reporter lines
grid.lines(x = c(0.32, 0.32),
           y = c(2.4, 6.42),
           default.units = "in",
           gp = gpar(lwd = 2, col = gray(0)))
## Ac/N-end reporter text
grid.text(x = 0.15, y = 4.41,
          label = "Ac/N-end Reporters",
          default.units = "in",
          rot = 90,
          gp = gpar(cex = 1.25))
## Arg/N-end reporter lines
grid.lines(x = c(0.32, 0.32),
           y = c(6.95, 13.25),
           default.units = "in",
           gp = gpar(lwd = 2, col = gray(0)))
## Arg/N-end reporter text
grid.text(x = 0.15, y = 10.1,
          label = "Arg/N-end Reporters",
          default.units = "in",
          rot = 90,
          gp = gpar(cex = 1.25))
dev.off()
}


## <<Z_score_stripplot>>
{
pdf(file = "~/Desktop/z_strip_full_test.pdf", height = 14.5, width = 14)
print(
stripplot(zTFT ~ strain | reporter,
          data = out_z,
          col = gray(0),
          fill = out_agg_cols,
          pch = 21,
          cex = 1.1,
          scales = list(alternating = 3,
                        x = list(labels = c("BY", "RM",
                         expression(paste("BY rpn4", Delta)), 
                         expression(paste("BY ubr1", Delta)), 
                         expression(paste("BY doa10", Delta))),
                         rot = 45)),
          layout = c(4, 5),
          grid = T,
          main = list(label = "Arg/N-end Reporters"),
          sub = list(label = "Ac/N-end Reporters"),
          between = list(x = c(0, 0, 0),
                         y = c(0, 0, 3)),
          as.table = T,
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.main.text = list(font = 2,
                                                   cex = 1.25,
                                                   just = "center", 
                                                   x = grid::unit(7, "in"),
                                                   y = grid::unit(13, "in")),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.25,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(6.25, "in")),
                              axis.text = list(cex = 1),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.25)),
          jitter.data = T,
          ## factor for jittering
          factor = 1.5,
          index.cond = list(aa_order),
          horizontal = F)
)

## <<example_stripplots>>
## use met and trp for this purpose 
out_x <- out_z[out_z$reporter == "Met TFT" | out_z$reporter == "Trp TFT", ]

{
pdf(file = "~/Desktop/example_strip_2_panel.pdf", height = 8, width = 5)
print(
stripplot(zTFT ~ strain | reporter,
          data = out_x,
          col = gray(0),
          fill = out_agg_cols,
          pch = 21,
          cex = 1.25,
          scales = list(alternating = 1,
                        tck = c(1, 0),
                        x = list(labels = c("BY", "RM",
                         expression(paste("BY rpn4", Delta)), 
                         expression(paste("BY ubr1", Delta)), 
                         expression(paste("BY doa10", Delta))),
                         rot = 45)),
          layout = c(1, 2),
          grid = T,
          as.table = F,
          jitter = T,
          factor = 1.7,
          ylab = "Z-score",
          xlab = "Strain",
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.main.text = list(font = 2,
                                                   cex = 1.25,
                                                   just = "center", 
                                                   x = grid::unit(7, "in"),
                                                   y = grid::unit(13, "in")),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.25,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(6.25, "in")),
                              axis.text = list(cex = 1.25),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.25)),
          horizontal = F)
)
grid.text(label = "Z-score",
          x = c(0.2, 0.2),
          y = c(3, 6.1),
          rot = 90,
          gp = gpar(cex = 1.25),
          default.units = "in")
dev.off()
}

## main title, not sure why this doesn't show up otherwise
## probably some par setting re: going outside the grid....
grid.text(label = "Arg/N-end Reporters",
          x = 7.0,
          y = 14.2,
          default.units = "in",
          gp = gpar(cex = 1.25, font = 2))

## y axis labels for the strip
grid.text(label = "Z-score",
          x = c(0.15, 0.15),
          y = c(7.75, 2.3),
          rot = 90,
          default.units = "in",
          gp = gpar(col = "black", cex = 1.25)
          )
dev.off()
}



TFT_hm$legend$right <- 
    list(fun = mergedTrellisLegendGrob(TFT_hm$legend$right, 
                                       list(fun = textGrob, 
                                            args = list("Z score", 
                                                        rot = 90,
                                                        gp = gpar(cex = 1.25))), 
                                       vertical = FALSE))
## mergedTrellisLegendGrob



## <<levelplot_TFT_heatmap>>
## the idea here is to show that the control
## strains work for the TFTs.  The TFT ratio
## needs scaling, though, as it looks like
## trash w/o it because there's such a large
## range of raw log2 TFT ratio values

## <<out_sc>> data frame of all replicates averaged together
out_sc <- aggregate.data.frame(x = out_agg,
                               by = list(out_agg$strain,
                                         out_agg$reporter),
                               FUN = function(x) {
                                   ifelse(is.numeric(x), mean(x), as.factor(x))
                               })

out_sc$strain <- factor(out_sc$strain,
                        levels = unique(out_sc$strain),
                        labels = levels(out_all$strain))

out_sc$reporter <- factor(out_sc$reporter,
                          levels = unique(out_sc$reporter),
                          labels = levels(out_all$reporter))

## set up a list to dump scaled output into
out_c <- list()

r_names <- gsub(pattern = "_", replacement = " ",
                x = reporter_names)

for (i in 1:length(r_names)) {
    out_c[[i]] <- out_sc[out_sc$reporter == r_names[i], ]
    min_level <- min(out_c[[i]]$TFT_ratio)
    out_c[[i]]$scTFT_ratio <- abs(out_c[[i]]$TFT_ratio - min_level)
}

out_c <- do.call("rbind", out_c)


test_this <- out_sc[out_sc$reporter == "Cys TFT" | out_sc$reporter == "Gln TFT", ]

t_l <- list()

for (i in 1:2) {
    t_min <- min(test_this$TFT_ratio[test_this$reporter == unique(test_this$reporter)[i]])
    t_l[[i]] <- test_this[test_this$reporter == unique(test_this$reporter)[i], ]
    t_l[[i]]$sctft <- abs(t_l[[i]]$TFT_ratio - t_min)
}

t_l <- do.call("rbind", t_l)
t_l[, c("strain", "sctft", "TFT_ratio")]



t_l

length(levels(out_c$reporter))
length(aa_order)


out_arg <- out_c 

test_this <- out_c[1, ]
max(grepl(pattern = test_this$reporter, x = levels(out_c$reporter)))

ac_names <- levels(out_c$aa_order)[1:8]
arg_names <- levels(out_c$aa_order)[9:20]

for (i in 1:nrow(out_c)) {
    out_c$arg[i] <- max(grepl(pattern = out_c$reporter[i],
                              x = arg_names))
    out_c$ac[i] <- max(grepl(pattern = out_c$reporter[i],
                              x = ac_names))
}

out_c$arg
out_c$ac

ac_out  <- out_c[out_c$ac == 1, ]
arg_out <- out_c[out_c$arg == 1, ]

max(arg_out$scTFT_ratio) ## 5.5

arg_level <- levelplot(scTFT_ratio ~ strain * aa_order,
                       strip = T,
                       xlab = "Strain",
                       ylab = "Reporter",
                       main = "Arg/N-end Reporters",
                       data = arg_out,
                       pretty = T,
                       scales = list(alternating = F,
                                     x = list(labels = c("BY", "RM",
                                                         expression(paste("BY rpn4", Delta)), 
                                                         expression(paste("BY ubr1", Delta)), 
                                                         expression(paste("BY doa10", Delta))),
                                              rot = 45)),
                       col.regions = gray(level = 23:0/23),
                       at = seq(from = 0, to = 5.5, by = 0.25),
                       colorkey = list(at = seq(from = 0, to = 5.5, by = 0.25)),
                       border = gray(0.3),
                       as.table = T,
                       ## index.cond = list(aa_order),
                       border.lwd = 2)

ac_level <- levelplot(scTFT_ratio ~ strain * aa_order,
                      strip = T,
                      xlab = "Strain",
                      ylab = "Reporter",
                      main = "Ac/N-end Reporters",
                      data = ac_out,
                      pretty = T,
                      scales = list(alternating = F,
                                    x = list(labels = c("BY", "RM",
                                                        expression(paste("BY rpn4", Delta)), 
                                                        expression(paste("BY ubr1", Delta)), 
                                                        expression(paste("BY doa10", Delta))),
                                             rot = 45)),
                      col.regions = gray(level = 31:0/31),
                      at = seq(from = 0, to = 7.5, by = 0.25),
                      colorkey = list(at = seq(from = 0, to = 7.5, by = 0.25)),
                      border = gray(0.3),
                      as.table = T,
                      ## index.cond = list(aa_order),
                      border.lwd = 2)

pdf(file = "~/Desktop/two_plot_heat.pdf", height = 14, width = 14)
print(arg_level, split = c(1, 1, 2, 1), more = T)
print(ac_level, split = c(2, 1, 2, 1), newpage = F)
dev.off()

print(one, split = c(1, 1, 1, 2))
print(two, split = c(1, 2, 1, 2), newpage = F)



levels(out_c$reporter)[aa_order]

out_c$aa_order <- factor(out_c$reporter,
                         levels = levels(out_c$reporter)[rev(aa_order)])

levelplot(scTFT_ratio ~ strain * aa_order,
          strip = T,
          xlab = "Strain",
          ylab = "Reporter",
          data = out_c,
          pretty = T,
          scales = list(alternating = F,
                        x = list(labels = c("BY", "RM",
                                            expression(paste("BY rpn4", Delta)), 
                                            expression(paste("BY ubr1", Delta)), 
                                            expression(paste("BY doa10", Delta))),
                                 rot = 45)),
          col.regions = gray(level = 31:0/31),
          at = seq(from = 0, to = 7.5, by = 0.25),
          colorkey = list(at = seq(from = 0, to = 7.5, by = 0.25)),
          border = gray(0.3),
          as.table = T,
          ## index.cond = list(aa_order),
          border.lwd = 2)

barplot(rep(4, 29), col = gray(level = 29:0/29))

t_l
col.regions=c("#FFFFFF", "#FFFFC6", "#FFFF8D", "#FFFF55", "#FFFF1C", "#FFE200", "#FFAA00", "#FF7100", "#FF3800", "#FF0000", "#000000"),  # 10 colors from white to red through yellow for levels 0 to 9, plus black for level=10 
at=c(-0.5:10.5),  # this is how I got colors centered on integer values 
colorkey = list(at = c(-0.5:10.5), labels=list(at=c(0:10),lab=c(as.character(c(0:9)),"NA"))), 


rr()
length(-0.5:10.5)
## set up a variable for subsetting on TFTs
## need to use 'gsub' on 'reporter_names' here,
## because 'reporter_names' is written like "Ala_TFT"
r_names <- gsub(pattern = "_", replacement = " ",
                x = reporter_names)


for (i in 1:length(r_names)) {
    out_c[[i]] <- out_agg[out_agg$reporter == r_names[i], ]
    min_level <- out_c[[i]]$strain[out_c[[i]]$TFT_ratio == min(out_c[[i]]$TFT_ratio)]
    min_mean <- mean(out_c[[i]]$TFT_ratio[out_c[[i]]$strain == min_level])
    out_c[[i]]$scTFT_ratio <- abs(out_c[[i]]$TFT_ratio - min_mean)
}

out_sc <- do.call("rbind", out_sc)

## cys TFT 
## avg = -4.14
## min = -7.39
-4.14 - -7.39 => 3.25 

## gln TFT
## avg = 0.273
## min = -0.0567
0.273 - -0.0567 => 0.3297 

r_names
out_agg$TFT_ratio




## 2 color palette generator
## call this w/ a numeric arg to get that
## many colors in a ramp, e.g., 'rr(20)'
rr <- colorRampPalette(c(gray(1), "#551144"))

print(

mean(out_sc$scTFT_ratio[out_sc$strain == "RM" & out_sc$reporter == "Cys TFT"]) 

levelplot(TFT_ratio ~ strain * reporter,
          strip = T,
          xlab = "Strain",
          ylab = "Reporter",
          data = x_out,
          pretty = T,
          col.regions = rr(28),
          colorkey = list(at = seq(from = 0, to = 7, by = 0.25)),
          border = gray(0.3),
          as.table = T,
          ## index.cond = list(aa_order),
          border.lwd = 2)

)

trellis.par.get()
mean(x_out$scTFT_ratio[x_out$strain == "BY" & x_out$reporter == "Gln TFT"])
mean(x_out$scTFT_ratio[x_out$strain == "RM" & x_out$reporter == "Gln TFT"])
mean(x_out$scTFT_ratio[x_out$strain == "doa10" & x_out$reporter == "Gln TFT"])
mean(x_out$scTFT_ratio[x_out$strain == "ubr1" & x_out$reporter == "Gln TFT"])
mean(x_out$scTFT_ratio[x_out$strain == "rpn4" & x_out$reporter == "Gln TFT"])
x_out <- out_sc
x_out$scTFT_ratio <- ifelse(x_out$scTFT_ratio < 0.01, 0, x_out$scTFT_ratio)
range(x_out$scTFT_ratio)

min(out_sc$scTFT_ratio[out_sc$reporter == "Cys TFT"])
min(out_sc$scTFT_ratio[out_sc$reporter == "Glu TFT"])

min(out_sc$scTFT_ratio[out_sc$reporter == "Ser TFT"])
mean(out_sc$scTFT_ratio[out_sc$reporter == "Ser TFT" & out_sc$strain == "rpn4"])

levels(out_agg$reporter)

test_max <- vector()
for (i in 1:length(levels(out_agg$reporter))) {
test_max[i] <- max(out_agg$TFT_ratio[out_agg$reporter == levels(out_agg$reporter)[i]])
}
test_max

## log2 reporter max/reporter level 

trellis.par.get()


## <<BY_RM_plot>>
## nrow(out_agg) = 800, so 300 should be BY or RM 
out_by_rm <- grepl(pattern = "[BR][YM]",
                   x = as.character(out_agg$strain))

out_br <- out_agg[out_by_rm, ]

out_br_cols <- vector

for (i in 1:nrow(out_br)) {
out_br_cols[i] <- all_cols[out_br$strain[i] == names(all_cols)]
}

{
pdf(file = "~/Desktop/by_rm_test.pdf", height = 14.5, width = 14)
print(
## need to make a TFT ratio amino acid index 
stripplot(TFT_ratio ~ strain | reporter,
          data = out_br,
          type = c("g", "p"),
          col = gray(0),
          fill = out_br_cols,
          pch = 21,
          cex = 1.1,
          scales = list(alternating = 3,
                        x = list(labels = c("BY", "RM"))),
          layout = c(4, 5),
          grid = T,
          main = list(label = "Arg/N-end Reporters"),
          sub = list(label = "Ac/N-end Reporters"),
          between = list(x = c(0, 0, 0),
                         y = c(0, 0, 3)),
          as.table = T,
          par.settings = list(strip.background = list(col = gray(0.9)),
                              clip = list(panel = FALSE),
                              par.main.text = list(font = 2,
                                                   cex = 1.25,
                                                   just = "center", 
                                                   x = grid::unit(7, "in"),
                                                   y = grid::unit(13, "in")),
                              par.sub.text = list(font = 2,
                                                  just = "center",
                                                  cex = 1.25,
                                                  x = grid::unit(7.05, "in"),
                                                  y = grid::unit(5.95, "in")),
                              axis.text = list(cex = 1),
                              par.ylab.text = list(cex = 1.25,
                                                   col = "white"),
                              par.xlab.text = list(cex = 1.25)),
          jitter.data = T,
          ## factor for jittering
          factor = 1.5,
          index.cond = list(aa_order),
          horizontal = F)
)
## main title, not sure why this doesn't show up otherwise
## probably some par setting re: going outside the grid....
grid.text(label = "Arg/N-end Reporters",
          x = 7.0,
          y = 14.2,
          default.units = "in",
          gp = gpar(cex = 1.25, font = 2))

## y axis labels for the strip
grid.text(label = "log2 TFT ratio",
          x = c(0.15, 0.15),
          y = c(7.45, 1.85),
          rot = 90,
          default.units = "in",
          gp = gpar(col = "black", cex = 1.25))
dev.off() 
}


## TODO 
## - [1] add reporter variable and transforms (GFP, RFP, TFT)
## - [2] extract replicate mean/media parameters
##       + possibly as separate frames, though maybe not necessary
reporter_var <- as.factor(gsub(pattern = "_",
                               replacement = " ",
                               x = reporter_name))


## working plots
## 5 plots by strain, split by replciates
densityplot(~ TFT_ratio | strain,
            data = fsc_gate_exprs,
            groups = replicate,
            layout = c(5, 1),
            plot.points = F,
            auto.key = list(space = "right"))

## single plot split by strain
densityplot(~ TFT_ratio,
            groups = strain,
            data = fsc_gate_exprs,
            plot.points = F,
            auto.key = list(space = "right"))

## strain by replicate heat map (but cols scaled wrong)
levelplot(TFT_ratio ~ strain * replicate,
          data = fsc_gate_exprs,
          border = gray(0.9),
          border.lwd = 4,
          scales = list(x=list(rot=45)),
          aspect = "iso") 

## single row heatmap
levelplot(TFT_ratio ~ strain * sample_id,
          data = fsc_gate_exprs,
          border = gray(0.9),
          border.lwd = 4,
          scales = list(x=list(rot=45)),
          aspect = "iso")

## recall that you can summarize trellis objects 
## and view high-level information about them:
t_obj <- densityplot(~ TFT_ratio | strain,
            data = fsc_gate_exprs,
            groups = replicate,
            layout = c(5, 1),
            plot.points = F,
            auto.key = list(space = "right"))
summary(t_obj)
## and plot
print(t_obj)

## 2D plot allow conditioning via x ~ y formulas
## these nicely show no relationship betw. FSC and TFT ratio
xyplot(TFT_ratio ~ FSC.A | strain,
       data = fsc_gate_exprs)
xyplot(TFT_ratio ~ FSC.A | strain,
       data = no_gate_exprs)

## no strong relationship betw. GFP and TFT ratio either 
xyplot(TFT_ratio ~ log_GFP | strain,
       data = fsc_gate_exprs)

## TFT ratio directly related to RFP
xyplot(TFT_ratio ~ log_RFP | strain,
       data = fsc_gate_exprs)
## not as much GFP
xyplot(log_RFP ~ log_GFP | strain,
       data = fsc_gate_exprs)

## this plot nicely shows that relative
## differences between strains don't
## change at various levels of FSC/SSC
a <- equal.count(no_gate_exprs$FSC.A)
plot(a)
b <- equal.count(no_gate_exprs$SSC.A)
plot(b)
f_shingle <- equal.count(no_gate_exprs$FSC.A)
densityplot(~ TFT_ratio | b,
            groups = strain,
            data = no_gate_exprs,
            plot.points = F,
            auto.key = list(col = 1))

## same plot w/ a custom shingle 
c_shingle <- equal.count(no_gate_exprs$FSC.A, number = 5, overlap = 0.1)
densityplot(~ TFT_ratio | c_shingle,
            groups = strain,
            data = no_gate_exprs,
            plot.points = F,
            auto.key = list(col = 1)) 


## nice cross-contingency table of n. cells
## per strain per replicate
xtabs(~strain + replicate,
      data = fsc_gate_exprs)

write.table(x = fsc_gate_exprs,
            file = paste0("~/Desktop/fsc_gated_", reporter_name, ".csv"),
            append = F, quote = F, sep = ",",
            row.names = F, col.names = T)


## basic example of reading in 
a <- read.table("~/Desktop/fsc_gated_rpn4_TFT.csv",
                header = T, sep = ",")
a$reporter <- as.factor(rep("Rpn4 TFT", nrow(a)))

b <- read.table("~/Desktop/fsc_gated_0662_TFT.csv",
                header = T, sep = ",")
b$reporter <- as.factor(rep("Tyr TFT", nrow(b)))

c <- rbind(a, b)

## basic levelplot conditioned on strain and reporter
levelplot(TFT_ratio ~ strain * reporter,
          data = c)


my.at=c(min(values(r)), 0,1,5,10,15,20,25,30,40,50,75,100,150,200, max(values(r)))
my.brks=seq(0, 200, by=13)

TFT_cols   <- diverging_hcl(n = 11, h = c(90, 180), c = 70, l = 90)
TFT_breaks <- seq(from = -4, to = 1, by = 0.5)
TFT_labels <- TFT_breaks

TFT_key <- list(at = TFT_breaks,
                labels = list(at = TFT_labels,
                              labels = TFT_labels),
                space = "right")

out <- levelplot(TFT_ratio ~ strain * reporter,
                 data = c,
                 colorkey = TFT_key,
                 col.regions = TFT_cols,
                 at = TFT_breaks)
print(out)


## basic density plot that compares groups w/in a 
## plot and splits reporter into separate plots
## line cols, x axis limits, and line width custom set
densityplot(~ TFT_ratio | reporter,
            groups = strain,
            data = c,
            plot.points = F,
            auto.key = list(space = "top"),
            par.settings = list(superpose.line = list(col = all_cols)),
            scales = list(alternating = F),
            lwd = 2.5,
            xlim = c(-4, 1))

str(make.groups(c$replicate, c$strain))
combn(x = letters[1:4], 2)

b$strain_rep <- as.factor(paste0(b[, "strain"], "_", b[, "replicate"]))
sr_cols <- list()
for (i in 1:length(all_cols)) {
    sr_cols[[i]] <- rep(all_cols[i], 8)
}
sr_cols <- unlist(sr_cols)

densityplot(replicate ~ TFT_ratio | reporter,
            groups = strain_rep,
            data = c,
            plot.points = F,
            auto.key = F,
            par.settings = list(superpose.line = list(col = sr_cols)),
            scales = list(alternating = F),
            lwd = 1,
            xlim = c(-4, 1))

densityplot(~ TFT_ratio | reporter,
            data = c,
            plot.points = F,
            auto.key = F,
            panel = function(x, ...){
                panel.densityplot(x = x,
                                  plot.points = F)
            },
            scales = list(alternating = F),
            lwd = 1,
            xlim = c(-4, 1))


## implement xy scatter plots
## https://rstudio-pubs-static.s3.amazonaws.com/12556_4e02f5564dc24b57b7a8f6d95d2a5cf7.html
## xyplot(y ~ z, asp = 1, panel = panel.smoothScatter, nbin = 150)
xyplot(log_RFP ~ log_GFP | reporter * strain,
       data = c,
       panel = panel.smoothScatter,
       nbin = 140,
       xlim = c(2.5, 5))

xyplot(log_RFP ~ log_GFP | reporter,
       groups = strain,
       data = c,
       pch = ".",
       cex = 2,
       nbin = 140,
       xlim = c(2.5, 5))


c$strain[1] == names(all_cols[])

c$strain_rep <- as.factor(paste0(c$strain, "_", c$replicate))



densityplot(~ TFT_ratio | reporter,
            groups = strain_rep,
            data = c,
            plot.points = F,
            xlim = c(-4, 1))


densityplot(~ TFT_ratio | reporter,
            groups = strain,
            data = c,
            xlim = c(-4, 1),
            scales = list(alternating = F),
            grid = T,
            plot.points = F,
            lwd = 2,
            col = all_cols,
            par.settings = list(strip.background = list(col = gray(0.9))),
            key = list(text = list(names(all_cols)),
                       rectangles = list(col = all_cols)))


ord <- order(c$strain)
kk <- c[ord, ]
cc <- order(names(all_cols))
all_cols <- all_cols[cc]



## 2020.11.30 - needs to incorporate the ordering above
## plus figure out a way to code the replicate colors -
## basically needs to be a repetition of each color n replciate times
## demo of using logical subsetting
## ddd$strain[1] == names(all_cols)
## regexp filter on unique(c$strain_rep)?
pdf(file = "~/Desktop/density_test.pdf", height = 5, width = 10)
print(
densityplot(~ TFT_ratio | reporter,
            groups = strain_rep,
            data = c,
            xlim = c(-4, 1.25),
            scales = list(alternating = F),
            grid = T,
            plot.points = F,
            lwd = 2,
            col = all_cols,
            par.settings = list(strip.background = list(col = gray(0.9))),
            key = list(text = list(names(all_cols[c(1, 3, 4, 5, 2)])),
                       rectangles = list(col = all_cols[c(1, 3, 4, 5, 2)])),
            panel = function(x, y, q, subscripts, ...) {
                xx <- rep(all_cols, each = 8)
                panel.grid(h = -1, v = -1)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = c$strain_rep,
                                  subscripts = subscripts,
                                  lty = 1,
                                  col = xx,
                                  lwd = 1)
                panel.densityplot(x,
                                  plot.points = F,
                                  groups = c$strain,
                                  subscripts = subscripts,
                                  lty = 1,
                                  lwd = 4,
                                  col = all_cols,
                                  ylim = c(0, 2))
            })
)
dev.off()

levelplot(TFT_ratio ~ reporter * strain,
          strip = T,
          data = c,
          pretty = T,
          border = gray(0.7),
          border.lwd = 2)
          


## basic working TFT_ratio ~ strain plot
## this shows all values, so not
## esp. useful 
stripplot(TFT_ratio ~ strain | reporter,
          data = c,
          jitter = T)

stripplot(TFT_ratio ~ strain | reporter,
          groups = strain_rep,
          data = c,
          panel = function(x, y, q, subscripts, ...) {
              panel.points( )
              panel.stripplot(x, y,
                              subscripts = subscripts,
                              groups = c$strain,
                              jitter.data = T,
                              horizontal = F,
                              factor = 2.5)
              })

ccc <- aggregate(x = c, by = list(c$strain_rep), FUN = function(x) {
          ifelse(is.numeric(x), mean(x), as.factor(x))
          })

## 'aggregate' creates a new dataframe from x by applying FUN to
## all unique combinations of the factors supplied to the 'by'
## argument - in this case, grab the mean of numeric data and
## keep everything else a factor 
ddd <- aggregate.data.frame(x = c,
                            by = list(c$strain, c$reporter, c$replicate),
                            FUN = function(x) {
                                ifelse(is.numeric(x), mean(x), as.factor(x))
                            })

## 'aggregate' seems to strip the levels from factors, so add
## these back using the values present in the original dataframe
ddd$strain <- factor(ddd$strain,
                     levels = unique(ddd$strain),
                     labels = levels(c$strain))

ddd$reporter <- factor(ddd$reporter,
                     levels = unique(ddd$reporter),
                     labels = levels(c$reporter))

## need a color vector that maps to strains that's the
## length of levels(strain) * levels(replicate) (usually 40)
ddd_cols <- vector()
for (i in 1:nrow(ddd)) {
    ddd_cols[i] <- all_cols[ddd$strain[i] == names(all_cols)]
}

## now, re-order strain to present levels in the order
## I'd like (BY, RM, rpn4, ubr1, doa10) instead of the
## default alphabetical order
ddd$out_fac <- factor(ddd$strain, levels = levels(ddd$strain)[c(1, 3, 4, 5, 2)])

pdf(file = "~/Desktop/strip_test.pdf", height = 6, width = 10)
print(
stripplot(TFT_ratio ~ out_fac | reporter,
          data = ddd,
          col = gray(0),
          fill = ddd_cols,
          pch = 21,
          cex = 1.1,
          
          scales = list(alternating = F),
          layout = c(2, 1),
          grid = T,
          par.settings = list(strip.background = list(col = gray(0.9))),
          jitter.data = T,
          ## factor for jittering
          factor = 1.25,
          horizontal = F)
)
dev.off()
expression(paste("rpn4", Delta))

rr <- colorRampPalette(c(gray(0.4), "white", "#882255"))
rr <- colorRampPalette(c("white", "#C92AA4"))
rr <- colorRampPalette(c("white", "black"))
## needs x axis label

pdf(file = "~/Desktop/heat_test.pdf", height = 4, width = 9)
print(
levelplot(TFT_ratio ~ out_fac * reporter,
          strip = T,
          xlab = "Strain",
          ylab = "Reporter",
          data = ddd,
          pretty = T,
          ## col.regions = gray(100:0/100)),
          col.regions = rr(20),
          border = gray(0.3),
          border.lwd = 2)
)
dev.off()


## adds a grid via 'type = c("g")'
xyplot(log_GFP ~ log_RFP,
       data = c,
       panel = function(x, y, ...) {
           panel.fill(col = gray(1))
           panel.grid(h = -1, v = -1,
                      col.line = gray(0.9), lwd = 1.5)
           panel.xyplot(x, y,
                        type = "p",
                        pch = ".",
                        cex = 2,
                        col.symbol = rgb(0, 0, 0, 0.01)
                      )
}
)


## you can 'rbind' the dataframes together 
## a <- data.frame(a = 1:5, b = 11:15)
## b <- data.frame(a = 6:10, b = 16:20)
## c <- rbind(a, b) ## works

#+END_SRC

# need to figure out how to plot delta symbols
# https://stats.idre.ucla.edu/r/codefragments/greek_letters/
#+BEGIN_SRC R :results graphics :file /tmp/delta.pdf
barplot(c(4,4,4), ylab = expression(paste("BY rpn4", Delta)))
#+END_SRC

#+RESULTS:
[[file:/tmp/delta.pdf]]

* Local Variables                                                  :noexport:
Local Variables:
org-confirm-elisp-link-function: nil
End:
